<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>NEURAL QUAKE ARENA // V3.0</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Deep Space theme - softer than pure black */
      --bg-dark: #0b0c15;
      --bg-darker: #070810;
      --panel-bg: rgba(15, 20, 35, 0.70);
      --panel-bg-solid: #0f1423;

      /* Neon accents with glow-friendly values */
      --neon-blue: #00f3ff;
      --neon-pink: #ff0055;
      --neon-green: #00ff9d;
      --neon-yellow: #ffd700;
      --laser-blue: #00aaff;

      /* Team colors - slightly softer */
      --team-red: #ff4466;
      --team-red-glow: rgba(255, 68, 102, 0.4);
      --team-blue: #4499ff;
      --team-blue-glow: rgba(68, 153, 255, 0.4);

      /* Text hierarchy */
      --text-main: #e0e6ed;
      --text-muted: #7a8599;
      --text-dim: #4a5568;

      /* Borders and surfaces */
      --border-color: rgba(255, 255, 255, 0.08);
      --border-glow: rgba(0, 243, 255, 0.3);
      --surface-hover: rgba(255, 255, 255, 0.05);
    }

* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: var(--bg-dark);
  background-image: radial-gradient(ellipse at 50% 0%, rgba(20, 30, 50, 0.4) 0%, transparent 60%);
  color: var(--text-main);
  font-family: 'Rajdhani', sans-serif;
  overflow: hidden;
  height: 100vh;
  height: 100dvh;
}

/* === NEW LAYOUT: Top bar + Game + Right sidebar === */
#app {
  display: flex;
  flex-direction: column;
  height: 100%;
}

/* TOP BAR - Scores */
#top-bar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
  padding: 12px 20px;
  background: rgba(8, 10, 18, 0.9);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-bottom: 1px solid rgba(0, 243, 255, 0.2);
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5), 0 1px 0 rgba(0, 243, 255, 0.1);
  flex-shrink: 0;
  position: relative;
  z-index: 150; /* Above sidebars */
}

.team-block {
  display: flex;
  align-items: center;
  gap: 15px;
}
.team-block.red { flex-direction: row; }
.team-block.blue { flex-direction: row; }

.team-score {
  text-align: center;
}
.team-score .score {
  font-family: 'JetBrains Mono', monospace;
  font-size: 2.5rem;
  font-weight: bold;
  text-shadow: 0 0 20px currentColor;
  line-height: 1;
}
.team-score .label {
  font-size: 0.7rem;
  opacity: 0.7;
  text-transform: uppercase;
}
.team-block.red .team-score { color: var(--team-red); text-shadow: 0 0 20px var(--team-red-glow), 0 0 40px var(--team-red-glow); }
.team-block.blue .team-score { color: var(--team-blue); text-shadow: 0 0 20px var(--team-blue-glow), 0 0 40px var(--team-blue-glow); }

.team-wins {
  text-align: center;
  padding: 6px 14px;
  background: rgba(255,255,255,0.03);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  transition: all 0.2s ease;
}
.team-wins:hover {
  background: var(--surface-hover);
}
.team-wins .wins {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.4rem;
  font-weight: bold;
}
.team-wins .label {
  font-size: 0.55rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.team-block.red .team-wins { color: var(--team-red); }
.team-block.blue .team-wins { color: var(--team-blue); }

/* Top Lives display (persistent mode) */
.team-top-lives {
  display: none;
  font-size: 0.7rem;
  align-items: stretch;
  gap: 10px;
}
body.persistent-mode .team-wins {
  display: none;
}
body.persistent-mode .team-top-lives {
  display: flex;
}

/* Section labels */
.team-top-lives .section-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.5rem;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
  opacity: 0.7;
}

/* Average score section */
.avg-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 8px 12px;
  background: rgba(255,255,255,0.03);
  border-radius: 6px;
  border: 1px solid var(--border-color);
  min-width: 60px;
}
.avg-section .avg-value {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.3rem;
  font-weight: bold;
  line-height: 1;
}
.team-block.red .avg-section .avg-value { color: var(--team-red); text-shadow: 0 0 10px var(--team-red-glow); }
.team-block.blue .avg-section .avg-value { color: var(--team-blue); text-shadow: 0 0 10px var(--team-blue-glow); }

/* Gene pool section */
.gene-pool-section {
  display: flex;
  flex-direction: column;
}
.top-lives-list {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.top-life-entry {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  padding: 2px 8px;
  background: rgba(255,255,255,0.02);
  border-radius: 3px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
}
.top-life-entry .rank {
  opacity: 0.6;
  min-width: 18px;
}
.top-life-entry .name {
  flex: 1;
  opacity: 0.9;
  max-width: 70px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.top-life-entry .kills {
  font-weight: bold;
  min-width: 30px;
  text-align: right;
}
.team-block.red .top-life-entry .kills { color: var(--team-red); }
.team-block.blue .top-life-entry .kills { color: var(--team-blue); }
.top-lives-empty {
  color: var(--text-dim);
  font-size: 0.6rem;
  font-style: italic;
  padding: 8px;
  text-align: center;
}

#center-info {
  text-align: center;
  padding: 0 20px;
  border-left: 1px solid var(--border-color);
  border-right: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}
/* Segmented mode selector */
.mode-selector {
  display: flex;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid var(--border-color);
}
.mode-selector button {
  padding: 6px 14px;
  border: none;
  background: transparent;
  color: #666;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  font-weight: bold;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
}
.mode-selector button:hover {
  color: var(--text-main);
  background: rgba(255, 255, 255, 0.08);
}
.mode-selector button.active {
  background: var(--neon-green);
  color: #000;
  box-shadow: 0 0 15px rgba(0, 255, 157, 0.4);
}
.mode-selector button.active:hover {
  background: var(--neon-green);
}
#center-info .big {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.8rem;
  color: var(--neon-green);
  font-weight: 800;
  line-height: 1;
  text-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
}
#center-info .sub {
  font-size: 0.6rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Pre-simulation info screen */
#pre-sim-screen {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle at center, rgba(13, 13, 25, 0.97) 0%, rgba(5, 5, 16, 0.99) 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 120; /* Above headless-overlay (100) */
  padding: 40px;
  text-align: center;
}
#pre-sim-screen.hidden {
  display: none;
}
#pre-sim-screen .mode-title {
  font-family: 'JetBrains Mono', monospace;
  font-size: 2rem;
  font-weight: bold;
  color: var(--neon-green);
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 3px;
}
#pre-sim-screen .mode-subtitle {
  font-size: 1rem;
  color: var(--neon-blue);
  margin-bottom: 30px;
}
#pre-sim-screen .mode-description {
  max-width: 500px;
  font-size: 0.9rem;
  color: #aaa;
  line-height: 1.6;
  margin-bottom: 30px;
}
#pre-sim-screen .mode-features {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 40px;
  text-align: left;
}
#pre-sim-screen .feature {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 0.85rem;
  color: #888;
}
#pre-sim-screen .feature .icon {
  color: var(--neon-green);
  font-size: 1rem;
}
#pre-sim-screen .start-btn {
  padding: 15px 50px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.1rem;
  font-weight: bold;
  background: var(--neon-green);
  color: #000;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 2px;
  transition: all 0.2s;
}
#pre-sim-screen .start-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 0 30px rgba(0, 255, 157, 0.4);
}

/* Modifiers Dropdown in Top Bar */
#modifiers-dropdown {
  position: absolute;
  left: 15px;
  top: 50%;
  transform: translateY(-50%);
}
#modifiers-btn {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid var(--border-color);
  color: #888;
  font-size: 0.85rem;
  padding: 8px 14px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
}
#modifiers-btn:hover {
  background: rgba(0, 200, 255, 0.1);
  border-color: var(--neon-blue);
  color: var(--neon-blue);
}
#modifiers-btn.active {
  background: rgba(0, 200, 255, 0.2);
  border-color: var(--neon-blue);
  color: var(--neon-blue);
}
#modifiers-menu {
  position: absolute;
  top: calc(100% + 8px);
  left: 0;
  min-width: 280px;
  background: rgba(12, 15, 25, 0.95);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  z-index: 200;
  padding: 12px 0;
  display: none;
}
#modifiers-menu.open {
  display: block;
}
#modifiers-menu .menu-category {
  padding: 8px 16px 4px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.6rem;
  font-weight: 700;
  color: var(--neon-blue);
  text-transform: uppercase;
  letter-spacing: 1px;
  opacity: 0.7;
}
#modifiers-menu .menu-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
  cursor: pointer;
  transition: background 0.15s;
}
#modifiers-menu .menu-item:hover {
  background: rgba(255, 255, 255, 0.05);
}
#modifiers-menu .menu-item label {
  font-size: 0.85rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
}
#modifiers-menu .menu-divider {
  height: 1px;
  background: rgba(255, 255, 255, 0.1);
  margin: 8px 16px;
}
#modifiers-menu .weapon-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
}
#modifiers-menu .weapon-row label {
  font-size: 0.85rem;
}

/* Slide-in Stats Panel */
#stats-panel {
  position: fixed;
  top: 0;
  right: -320px;
  width: 300px;
  height: 100vh;
  background: rgba(12, 15, 25, 0.78);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border-left: 1px solid var(--border-color);
  box-shadow: -10px 0 40px rgba(0, 0, 0, 0.5);
  z-index: 1000;
  transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  overflow-y: auto;
  padding: 20px;
  padding-top: 70px; /* Space for top-bar */
}
#stats-panel.open {
  right: 0;
}
#stats-panel h3 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  font-weight: 700;
  color: var(--neon-blue);
  text-transform: uppercase;
  letter-spacing: 2px;
  margin: 24px 0 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(0, 243, 255, 0.2);
  text-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
  display: flex;
  align-items: center;
  gap: 8px;
}
#stats-panel h3::before {
  content: '//';
  opacity: 0.5;
}
#stats-panel h3:first-child {
  margin-top: 0;
}
#stats-panel .close-btn {
  position: absolute;
  top: 70px;
  right: 12px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: var(--text-muted);
  font-size: 1.2rem;
  width: 32px;
  height: 32px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}
#stats-panel .close-btn:hover {
  background: rgba(255, 0, 85, 0.2);
  border-color: var(--neon-pink);
  color: var(--neon-pink);
}
#stats-panel .stat-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  font-size: 0.85rem;
  border-bottom: 1px dashed rgba(255,255,255,0.05);
}
#stats-panel .stat-value {
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
}
#stats-panel .hof-entry {
  display: flex;
  justify-content: space-between;
  padding: 4px 8px;
  margin: 2px 0;
  background: rgba(255,255,255,0.02);
  border-radius: 3px;
  font-size: 0.8rem;
}
#stats-panel .team-section {
  margin-bottom: 15px;
}
#stats-panel .team-header {
  font-size: 0.75rem;
  font-weight: bold;
  margin-bottom: 5px;
}

/* Floating Control Bar */
#control-bar {
  position: fixed;
  bottom: 25px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(12, 15, 25, 0.80);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 50px;
  padding: 10px 20px;
  z-index: 100;
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.05);
}
#control-bar .control-group {
  display: flex;
  align-items: center;
  gap: 4px;
}
#control-bar .control-group.main-controls {
  padding: 0 12px;
  border-left: 1px solid var(--border-color);
  border-right: 1px solid var(--border-color);
}
#control-bar button {
  width: 46px;
  height: 46px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(255, 255, 255, 0.03);
  color: var(--text-muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.25s ease;
  position: relative;
}
#control-bar button:hover {
  background: rgba(0, 200, 255, 0.15);
  border-color: var(--neon-blue);
  color: var(--neon-blue);
  box-shadow: 0 0 20px rgba(0, 243, 255, 0.3), inset 0 0 10px rgba(0, 243, 255, 0.1);
  transform: translateY(-2px);
}
#control-bar button.active {
  background: rgba(0, 255, 157, 0.2);
  border-color: var(--neon-green);
  color: var(--neon-green);
  box-shadow: 0 0 20px rgba(0, 255, 157, 0.3), inset 0 0 10px rgba(0, 255, 157, 0.1);
}
#control-bar button svg {
  width: 26px;
  height: 26px;
}
/* Tooltip for control bar buttons */
#control-bar button[data-tooltip]:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  color: #fff;
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 0.75rem;
  white-space: nowrap;
  margin-bottom: 8px;
  pointer-events: none;
  z-index: 1000;
}
#control-bar .play-btn {
  width: 58px;
  height: 58px;
  background: rgba(0, 255, 157, 0.15);
  border: 2px solid var(--neon-green);
  color: var(--neon-green);
  box-shadow: 0 0 25px rgba(0, 255, 157, 0.25), inset 0 0 15px rgba(0, 255, 157, 0.1);
}
#control-bar .play-btn:hover {
  background: rgba(0, 255, 157, 0.25);
  box-shadow: 0 0 35px rgba(0, 255, 157, 0.4), inset 0 0 20px rgba(0, 255, 157, 0.15);
  transform: translateY(-2px) scale(1.05);
}
#control-bar .play-btn svg {
  width: 30px;
  height: 30px;
}
#control-bar .play-btn .pause-icon {
  display: none;
}
#control-bar .play-btn.paused .play-icon {
  display: block;
}
#control-bar .play-btn.paused .pause-icon {
  display: none;
}
#control-bar .play-btn:not(.paused) .play-icon {
  display: none;
}
#control-bar .play-btn:not(.paused) .pause-icon {
  display: block;
}

/* MAIN AREA - Canvas + Sidebars */
#main-area {
  display: flex;
  flex: 1;
  overflow: hidden;
  justify-content: center;
  position: relative;
}

/* LEFT SIDEBAR - Stats & Controls */
#left-sidebar {
  position: fixed;
  left: -280px;
  top: 0;
  width: 260px;
  height: 100vh;
  background: rgba(12, 15, 25, 0.78);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border-right: 1px solid var(--border-color);
  box-shadow: 10px 0 40px rgba(0, 0, 0, 0.5);
  padding: 20px;
  padding-top: 70px; /* Space for top-bar */
  display: flex;
  flex-direction: column;
  gap: 8px;
  overflow-y: auto;
  z-index: 1000;
  transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
#left-sidebar.open {
  left: 0;
}
#left-sidebar .close-btn {
  position: absolute;
  top: 70px;
  right: 12px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: var(--text-muted);
  font-size: 1.2rem;
  width: 32px;
  height: 32px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}
#left-sidebar .close-btn:hover {
  background: rgba(255, 0, 85, 0.2);
  border-color: var(--neon-pink);
  color: var(--neon-pink);
}

/* Sidebar toggle buttons - glowing edge tabs */
.sidebar-toggle {
  position: fixed;
  top: 50%;
  transform: translateY(-50%);
  width: 28px;
  height: 100px;
  background: linear-gradient(180deg, rgba(0, 243, 255, 0.15) 0%, rgba(0, 150, 200, 0.1) 100%);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(0, 243, 255, 0.4);
  cursor: pointer;
  z-index: 1001;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  color: var(--neon-blue);
  font-size: 14px;
  box-shadow: 0 0 20px rgba(0, 243, 255, 0.2), inset 0 0 15px rgba(0, 243, 255, 0.1);
}
.sidebar-toggle::before {
  content: '';
  position: absolute;
  top: 15%;
  bottom: 15%;
  width: 3px;
  background: linear-gradient(180deg, transparent, var(--neon-blue), transparent);
  opacity: 0.6;
  border-radius: 2px;
}
.sidebar-toggle.left::before { right: 6px; }
.sidebar-toggle.right::before { left: 6px; }
.sidebar-toggle:hover {
  background: linear-gradient(180deg, rgba(0, 243, 255, 0.3) 0%, rgba(0, 200, 255, 0.2) 100%);
  border-color: var(--neon-blue);
  box-shadow: 0 0 30px rgba(0, 243, 255, 0.4), inset 0 0 20px rgba(0, 243, 255, 0.2);
  color: #fff;
}
.sidebar-toggle.left {
  left: 0;
  border-radius: 0 14px 14px 0;
  border-left: none;
}
.sidebar-toggle.right {
  right: 0;
  border-radius: 14px 0 0 14px;
  border-right: none;
}
.sidebar-toggle.left.open {
  left: 260px;
}
.sidebar-toggle.right.open {
  right: 300px;
}
.sidebar-toggle svg {
  width: 16px;
  height: 16px;
  transition: transform 0.3s ease;
  filter: drop-shadow(0 0 4px currentColor);
}
.sidebar-toggle.left.open svg {
  transform: rotate(180deg);
}
.sidebar-toggle.right.open svg {
  transform: rotate(180deg);
}

/* CANVAS */
#canvas-container {
  flex: 1;
  position: relative;
  background: #000;
  overflow: hidden;
  min-height: 0;
}
canvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
}

/* PANELS - matching stats-panel style */
.panel {
  margin-bottom: 8px;
}
.panel h2 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  font-weight: 700;
  color: var(--neon-blue);
  text-transform: uppercase;
  letter-spacing: 2px;
  margin: 24px 0 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(0, 243, 255, 0.2);
  text-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: grab;
  user-select: none;
}
.panel:first-child h2 {
  margin-top: 0;
}
.panel.dragging {
  opacity: 0.9;
  z-index: 1000;
  box-shadow: 0 8px 32px rgba(0, 200, 255, 0.3);
  pointer-events: none;
}
.panel.dragging h2 {
  cursor: grabbing;
}
.panel.drag-over {
  border-color: var(--neon-green);
  background: rgba(0, 255, 136, 0.05);
}
#left-sidebar {
  display: flex;
  flex-direction: column;
}
#left-sidebar .panel {
  transition: transform 0.25s cubic-bezier(0.2, 0, 0, 1), opacity 0.15s ease;
}
.panel.placeholder {
  visibility: hidden;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  font-size: 0.85rem;
  border-bottom: 1px dashed rgba(255,255,255,0.05);
}
.stat-value {
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
}

/* TOGGLES */
.toggle-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
  transition: all 0.2s ease;
}
.toggle-row:hover {
  background: rgba(255, 255, 255, 0.02);
  margin: 0 -8px;
  padding: 8px;
  border-radius: 4px;
}
.toggle-row label {
  font-size: 0.8rem;
  color: var(--text-muted);
  transition: color 0.2s ease;
}
.toggle-row:hover label {
  color: var(--text-main);
}
.toggle {
  width: 42px;
  height: 22px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 11px;
  cursor: pointer;
  position: relative;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.toggle:hover {
  border-color: rgba(255, 255, 255, 0.2);
}
.toggle::after {
  content: '';
  position: absolute;
  top: 2px; left: 2px;
  width: 16px; height: 16px;
  background: linear-gradient(135deg, #666, #444);
  border-radius: 50%;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}
.toggle.active {
  background: rgba(0, 255, 157, 0.25);
  border-color: var(--neon-green);
  box-shadow: 0 0 15px rgba(0, 255, 157, 0.3), inset 0 0 8px rgba(0, 255, 157, 0.2);
}
.toggle.active::after {
  transform: translateX(20px);
  background: linear-gradient(135deg, var(--neon-green), #00cc7a);
  box-shadow: 0 0 10px var(--neon-green), 0 2px 4px rgba(0, 0, 0, 0.3);
}
.toggle.disabled { opacity: 0.3; cursor: not-allowed; }

/* WEAPON SELECTOR */
.weapon-selector {
  display: flex;
  gap: 5px;
}
.weapon-btn {
  background: var(--panel-bg);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 4px 10px;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0.5;
}
.weapon-btn:hover {
  opacity: 0.8;
  border-color: rgba(255, 255, 255, 0.2);
}
.weapon-btn.active {
  opacity: 1;
  background: linear-gradient(135deg, var(--neon-green), #00cc7a);
  border-color: var(--neon-green);
  box-shadow: 0 0 8px var(--neon-green);
}

/* SLIDERS */
.control-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
}
.control-row label {
  width: 40px;
  flex-shrink: 0;
  font-size: 0.75rem;
  color: #adb5bd;
}
input[type="range"] {
  -webkit-appearance: none;
  flex: 1;
  min-width: 60px;
  height: 6px;
  background: linear-gradient(to right, rgba(0, 243, 255, 0.2), rgba(255, 255, 255, 0.05));
  border-radius: 3px;
  border: 1px solid rgba(255, 255, 255, 0.08);
  cursor: pointer;
  transition: all 0.2s ease;
}
input[type="range"]:hover {
  background: linear-gradient(to right, rgba(0, 243, 255, 0.3), rgba(255, 255, 255, 0.08));
  border-color: rgba(0, 243, 255, 0.3);
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 16px;
  width: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--neon-blue), #0088aa);
  cursor: pointer;
  box-shadow: 0 0 12px var(--neon-blue), 0 2px 4px rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  transition: all 0.2s ease;
}
input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.15);
  box-shadow: 0 0 20px var(--neon-blue), 0 2px 8px rgba(0, 0, 0, 0.4);
}
input[type="range"]::-moz-range-thumb {
  height: 16px;
  width: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--neon-blue), #0088aa);
  cursor: pointer;
  box-shadow: 0 0 12px var(--neon-blue);
  border: 2px solid rgba(255, 255, 255, 0.2);
}
input[type="range"]::-moz-range-track {
  height: 6px;
  background: linear-gradient(to right, rgba(0, 243, 255, 0.2), rgba(255, 255, 255, 0.05));
  border-radius: 3px;
}
.control-row .value {
  min-width: 40px;
  width: 40px;
  flex-shrink: 0;
  text-align: right;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.75rem;
  color: var(--neon-blue);
  text-shadow: 0 0 8px rgba(0, 243, 255, 0.4);
}

/* BUTTONS */
button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: rgba(0, 243, 255, 0.1);
  border: 1px solid var(--neon-blue);
  color: var(--neon-blue);
  padding: 10px 16px;
  border-radius: 2px;
  cursor: pointer;
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
  font-size: 0.8rem;
  text-transform: uppercase;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}
button:hover {
  background: var(--neon-blue);
  color: #000;
  box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
}
button.secondary {
  border-color: #666;
  color: #aaa;
  background: transparent;
}
button.secondary:hover {
  border-color: #fff;
  color: #fff;
  background: rgba(255,255,255,0.1);
  box-shadow: none;
}
.btn-row {
  display: flex;
  gap: 10px;
}
.btn-row button { flex: 1; }

/* SCROLLBARS */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb {
  background: var(--neon-blue);
  border-radius: 4px;
  border: 2px solid transparent;
  background-clip: padding-box;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--neon-green);
  border: 2px solid transparent;
  background-clip: padding-box;
}

/* AGENT PROFILE CARD */
#agent-profile {
  font-size: 0.75rem;
}
#profile-header {
  margin-bottom: 8px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}
.agent-name {
  font-size: 1rem;
  font-weight: bold;
  font-family: 'JetBrains Mono', monospace;
}
.agent-team {
  font-size: 0.7rem;
  opacity: 0.6;
  text-transform: uppercase;
}
.profile-section {
  margin: 8px 0;
  padding: 6px 0;
  border-bottom: 1px dashed rgba(255,255,255,0.05);
}
.profile-section:last-child {
  border-bottom: none;
}
.section-label {
  font-size: 0.65rem;
  text-transform: uppercase;
  opacity: 0.5;
  margin-bottom: 6px;
  letter-spacing: 1px;
}
.profile-bars {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.bar-row {
  display: flex;
  align-items: center;
  gap: 6px;
}
.bar-label {
  width: 20px;
  font-size: 0.65rem;
  opacity: 0.7;
}
.bar-track {
  flex: 1;
  height: 8px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
  overflow: hidden;
}
.bar-fill {
  height: 100%;
  transition: width 0.15s ease-out;
}
.health-fill {
  background: linear-gradient(90deg, #ff4444, #ff6666);
}
.armor-fill {
  background: linear-gradient(90deg, #4488ff, #66aaff);
}
.bar-value {
  width: 24px;
  text-align: right;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
}
.neural-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 4px;
  text-align: center;
}
.neural-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}
.neural-indicator span {
  font-size: 0.55rem;
  opacity: 0.6;
}
.indicator-bar {
  width: 6px;
  height: 28px;
  background: rgba(255,255,255,0.1);
  border-radius: 3px;
  position: relative;
  overflow: hidden;
}
.indicator-bar::after {
  content: '';
  position: absolute;
  bottom: 50%;
  left: 0;
  right: 0;
  height: var(--bar-height, 0%);
  background: var(--neon-green);
  transition: height 0.1s, bottom 0.1s, top 0.1s;
  box-shadow: 0 0 4px var(--neon-green);
}
.indicator-bar.positive::after {
  bottom: 50%;
  top: auto;
  background: var(--neon-green);
  box-shadow: 0 0 4px var(--neon-green);
}
.indicator-bar.negative::after {
  bottom: auto;
  top: 50%;
  background: var(--neon-pink);
  box-shadow: 0 0 4px var(--neon-pink);
}
.indicator-light {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  transition: all 0.1s;
}
.indicator-light.active {
  background: var(--neon-green);
  box-shadow: 0 0 8px var(--neon-green);
  border-color: var(--neon-green);
}
.awareness-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
  font-size: 0.7rem;
}
.awareness-value {
  font-family: 'JetBrains Mono', monospace;
  color: var(--neon-blue);
}

/* LEADERBOARD */
#leaderboard, #alltime-leaderboard {
  max-height: 140px;
  overflow-y: auto;
}
.leader-entry {
  display: flex;
  justify-content: space-between;
  padding: 4px 6px;
  font-size: 0.75rem;
  margin-bottom: 2px;
  background: rgba(255,255,255,0.02);
  border-radius: 2px;
}
.leader-entry .name {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.leader-entry .score {
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
}
.leader-entry.dead { opacity: 0.3; }

/* EVENT LOG */
#event-log {
  max-height: 100px;
  overflow-y: auto;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
}
.event { padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.03); }
.event .kill { color: var(--neon-pink); }
.event .damage { color: var(--neon-yellow); }
.event .pickup { color: var(--neon-green); }
.event .laser { color: var(--laser-blue); }

#load-file { display: none; }

/* HEADLESS OVERLAY */
#headless-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(5, 5, 16, 0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}
#headless-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}
#headless-overlay .icon {
  font-size: 4rem;
  margin-bottom: 20px;
}
#headless-overlay h2 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.5rem;
  color: var(--neon-green);
  text-transform: uppercase;
  letter-spacing: 3px;
  margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
}
#headless-overlay p {
  color: #888;
  font-size: 0.9rem;
  margin-bottom: 25px;
}
#headless-overlay .hint {
  background: rgba(0, 255, 157, 0.1);
  border: 1px solid rgba(0, 255, 157, 0.3);
  border-radius: 6px;
  padding: 15px 25px;
  color: #aaa;
  font-size: 0.85rem;
}
#headless-overlay .hint strong {
  color: var(--neon-green);
}

  </style>
</head>
<body>
  <div id="app">
    <!-- TOP BAR: Scores & Match Info -->
    <div id="top-bar">
      <div id="modifiers-dropdown">
        <button id="modifiers-btn" title="Game Modifiers">‚öôÔ∏è Modifiers</button>
        <div id="modifiers-menu">
          <div class="menu-category">Pickups</div>
          <div class="menu-item">
            <label for="mod-health">ü©π Health Spawns</label>
            <div class="toggle active" id="mod-health"></div>
          </div>
          <div class="menu-item">
            <label for="mod-armor">üõ°Ô∏è Armor Spawns</label>
            <div class="toggle active" id="mod-armor"></div>
          </div>
          <div class="menu-item">
            <label for="mod-laser">‚ö° Laser Drops</label>
            <div class="toggle active" id="mod-laser"></div>
          </div>
          <div class="menu-item">
            <label for="mod-sword">üó°Ô∏è Sword Drops</label>
            <div class="toggle active" id="mod-sword"></div>
          </div>
          <div class="menu-divider"></div>
          <div class="menu-category">Abilities</div>
          <div class="menu-item">
            <label for="mod-dodge">üí® Dodging</label>
            <div class="toggle active" id="mod-dodge"></div>
          </div>
          <div class="menu-item">
            <label for="mod-teleporter">üåÄ Teleporters</label>
            <div class="toggle active" id="mod-teleporter"></div>
          </div>
          <div class="menu-divider"></div>
          <div class="menu-category">Damage</div>
          <div class="menu-item">
            <label for="mod-ff">üí• Friendly Fire</label>
            <div class="toggle" id="mod-ff"></div>
          </div>
          <div class="menu-item">
            <label for="mod-ricochet">üîÑ FF Ricochet</label>
            <div class="toggle" id="mod-ricochet"></div>
          </div>
          <div class="menu-divider"></div>
          <div class="menu-category">Mode</div>
          <div class="menu-item" id="mod-no-respawn-row">
            <label for="mod-no-respawn">üíÄ No Respawn</label>
            <div class="toggle" id="mod-no-respawn"></div>
          </div>
          <div class="menu-item">
            <label for="mod-5x-hp">üí™ 5x HP</label>
            <div class="toggle" id="mod-5x-hp"></div>
          </div>
          <div class="menu-divider"></div>
          <div class="weapon-row">
            <label>üî´ Base Weapon</label>
            <div class="weapon-selector">
              <button class="weapon-btn active" id="mod-weapon-rocket" title="Rocket Launcher">üöÄ</button>
              <button class="weapon-btn" id="mod-weapon-rifle" title="SKS Rifle">üéØ</button>
            </div>
          </div>
        </div>
      </div>

      <div class="team-block red">
        <div class="team-wins">
          <div class="wins" id="red-wins">0</div>
          <div class="label">wins</div>
        </div>
        <div class="team-top-lives" id="red-top-lives">
          <div class="avg-section">
            <div class="section-label">AVG</div>
            <div class="avg-value" id="red-avg-life">0</div>
          </div>
          <div class="gene-pool-section">
            <div class="section-label">GENE POOL TOP 5</div>
            <div class="top-lives-list"></div>
          </div>
        </div>
        <div class="team-score">
          <div class="score" id="red-score">0</div>
          <div class="label">üî¥ RED</div>
        </div>
      </div>

      <div id="center-info">
        <div class="mode-selector">
          <button id="mode-rounds" class="active">Rounds</button>
          <button id="mode-persistent">Persistent</button>
        </div>
        <div class="big" id="kill-limit-display">50</div>
        <div class="sub" id="mode-sub">first to</div>
      </div>

      <div class="team-block blue">
        <div class="team-score">
          <div class="score" id="blue-score">0</div>
          <div class="label">BLUE üîµ</div>
        </div>
        <div class="team-wins">
          <div class="wins" id="blue-wins">0</div>
          <div class="label">wins</div>
        </div>
        <div class="team-top-lives" id="blue-top-lives">
          <div class="gene-pool-section">
            <div class="section-label">GENE POOL TOP 5</div>
            <div class="top-lives-list"></div>
          </div>
          <div class="avg-section">
            <div class="section-label">AVG</div>
            <div class="avg-value" id="blue-avg-life">0</div>
          </div>
        </div>
      </div>
</div>

<!-- MAIN AREA -->
<div id="main-area">
  <!-- Sidebar toggle buttons -->
  <button class="sidebar-toggle left" id="toggle-left-sidebar" title="Toggle Settings">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </button>
  <button class="sidebar-toggle right" id="toggle-right-sidebar" title="Toggle Stats">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
  </button>

  <!-- LEFT SIDEBAR: Stats & Controls -->
  <div id="left-sidebar">
    <button class="close-btn" id="close-left-sidebar">‚úï</button>
    <div class="panel" data-panel-id="status">
      <h2>// Status</h2>
      <div class="stat-row" id="generation-row">
        <span>Generation</span>
        <span class="stat-value" id="generation">1</span>
      </div>
      <div class="stat-row">
        <span>Alive</span>
        <span class="stat-value" id="alive">100</span>
      </div>
      <div class="stat-row">
        <span>Time</span>
        <span class="stat-value" id="time-left">60s</span>
      </div>
    </div>

    <div class="panel" data-panel-id="parameters">
      <h2>// Parameters</h2>
      <div class="control-row">
        <label>Zoom</label>
        <input type="range" id="zoom" min="100" max="400" value="100" />
        <span class="value" id="zoom-value">1.0x</span>
      </div>
      <div class="control-row">
        <label>Speed</label>
        <input type="range" id="speed" min="1" max="20" value="1" />
        <span class="value" id="speed-value">1x</span>
      </div>
      <div class="control-row">
        <label>Pop</label>
        <input type="range" id="population" min="20" max="200" value="100" step="10" />
        <span class="value" id="population-value">100</span>
      </div>
      <div class="control-row">
        <label>Time</label>
        <input type="range" id="round-time" min="1" max="10" value="1" step="1" />
        <span class="value" id="round-time-value">1m</span>
      </div>
      <div class="control-row">
        <label>Kills</label>
        <input type="range" id="kill-limit" min="10" max="100" value="50" step="5" />
        <span class="value" id="kill-limit-value">50</span>
      </div>
      <div class="control-row">
        <label>Respawn</label>
        <input type="range" id="respawn-time" min="1" max="10" value="3" step="1" />
        <span class="value" id="respawn-time-value">3s</span>
      </div>
    </div>

    <div class="panel" data-panel-id="controls">
      <h2>// Advanced</h2>
      <div class="btn-row">
        <button id="copy-btn" style="background: rgba(0, 255, 100, 0.2); border-color: #00ff64; color: #00ff64;">üìã COPY</button>
        <button id="demo-btn" style="background: rgba(255, 200, 0, 0.2); border-color: #ffc800; color: #ffc800;">üéÆ DEMO</button>
      </div>
      <div class="btn-row" style="margin-top:10px;">
        <button id="debug-sword-btn" style="background: rgba(255, 0, 255, 0.1); border-color: #ff00ff; color: #ff00ff;">üó°Ô∏è ALL SWORD</button>
        <button id="debug-laser-btn" style="background: rgba(0, 200, 255, 0.1); border-color: #00aaff; color: #00aaff;">‚ö° ALL LASER</button>
      </div>
      <input type="file" id="load-file" accept=".json" />
      <!-- Hidden elements for compatibility with existing code -->
      <button id="pause-btn" style="display:none;">PAUSE</button>
      <button id="restart-btn" style="display:none;">RESET</button>
      <button id="save-btn" style="display:none;">SAVE</button>
      <button id="load-btn" style="display:none;">LOAD</button>
      <button id="headless-btn" style="display:none;">HEADLESS</button>
      <button id="turbo-btn" style="display:none;">TURBO</button>
    </div>

    <div class="panel" data-panel-id="leaderboard">
      <h2>// Leaderboard</h2>
      <div id="leaderboard"></div>
    </div>
  </div>

  <!-- CANVAS -->
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="headless-overlay">
      <div class="icon">üñ•Ô∏è</div>
      <h2>Simulation Running in Headless Mode</h2>
      <p>Rendering is disabled for faster simulation speed.</p>
      <div class="hint">Toggle <strong>üñ•Ô∏è HEADLESS</strong> in Controls to view the battle.</div>
    </div>
    <!-- Pre-simulation info screen -->
    <div id="pre-sim-screen">
      <div class="mode-title" id="pre-sim-title">ROUNDS MODE</div>
      <div class="mode-subtitle" id="pre-sim-subtitle">Generation-based Evolution</div>
      <div class="mode-description" id="pre-sim-description">
        Teams battle in timed rounds. After each round, the losing team evolves by learning from the winners. Watch neural networks improve over generations.
      </div>
      <div class="mode-features" id="pre-sim-features">
        <div class="feature"><span class="icon">‚è±Ô∏è</span> Timed rounds with kill limit</div>
        <div class="feature"><span class="icon">üß¨</span> Losers evolve after each round</div>
        <div class="feature"><span class="icon">üèÜ</span> Track wins across generations</div>
      </div>
      <button class="start-btn" id="start-sim-btn">START SIMULATION</button>
    </div>
  </div>

</div>

<!-- Slide-in Stats Panel (accessed via right sidebar toggle) -->
<div id="stats-panel">
  <button class="close-btn" id="stats-close">&times;</button>

  <!-- Agent Profile Card (shown when following an agent) -->
  <div id="agent-profile" style="display: none; margin-bottom: 16px;">
    <h3>ü§ñ Agent Profile</h3>
    <div id="profile-header">
      <div class="agent-name" id="profile-name">-</div>
      <div class="agent-team" id="profile-team">-</div>
    </div>
    <div class="profile-section">
      <div class="profile-bars">
        <div class="bar-row">
          <span class="bar-label">HP</span>
          <div class="bar-track health-track">
            <div class="bar-fill health-fill" id="profile-health-bar"></div>
          </div>
          <span class="bar-value" id="profile-health-val">100</span>
        </div>
        <div class="bar-row">
          <span class="bar-label">AR</span>
          <div class="bar-track armor-track">
            <div class="bar-fill armor-fill" id="profile-armor-bar"></div>
          </div>
          <span class="bar-value" id="profile-armor-val">0</span>
        </div>
      </div>
    </div>
    <div class="profile-section">
      <div class="stat-row">
        <span>Weapon</span>
        <span class="stat-value" id="profile-weapon">Rocket</span>
      </div>
      <div class="stat-row">
        <span>K/D</span>
        <span class="stat-value" id="profile-kd">0/0</span>
      </div>
    </div>
    <div class="profile-section">
      <div class="section-label">Neural Activity</div>
      <div class="neural-grid">
        <div class="neural-indicator">
          <div class="indicator-bar" id="neural-turn"></div>
          <span>Turn</span>
        </div>
        <div class="neural-indicator">
          <div class="indicator-bar" id="neural-speed"></div>
          <span>Speed</span>
        </div>
        <div class="neural-indicator">
          <div class="indicator-bar" id="neural-strafe"></div>
          <span>Strafe</span>
        </div>
        <div class="neural-indicator">
          <div class="indicator-light" id="neural-shoot"></div>
          <span>Fire</span>
        </div>
        <div class="neural-indicator">
          <div class="indicator-light" id="neural-dash"></div>
          <span>Dash</span>
        </div>
      </div>
    </div>
    <div class="profile-section">
      <div class="section-label">Awareness</div>
      <div class="awareness-row">
        <span>Enemy</span>
        <span class="awareness-value" id="awareness-enemy">None</span>
      </div>
      <div class="awareness-row">
        <span>Ally</span>
        <span class="awareness-value" id="awareness-ally">None</span>
      </div>
    </div>
  </div>

  <h3>üìä Simulation</h3>
  <div class="stat-row">
    <span>Mode</span>
    <span class="stat-value" id="stats-mode">Rounds</span>
  </div>
  <div class="stat-row" id="stats-total-lives-row">
    <span>Total Lives</span>
    <span class="stat-value" id="stats-total-lives">0</span>
  </div>
  <div class="stat-row">
    <span>Sim Speed</span>
    <span class="stat-value" id="stats-ups">60</span>
  </div>

  <h3>‚öîÔ∏è Weapon Kills</h3>
  <div class="stat-row">
    <span>üöÄ Rocket</span>
    <span class="stat-value" id="stats-rocket-kills" style="color: #ff8800;">0 / 0</span>
  </div>
  <div class="stat-row">
    <span>‚ö° Laser</span>
    <span class="stat-value" id="stats-laser-kills" style="color: #00aaff;">0 / 0</span>
  </div>
  <div class="stat-row">
    <span>üó°Ô∏è Sword</span>
    <span class="stat-value" id="stats-sword-kills" style="color: #ff00ff;">0 / 0</span>
  </div>

  <h3>üèÜ Overall Kill Leaderboard</h3>
  <div id="stats-leaderboard" class="team-section">
    <div style="opacity: 0.5; font-size: 0.75rem;">No data yet</div>
  </div>


  <h3>üìú Combat Log</h3>
  <div id="stats-combat-log" style="max-height: 200px; overflow-y: auto; font-size: 0.75rem;"></div>
</div>

<!-- Floating Control Bar -->
<div id="control-bar">
  <div class="control-group">
    <button id="ctrl-save" title="Save checkpoint">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>
    </button>
    <button id="ctrl-load" title="Load checkpoint">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"/></svg>
    </button>
  </div>

  <div class="control-group main-controls">
    <button id="ctrl-reset" title="Reset simulation">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
    </button>
    <button id="ctrl-play" class="play-btn" title="Play/Pause">
      <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
      <svg class="pause-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </button>
  </div>

  <div class="control-group">
    <button id="ctrl-headless" title="Headless Mode" data-tooltip="Headless Mode">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H3V4h18v12z"/></svg>
    </button>
    <button id="ctrl-performance" title="Performance Mode" data-tooltip="Performance Mode">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 2.05v2.02c3.95.49 7 3.85 7 7.93 0 3.21-1.92 6-4.72 7.28L13 17v5h5l-1.22-1.22C19.91 19.07 22 15.76 22 12c0-5.18-3.95-9.45-9-9.95zM11 2.05C5.95 2.55 2 6.81 2 12c0 3.76 2.09 7.07 5.16 8.78L6 22h5v-5l-2.28 2.28C6.08 18 4.5 15.21 4.5 12c0-4.08 3.05-7.44 7-7.93V2.05z"/></svg>
    </button>
  </div>
</div>

  <script>
  (() => {
    'use strict';

    // --------------------
    // Utility
    // --------------------
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    // Format time in MM:SS format
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    // --------------------
    // Demo Checkpoint (pre-trained AI for visitors)
    // To update: Save a checkpoint, then run in console:
    // copy(localStorage.getItem('quake-checkpoint'))
    // and paste the result below (replacing null)
    // --------------------
    const DEMO_CHECKPOINT = null;

    // --------------------
    // Turbo Mode (ultra performance for training)
    // --------------------
    let turboMode = false;
    let forceWeapon = null; // 'sword', 'laser', or null - persists weapons after death
    let persistentMode = false; // Persistent per-life evolution mode
    let noRespawnMode = false; // Rounds mode only: no respawns, round ends when team eliminated
    let fiveXHpMode = false; // 5x HP mode: 500 HP, combo system enabled

    // --------------------
    // Hall of Fame (for persistent mode)
    // --------------------
    const HOF_MAX_SIZE = 100; // Max entries per team
    const hallOfFame = [[], []]; // [redTeamHoF, blueTeamHoF]
    let totalLivesEvaluated = 0;

    // Track rolling average score at death (last X lives where X = team population)
    const recentScores = [[], []]; // Rolling window of recent scores per team

    function getAverageScoreAtDeath(team) {
      if (recentScores[team].length === 0) return 0;
      const sum = recentScores[team].reduce((a, b) => a + b, 0);
      return sum / recentScores[team].length;
    }

    // Hall of Fame entry structure:
    // { score, brain (cloned weights), kills, deaths, damageDealt, survivalTime, timestamp }

    function addToHallOfFame(team, entry) {
      // Track rolling average (last 100 lives)
      const windowSize = 100;
      recentScores[team].push(entry.score);
      if (recentScores[team].length > windowSize) {
        recentScores[team].shift(); // Remove oldest
      }

      hallOfFame[team].push(entry);
      hallOfFame[team].sort((a, b) => b.score - a.score);
      if (hallOfFame[team].length > HOF_MAX_SIZE) {
        hallOfFame[team].length = HOF_MAX_SIZE;
      }
    }

    // Tournament selection - pick best of k random candidates
    function selectParentFromHoF(team, tournamentSize = 5) {
      const hof = hallOfFame[team];
      if (hof.length === 0) return null;
      if (hof.length === 1) return hof[0];

      let best = null;
      for (let i = 0; i < Math.min(tournamentSize, hof.length); i++) {
        const idx = Math.floor(Math.random() * hof.length);
        const candidate = hof[idx];
        if (!best || candidate.score > best.score) {
          best = candidate;
        }
      }
      return best;
    }

    // Get mutation rate based on parent's rank in HoF
    function getMutationRateForRank(team, parentEntry) {
      const hof = hallOfFame[team];
      const rank = hof.indexOf(parentEntry);
      if (rank === -1 || hof.length <= 1) return { rate: 0.15, strength: 0.3 };

      // Top 10% get low mutation, bottom gets higher
      const percentile = rank / hof.length;
      const rate = 0.05 + percentile * 0.2; // 0.05 to 0.25
      const strength = 0.1 + percentile * 0.4; // 0.1 to 0.5
      return { rate, strength };
    }

    function clearHallOfFame() {
      hallOfFame[0] = [];
      hallOfFame[1] = [];
      totalLivesEvaluated = 0;
      // Reset rolling average scores
      recentScores[0] = [];
      recentScores[1] = [];
    }

    // --------------------
    // Names
    // --------------------
    const FIRST_NAMES = ['Ole', 'Lars', 'Erik', 'Anders', 'Magnus', 'Henrik', 'Jonas', 'Marius', 'Kristian', 'Thomas', 'Astrid', 'Ingrid', 'Solveig', 'Freya', 'Sigrid', 'Nora', 'Emma', 'Maja', 'Thea', 'Ella', 'Bj√∏rn', 'Torstein', 'Gunnar', 'H√•kon', 'Leif', 'Ragnar', 'Sven', 'Olav', 'Knut', 'Arne', 'Liv', 'Grete', 'Kari', 'Anne', 'James', 'John', 'William', 'David', 'Richard', 'Mary', 'Patricia', 'Jennifer', 'Linda', 'Elizabeth', 'Michael', 'Christopher', 'Joshua', 'Andrew', 'Brandon', 'Emily', 'Hannah', 'Madison', 'Ashley', 'Olivia', 'Jack', 'Harry', 'Oliver', 'George', 'Charlie', 'Grace', 'Chloe', 'Lily', 'Mia', 'Ruby', 'Viktor', 'Felix', 'Oscar', 'Sebastian', 'Adrian', 'Aurora', 'Emilie', 'Hedda', 'Sara', 'Julie'];
    const LAST_NAMES = ['Hansen', 'Johansen', 'Olsen', 'Larsen', 'Andersen', 'Pedersen', 'Nilsen', 'Kristiansen', 'Jensen', 'Karlsen', 'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Miller', 'Davis', 'Garcia', 'Rodriguez', 'Wilson', 'Martinez', 'Anderson', 'Taylor', 'Thomas', 'Moore', 'Martin', 'Jackson', 'Thompson', 'White', 'Lopez'];

    // --------------------
    // Neural net
    // --------------------
    class NeuralNetwork {
      constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize, hiddenSize);
        this.biasH = new Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
        this.biasO = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
      }
      randomMatrix(rows, cols, fanIn) {
        const scale = Math.sqrt(2 / fanIn);
        const m = new Array(rows);
        for (let r = 0; r < rows; r++) {
          const row = new Array(cols);
          for (let c = 0; c < cols; c++) row[c] = (Math.random() - 0.5) * 2 * scale;
          m[r] = row;
        }
        return m;
      }
      activate(x) { return Math.tanh(x); }
      forward(inputs) {
        // Safe pad/truncate so we always use the full weight matrix.
        const x = (inputs.length === this.inputSize)
          ? inputs
          : inputs.length > this.inputSize
            ? inputs.slice(0, this.inputSize)
            : inputs.concat(new Array(this.inputSize - inputs.length).fill(0));

        const hidden = new Array(this.hiddenSize);
        for (let i = 0; i < this.hiddenSize; i++) {
          let sum = this.biasH[i];
          const w = this.weightsIH[i];
          for (let j = 0; j < this.inputSize; j++) sum += w[j] * x[j];
          hidden[i] = this.activate(sum);
        }

        const out = new Array(this.outputSize);
        for (let i = 0; i < this.outputSize; i++) {
          let sum = this.biasO[i];
          const w = this.weightsHO[i];
          for (let j = 0; j < this.hiddenSize; j++) sum += w[j] * hidden[j];
          out[i] = this.activate(sum);
        }
        return out;
      }
      clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(row => row.slice());
        nn.weightsHO = this.weightsHO.map(row => row.slice());
        nn.biasH = this.biasH.slice();
        nn.biasO = this.biasO.slice();
        return nn;
      }
      mutate(rate = 0.1, strength = 0.3) {
        const mutateVal = (v) => (Math.random() < rate ? v + (Math.random() - 0.5) * 2 * strength : v);
        const mutateArr = (arr) => { for (let i = 0; i < arr.length; i++) arr[i] = mutateVal(arr[i]); };
        const mutateMat = (mat) => { for (let r = 0; r < mat.length; r++) mutateArr(mat[r]); };
        mutateMat(this.weightsIH);
        mutateMat(this.weightsHO);
        mutateArr(this.biasH);
        mutateArr(this.biasO);
      }
    }

    // --------------------
    // Pickups
    // --------------------
    class BowPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class KnifePickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }
    class SniperPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class ShotgunPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class BazookaPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 22; this.pickedUp = false; this.spawnTime = Date.now(); } }
    class HealingPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; this.healAmount = 50; } }
    class ArmorPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }

    // --------------------
    // Projectiles
    // --------------------
    class Arrow {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 350; this.damage = 50; this.maxRange = 1200;
        this.distanceTraveled = 0; this.alive = true; this.radius = 5;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class Bullet {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 800; this.damage = 100; this.maxRange = 2000;
        this.distanceTraveled = 0; this.alive = true; this.radius = 3;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class ShotgunBlast {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.nearRange = 80; this.farRange = 150; this.spreadAngle = Math.PI / 4;
        this.maxTime = 0.2; this.timer = 0; this.active = true;
        this.hasDealtNearDamage = false; this.hasDealtFarDamage = false;
        this.currentRadius = 0; this.speed = 800;
      }
      update(dt, agents, world) {
        if (!this.active) return;
        this.timer += dt;
        this.currentRadius = this.timer * this.speed;
        if (!this.hasDealtNearDamage && this.currentRadius >= this.nearRange) {
          this.hasDealtNearDamage = true;
          this.dealDamageInRange(agents, world, 0, this.nearRange, 100);
        }
        if (!this.hasDealtFarDamage && this.currentRadius >= this.farRange) {
          this.hasDealtFarDamage = true;
          this.dealDamageInRange(agents, world, this.nearRange, this.farRange, 50);
        }
        if (this.timer >= this.maxTime) this.active = false;
      }
      dealDamageInRange(agents, world, minDist, maxDist, damage) {
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = agent.x - this.x, dy = agent.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist || dist > maxDist) continue;

          let angleToAgent = Math.atan2(dy, dx);
          let angleDiff = angleToAgent - this.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          if (Math.abs(angleDiff) > this.spreadAngle) continue;

          const killed = agent.takeDamage(damage, this.owner, world);
          this.owner.damageDealt += damage;
          this.owner.lifeDamageDealt += damage;
          world.addEvent(this.owner.name + ' blasted ' + agent.name, 'damage');
          if (killed) {
            this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
            this.owner.lifeKills++;
            world.teamKills[this.owner.team]++;
            this.owner.killScore += 50;
            world.addEvent(this.owner.name + ' killed ' + agent.name + '!', 'kill');
          }
        }
      }
    }

    class Rocket {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 280; // Slower than arrows (350)
        this.maxRange = 1500;
        this.distanceTraveled = 0;
        this.alive = true;
        this.radius = 8;
        this.explosionRadius = 120;
        this.damage = 200; // Instakill in center
        // Trail particles
        this.trail = [];
        this.trailTimer = 0;
      }
      update(dt, agents, obstacles, world) {
        if (!this.alive) return null;
        
        // Wobbly flight path for visual fun
        const wobble = Math.sin(this.distanceTraveled * 0.05) * 0.02;
        const moveAngle = this.angle + wobble;
        
        const moveX = Math.cos(moveAngle) * this.speed * dt;
        const moveY = Math.sin(moveAngle) * this.speed * dt;
        this.x += moveX;
        this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        
        // Add smoke trail particles
        this.trailTimer += dt;
        if (this.trailTimer > 0.02) {
          this.trailTimer = 0;
          this.trail.push({
            x: this.x - Math.cos(this.angle) * 15,
            y: this.y - Math.sin(this.angle) * 15,
            life: 1,
            size: 8 + Math.random() * 6,
            vx: (Math.random() - 0.5) * 30,
            vy: (Math.random() - 0.5) * 30
          });
        }
        
        // Update trail
        for (const p of this.trail) {
          p.life -= dt * 2;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.size *= 0.98;
        }
        this.trail = this.trail.filter(p => p.life > 0);
        
        // Max range - explode
        if (this.distanceTraveled >= this.maxRange) {
          this.alive = false;
          return { type: 'explode', x: this.x, y: this.y };
        }
        
        // Hit obstacle - explode
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        // Hit agent - explode
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        return null;
      }
    }

    class Explosion {
      constructor(x, y, owner, radius, damage) {
        this.x = x;
        this.y = y;
        this.owner = owner;
        this.radius = radius;
        this.damage = damage;
        this.maxTime = 0.6;
        this.timer = 0;
        this.hasDealtDamage = false;
        this.currentRadius = 0;
        // Shockwave rings
        this.rings = [];
        // Debris particles
        this.particles = [];
        for (let i = 0; i < 40; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 150 + Math.random() * 350;
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.4 + Math.random() * 0.4,
            size: 3 + Math.random() * 8,
            color: Math.random() > 0.5 ? '#ff6600' : (Math.random() > 0.5 ? '#ffcc00' : '#ff0000')
          });
        }
        // Initial flash
        this.flashIntensity = 1;
      }
      update(dt, agents, world) {
        this.timer += dt;
        this.currentRadius = Math.min(this.radius, (this.timer / 0.15) * this.radius);
        this.flashIntensity = Math.max(0, 1 - this.timer * 4);
        
        // Add expanding rings
        if (this.timer < 0.3 && Math.random() < 0.3) {
          this.rings.push({ radius: this.currentRadius * 0.3, alpha: 1 });
        }
        
        // Update rings
        for (const ring of this.rings) {
          ring.radius += 400 * dt;
          ring.alpha -= dt * 3;
        }
        this.rings = this.rings.filter(r => r.alpha > 0);
        
        // Update particles
        for (const p of this.particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += 200 * dt; // Gravity
          p.life -= dt;
          p.size *= 0.97;
        }
        this.particles = this.particles.filter(p => p.life > 0);
        
        // Deal damage once at peak
        if (!this.hasDealtDamage && this.timer >= 0.05) {
          this.hasDealtDamage = true;
          for (const agent of agents) {
            if (!agent.alive || (this.owner && agent.team === this.owner.team)) continue;
            const dx = agent.x - this.x, dy = agent.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > this.radius) continue;
            
            // Damage falloff: 100% at center, 50% at edge
            const falloff = 1 - (dist / this.radius) * 0.5;
            const finalDamage = Math.floor(this.damage * falloff);
            
            const killed = agent.takeDamage(finalDamage, this.owner, world);
            if (this.owner) {
              this.owner.damageDealt += finalDamage;
              this.owner.lifeDamageDealt += finalDamage;
              if (killed) {
                this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
                this.owner.lifeKills++;
                this.owner.weaponKills.rocket++;
                this.owner.totalWeaponKills.rocket++;
                world.weaponKills.rocket++;
                world.totalWeaponKills.rocket++;
                world.teamKills[this.owner.team]++;
                this.owner.killScore += 50;
                world.addEvent('üí• ' + this.owner.name + ' OBLITERATED ' + agent.name + '!', 'kill');
              } else {
                world.addEvent(this.owner.name + ' rocket hit ' + agent.name, 'damage');
              }
            }
          }
        }
        
        return this.timer >= this.maxTime;
      }
    }

    // --------------------
    // Control Point
    // --------------------
    class ControlPoint {
      constructor(x, y, size) {
        this.x = x; this.y = y; this.size = size;
        this.owner = null; this.capturer = null;
        this.captureProgress = 0; this.captureTime = 10;
        this.contested = false;
        this.color = 'hsl(' + (Math.random() * 360) + ', 100%, 50%)';
      }
      containsAgent(agent) {
        return agent.x >= this.x && agent.x <= this.x + this.size && agent.y >= this.y && agent.y <= this.y + this.size;
      }
      getAgentsInside(agents) { return agents.filter(a => a.alive && this.containsAgent(a)); }
      update(dt, agents, world) {
        const inside = this.getAgentsInside(agents);

        if (this.owner && !this.owner.alive) {
          world.addEvent(this.owner.name + ' lost point', 'damage');
          this.owner = null;
        }

        this.contested = inside.length > 1;
        if (this.contested) {
          this.capturer = null;
          this.captureProgress = 0;
          return;
        }

        if (inside.length === 1) {
          const agent = inside[0];

          if (this.owner === agent) {
            agent.controlPointSeconds += dt;
            return;
          }

          // Capturing
          if (this.capturer !== agent) {
            this.capturer = agent;
            this.captureProgress = 0;
          }
          this.captureProgress += dt;

          if (this.captureProgress >= this.captureTime) {
            if (this.owner && this.owner !== agent) world.addEvent(agent.name + ' took point from ' + this.owner.name + '!', 'kill');
            this.owner = agent;
            this.capturer = null;
            this.captureProgress = 0;
            agent.controlPointCaptures++;
            world.addEvent(agent.name + ' captured point!', 'kill');
          }
          return;
        }

        // Nobody inside
        this.capturer = null;
        this.captureProgress = 0;
        if (this.owner && this.owner.alive) this.owner.controlPointSeconds += dt;
      }
    }

    // --------------------
    // Spatial hash (cheap nearest-neighbor acceleration)
    // --------------------
    class SpatialHash {
      constructor(cellSize) {
        this.cellSize = cellSize;
        this.map = new Map();
      }
      key(cx, cy) { return (cx << 16) ^ (cy & 0xffff); }
      cell(v) { return Math.floor(v / this.cellSize); }
      clear() { this.map.clear(); }
      insert(obj, x, y) {
        const cx = this.cell(x), cy = this.cell(y);
        const k = this.key(cx, cy);
        let arr = this.map.get(k);
        if (!arr) { arr = []; this.map.set(k, arr); }
        arr.push(obj);
      }
      query(x, y, radius) {
        const r = radius;
        const cs = this.cellSize;
        const minX = this.cell(x - r), maxX = this.cell(x + r);
        const minY = this.cell(y - r), maxY = this.cell(y + r);
        const out = [];
        for (let cx = minX; cx <= maxX; cx++) {
          for (let cy = minY; cy <= maxY; cy++) {
            const arr = this.map.get(this.key(cx, cy));
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    }

    // --------------------
    // Agent
    // --------------------
    // QUAKE MODE - Everyone gets a rocket launcher!
    const ROCKET = {
      damage: 90,          // Direct hit = almost one-shot
      splashRadius: 120,   // Big splash
      splashFalloff: 0.4,  // 40% damage at edge
      speed: 450,          // Fast enough to hit, slow enough to dodge
      fireRate: 4.0,        // 4 seconds between shots - makes each rocket count!
      selfDamage: true,    // Watch your feet!
      maxRange: 2000
    };

    // SKS-style semi-auto rifle - fast bullets, damage dropoff
    const RIFLE = {
      damageClose: 120,    // Max damage at point blank
      damageFar: 60,       // Min damage at max range
      speed: 2000,         // Much faster than rockets
      fireRate: 1.0,       // 1 second between shots
      maxRange: 2500,      // Full map range
      bulletSize: 4        // Small bullet
    };

    let baseWeapon = 'rocket'; // 'rocket' or 'rifle' - base weapon for all agents

    class Agent {
      constructor(x, y, name, brain = null, team = 0) {
        this.x = x; this.y = y; this.name = name;
        this.team = team; // 0 = red, 1 = blue
        this.rotation = Math.random() * Math.PI * 2;
        this.vx = 0; this.vy = 0;

        this.maxHealth = fiveXHpMode ? 500 : 100;
        this.health = this.maxHealth;
        this.armor = 0; this.maxArmor = 100; // 2 armor packs = 100
        this.stamina = 100; this.maxStamina = 100;

        this.alive = true;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        
        // Respawn system
        this.respawnTimer = 0;
        this.deaths = 0;

        // Weapon system
        this.weaponCooldown = 0;
        this.weapon = 'rocket'; // 'rocket', 'laser', or 'sword'
        this.laserCharge = 0; // 0-3 seconds
        this.laserCharging = false;
        
        // Sword mechanics
        this.swordCharge = 0; // 0-2 seconds max
        this.swordCharging = false;
        this.swordLunging = false;
        this.lungeStartX = 0;
        this.lungeStartY = 0;
        this.lungeEndX = 0;
        this.lungeEndY = 0;
        this.lungeProgress = 0;

        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.assists = 0;
        this.lastHitBy = null; // For assist tracking
        
        // Lifetime stats (persist across rounds)
        this.totalKills = 0;
        this.totalDeaths = 0;
        this.roundsPlayed = 0;

        // Weapon kill stats (per round)
        this.weaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };
        // Weapon kill stats (lifetime)
        this.totalWeaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };

        // Network: 54 inputs ‚Üí 16 hidden ‚Üí 5 outputs
        // Inputs: 42 raycast (21 rays √ó 2) + 12 state (health, cooldown, velocity, weapon type, rocket awareness, etc)
        // Outputs: turn, move speed, shoot, strafe, dash
        this.brain = brain || new NeuralNetwork(54, 16, 5);

        // Track if agent has picked up a special weapon this round (can only pick up once)
        this.hasPickedUpWeapon = false;

        // Persistent mode tracking
        this.lifeStartTime = 0; // Set when agent spawns/respawns
        this.lifeKills = 0; // Kills this life only
        this.lifeDamageDealt = 0; // Damage this life only
        this.lifeDamageTaken = 0; // Damage taken this life only
        this.lifeMisses = 0; // Missed shots this life only
        this.misses = 0; // Total missed shots

        // Combo system (5x HP mode)
        this.comboTarget = null; // Current target being comboed
        this.comboCount = 0; // Consecutive hits on same target
        this.comboTimer = 0; // Time since last hit on combo target
        this.comboScore = 0; // Extra score from combos this life

        // Dodge ability
        this.dodgeCooldown = 0;
        this.isDodging = false;
        this.dodgeProgress = 0;
        this.dodgeStartX = 0;
        this.dodgeStartY = 0;
        this.dodgeEndX = 0;
        this.dodgeEndY = 0;

        // Edge camping detection
        this.edgeCampTime = 0; // Time spent near edges
        this.inDangerZone = false; // Currently taking damage from danger zone

        this.radius = 16;
        this.color = team === 0 ? '#ff4444' : '#4488ff';
      }
      
      // Reset for new round but keep identity
      resetForRound() {
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        // Check if forceWeapon is active (debug mode)
        if (forceWeapon) {
          this.weapon = forceWeapon;
          this.hasPickedUpWeapon = true;
        } else {
          this.weapon = 'rocket';
          this.hasPickedUpWeapon = false; // Can pick up one special weapon per round
        }
        this.dodgeCooldown = 0;
        this.isDodging = false;
        this.dodgeProgress = 0;
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;
        
        // Reset round stats but not lifetime stats
        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.deaths = 0;
        this.assists = 0;
        this.weaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };
        this.roundsPlayed++;

        this.maxHealth = fiveXHpMode ? 500 : 100;
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;

        // Reset edge camping tracking
        this.edgeCampTime = 0;
        this.inDangerZone = false;
      }

      // Respawn after death
      respawn(world) {
        this.maxHealth = fiveXHpMode ? 500 : 100;
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        // Check if forceWeapon is active (debug mode)
        if (forceWeapon) {
          this.weapon = forceWeapon;
          this.hasPickedUpWeapon = true;
        } else {
          this.weapon = 'rocket'; // Lose special weapons on death
          this.hasPickedUpWeapon = false;
        }
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;

        // Reset life stats for persistent mode
        this.lifeStartTime = world ? world.totalTime : 0;
        this.lifeKills = 0;
        this.lifeDamageDealt = 0;
        this.lifeDamageTaken = 0;
        this.lifeMisses = 0;

        // Reset combo
        this.comboTarget = null;
        this.comboCount = 0;
        this.comboTimer = 0;
        this.comboScore = 0;

        // Spawn at back of team's side
        const clusterX = this.team === 0 ? 80 : world.width - 80;
        this.x = clusterX + (Math.random() - 0.5) * 100;
        this.y = world.height / 2 + (Math.random() - 0.5) * (world.height - 200);
        this.x = clamp(this.x, 40, world.width - 40);
        this.y = clamp(this.y, 40, world.height - 40);
        this.rotation = this.team === 0 ? 0 : Math.PI;
      }

      get score() {
        const killPoints = this.kills * 50;
        const assistPoints = this.assists * 25;
        const damagePoints = this.damageDealt;
        return killPoints + assistPoints + damagePoints - this.damageTaken;
      }

      // Handle combo hit (5x HP mode) - returns combo multiplier for damage score
      registerComboHit(target, baseDamage) {
        if (!fiveXHpMode) return 1.0; // No combo in normal mode

        const COMBO_DURATION = 6.0; // 6 seconds to maintain combo

        if (this.comboTarget === target) {
          // Same target - continue combo
          this.comboCount++;
          this.comboTimer = COMBO_DURATION;
        } else {
          // New target - start new combo
          this.comboTarget = target;
          this.comboCount = 1;
          this.comboTimer = COMBO_DURATION;
        }

        // Calculate combo multiplier: 1.0x, 1.2x, 1.5x, 1.8x, 2.0x (cap)
        const multipliers = [1.0, 1.2, 1.5, 1.8, 2.0];
        const multiplier = multipliers[Math.min(this.comboCount - 1, multipliers.length - 1)];

        // Award bonus score based on combo
        const bonusScore = Math.floor(baseDamage * (multiplier - 1.0));
        this.comboScore += bonusScore;

        return multiplier;
      }

      // Get kill bonus based on combo (called when target dies)
      getComboKillBonus(target) {
        if (!fiveXHpMode) return 0;
        if (this.comboTarget !== target) return 0;

        // Bonus: 50 points per combo hit
        const bonus = this.comboCount * 50;

        // Reset combo after kill
        this.comboTarget = null;
        this.comboCount = 0;
        this.comboTimer = 0;

        return bonus;
      }

      castRays(world, numRays = 21, fov = Math.PI * 0.8) {
        const { agents, obstacles, pickups, width: worldWidth, height: worldHeight } = world;
        const rayData = [];

        const startAngle = this.rotation - fov / 2;
        const angleStep = fov / (numRays - 1);
        const maxDist = Math.hypot(worldWidth, worldHeight);

        // Check all alive agents for raycasts (full map visibility)
        const nearCandidates = agents.filter(a => a.alive && a !== this);

        for (let i = 0; i < numRays; i++) {
          const angle = startAngle + angleStep * i;
          let closestDist = maxDist;
          let closestType = 0;

          const edgeDist = this.raycastMapEdge(angle, worldWidth, worldHeight);
          if (edgeDist < closestDist) { closestDist = edgeDist; closestType = 0; }

          for (const obs of obstacles) {
            const dist = this.raycastRect(angle, closestDist, obs);
            if (dist < closestDist) { closestDist = dist; closestType = 0.5; }
          }

          // Check pickups (weapons, health, armor)
          for (const pickup of pickups) {
            const dist = this.raycastCircle(angle, closestDist, pickup.x, pickup.y, pickup.radius);
            if (dist < closestDist) { closestDist = dist; closestType = 0.25; }
          }

          // Check enemy rockets (type 0.75)
          for (const rocket of world.rockets) {
            if (rocket.owner && rocket.owner.team === this.team) continue; // Ignore own team's rockets
            const dist = this.raycastCircle(angle, closestDist, rocket.x, rocket.y, 8); // 8 = rocket radius
            if (dist < closestDist) { closestDist = dist; closestType = 0.75; }
          }

          for (const other of nearCandidates) {
            if (other === this || !other.alive) continue;
            const dist = this.raycastCircle(angle, closestDist, other.x, other.y, other.radius);
            if (dist < closestDist) { closestDist = dist; closestType = 1; }
          }

          rayData.push(closestDist / maxDist);
          rayData.push(closestType);
        }
        return rayData;
      }

      raycastMapEdge(angle, w, h) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = Infinity;
        if (dx < 0) { const t = -this.x / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dx > 0) { const t = (w - this.x) / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dy < 0) { const t = -this.y / dy; if (t > 0 && t < tMin) tMin = t; }
        if (dy > 0) { const t = (h - this.y) / dy; if (t > 0 && t < tMin) tMin = t; }
        return tMin;
      }

      raycastRect(angle, max, rect) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = 0, tMax = max;

        if (dx !== 0) {
          const t1 = (rect.x - this.x) / dx;
          const t2 = (rect.x + rect.w - this.x) / dx;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.x < rect.x || this.x > rect.x + rect.w) {
          return max;
        }

        if (dy !== 0) {
          const t1 = (rect.y - this.y) / dy;
          const t2 = (rect.y + rect.h - this.y) / dy;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.y < rect.y || this.y > rect.y + rect.h) {
          return max;
        }

        if (tMin <= tMax && tMin > 0) return tMin;
        return max;
      }

      raycastCircle(angle, max, cx, cy, r) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        const fx = this.x - cx, fy = this.y - cy;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - r * r;
        const d = b * b - 4 * a * c;
        if (d < 0) return max;
        const t = (-b - Math.sqrt(d)) / (2 * a);
        if (t > 0 && t < max) return t;
        return max;
      }

      think(world) {
        if (!this.alive) return null;

        const rayData = this.castRays(world);

        // Find nearest enemy
        let nearestEnemyDist = 1;
        let nearestEnemyAngle = 0;
        const enemies = world.agents.filter(a => a.alive && a.team !== this.team);
        for (const enemy of enemies) {
          const dx = enemy.x - this.x, dy = enemy.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 1000);
          if (nDist < nearestEnemyDist) {
            nearestEnemyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestEnemyAngle = a / Math.PI;
          }
        }

        // Find nearest ally (to avoid friendly fire)
        let nearestAllyDist = 1;
        let nearestAllyAngle = 0;
        const allies = world.agents.filter(a => a.alive && a.team === this.team && a !== this);
        for (const ally of allies) {
          const dx = ally.x - this.x, dy = ally.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 500);
          if (nDist < nearestAllyDist) {
            nearestAllyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestAllyAngle = a / Math.PI;
          }
        }

        // Find nearest enemy rocket (to dodge)
        let nearestRocketDist = 1;
        let nearestRocketAngle = 0;
        for (const rocket of world.rockets) {
          if (rocket.owner && rocket.owner.team === this.team) continue; // Ignore own team's rockets
          const dx = rocket.x - this.x, dy = rocket.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 500); // Normalize to 500 units
          if (nDist < nearestRocketDist) {
            nearestRocketDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestRocketAngle = a / Math.PI;
          }
        }

        const speedNorm = clamp(Math.hypot(this.vx, this.vy) / 200, 0, 1);
        const weaponReady = this.weaponCooldown <= 0 ? 1 : 0;
        const hasLaser = this.weapon === 'laser' ? 1 : 0;
        const hasSword = this.weapon === 'sword' ? 1 : 0;
        const dodgeReady = this.dodgeCooldown <= 0 ? 1 : 0;

        // Inputs: 54 total (42 rays + 12 internal)
        const internal = [
          this.health / this.maxHealth,
          speedNorm,
          weaponReady,
          nearestEnemyAngle,
          nearestEnemyDist,
          nearestAllyAngle,
          nearestAllyDist,
          nearestRocketAngle,
          nearestRocketDist,
          this.team,
          hasLaser,
          hasSword
        ];

        const outputs = this.brain.forward(rayData.concat(internal));

        const decision = {
          turnAmount: outputs[0],
          speedAmount: (outputs[1] + 1) / 2,
          wantsShoot: outputs[2] > 0,
          strafe: outputs[3],
          wantsDash: outputs[4] > 0
        };

        // Store for UI visualization
        this.lastDecision = decision;
        this.lastRayData = rayData;
        this.lastAwareness = {
          enemyDist: nearestEnemyDist,
          enemyAngle: nearestEnemyAngle,
          allyDist: nearestAllyDist,
          allyAngle: nearestAllyAngle,
          rocketDist: nearestRocketDist,
          rocketAngle: nearestRocketAngle
        };

        return decision;
      }

      update(decision, dt, world, obstacles) {
        if (!this.alive) return;

        this.attackCooldown = Math.max(0, this.attackCooldown - dt);
        this.attackRecovery = Math.max(0, this.attackRecovery - dt);
        this.weaponCooldown = Math.max(0, this.weaponCooldown - dt);
        this.dodgeCooldown = Math.max(0, this.dodgeCooldown - dt);

        // Update combo timer (5x HP mode)
        if (this.comboTimer > 0) {
          this.comboTimer -= dt;
          if (this.comboTimer <= 0) {
            // Combo expired
            this.comboTarget = null;
            this.comboCount = 0;
          }
        }

        // Handle sword lunge movement (with chain support)
        if (this.swordLunging) {
          if (this.chainTargets && this.chainTargets.length > 0) {
            // Chain lunge - follow path through multiple targets
            const chainSpeed = 600; // Slightly faster for chain kills

            // Calculate total chain distance
            let totalDist = 0;
            const segmentDists = [];
            for (const chain of this.chainTargets) {
              const d = Math.hypot(chain.toX - chain.fromX, chain.toY - chain.fromY);
              segmentDists.push(d);
              totalDist += d;
            }

            // Update progress based on total distance
            this.lungeProgress += (dt * chainSpeed) / Math.max(50, totalDist);

            if (this.lungeProgress >= 1) {
              this.swordLunging = false;
              const lastChain = this.chainTargets[this.chainTargets.length - 1];
              this.x = lastChain.toX;
              this.y = lastChain.toY;
              this.weaponCooldown = 1.0;
              this.chainTargets = null;
            } else {
              // Find which segment we're on
              let progressDist = this.lungeProgress * totalDist;
              let segmentIndex = 0;
              let segmentStart = 0;

              for (let i = 0; i < segmentDists.length; i++) {
                if (progressDist <= segmentStart + segmentDists[i]) {
                  segmentIndex = i;
                  break;
                }
                segmentStart += segmentDists[i];
              }

              const chain = this.chainTargets[segmentIndex];
              const segmentProgress = (progressDist - segmentStart) / segmentDists[segmentIndex];

              // Interpolate position within segment
              this.x = chain.fromX + (chain.toX - chain.fromX) * segmentProgress;
              this.y = chain.fromY + (chain.toY - chain.fromY) * segmentProgress;

              // Face the target
              this.rotation = Math.atan2(chain.toY - chain.fromY, chain.toX - chain.fromX);
            }
          } else {
            // Regular lunge (no chain)
            const lungeSpeed = 500 / Math.max(50, this.lungeDist);
            this.lungeProgress += dt * lungeSpeed;
            if (this.lungeProgress >= 1) {
              this.swordLunging = false;
              this.x = this.lungeEndX;
              this.y = this.lungeEndY;
              this.weaponCooldown = 1.0;
            } else {
              this.x = this.lungeStartX + (this.lungeEndX - this.lungeStartX) * this.lungeProgress;
              this.y = this.lungeStartY + (this.lungeEndY - this.lungeStartY) * this.lungeProgress;
            }
          }
          return; // Skip normal movement during lunge
        }

        // Handle dodge movement animation
        if (this.isDodging) {
          const dodgeSpeed = 8; // Complete dodge in ~0.125 seconds
          this.dodgeProgress += dt * dodgeSpeed;

          // Ease out for smooth deceleration
          const easedProgress = 1 - Math.pow(1 - Math.min(1, this.dodgeProgress), 2);

          if (this.dodgeProgress >= 1) {
            this.isDodging = false;
            this.x = this.dodgeEndX;
            this.y = this.dodgeEndY;
          } else {
            // Interpolate position with easing
            this.x = this.dodgeStartX + (this.dodgeEndX - this.dodgeStartX) * easedProgress;
            this.y = this.dodgeStartY + (this.dodgeEndY - this.dodgeStartY) * easedProgress;
          }
          return; // Skip normal movement during dodge
        }

        if (!decision) return;

        // Trigger dodge/dash (if enabled in world)
        if (decision.wantsDash && this.dodgeCooldown <= 0 && world.dodgingEnabled && !this.isDodging) {
          const dashDistance = 70; // Short dash distance

          // Dash in movement direction, or facing direction if not moving
          let dashAngle;
          const moveX = Math.cos(this.rotation) * decision.speedAmount + Math.cos(this.rotation + Math.PI/2) * (decision.strafe || 0);
          const moveY = Math.sin(this.rotation) * decision.speedAmount + Math.sin(this.rotation + Math.PI/2) * (decision.strafe || 0);
          const moveMag = Math.hypot(moveX, moveY);

          if (moveMag > 0.1) {
            dashAngle = Math.atan2(moveY, moveX);
          } else {
            dashAngle = this.rotation; // Dash forward if not moving
          }

          // Calculate new position
          let newX = this.x + Math.cos(dashAngle) * dashDistance;
          let newY = this.y + Math.sin(dashAngle) * dashDistance;

          // Clamp to world bounds
          newX = clamp(newX, this.radius, world.width - this.radius);
          newY = clamp(newY, this.radius, world.height - this.radius);

          // Check obstacle collision and adjust
          for (const obs of obstacles) {
            const col = this.checkRectCollision(newX, newY, obs);
            if (col) { newX = col.x; newY = col.y; }
          }

          // Set up dodge animation
          this.dodgeStartX = this.x;
          this.dodgeStartY = this.y;
          this.dodgeEndX = newX;
          this.dodgeEndY = newY;
          this.dodgeProgress = 0;
          this.isDodging = true;
          this.dodgeCooldown = 6.0; // 6 second cooldown

          // Add dodge trail effect
          world.dodgeTrails.push({
            startX: this.x,
            startY: this.y,
            endX: newX,
            endY: newY,
            team: this.team,
            timer: 0,
            maxTime: 0.3
          });
        }

        this.rotation += decision.turnAmount * 4 * dt; // Faster turning for dodging

        // Forward/backward movement
        let targetSpeed = decision.speedAmount * 150; // Faster base speed

        // 2x movement speed while holding sword (not charging)
        if (this.weapon === 'sword' && !this.swordCharging) {
          targetSpeed *= 2;
        }

        // 50% movement speed while charging laser
        if (this.laserCharging) {
          targetSpeed *= 0.5;
        }

        // 80% movement slow while charging sword (20% speed)
        if (this.swordCharging) {
          targetSpeed *= 0.2;
        }

        // Strafing (perpendicular movement)
        let strafeSpeed = (decision.strafe || 0) * 100;

        // 2x strafe speed while holding sword (not charging)
        if (this.weapon === 'sword' && !this.swordCharging) {
          strafeSpeed *= 2;
        }

        if (this.laserCharging) {
          strafeSpeed *= 0.5;
        }
        if (this.swordCharging) {
          strafeSpeed *= 0.2;
        }

        const tvx = Math.cos(this.rotation) * targetSpeed + Math.cos(this.rotation + Math.PI/2) * strafeSpeed;
        const tvy = Math.sin(this.rotation) * targetSpeed + Math.sin(this.rotation + Math.PI/2) * strafeSpeed;
        
        const lerp = Math.min(1, 8 * dt); // Snappier movement
        this.vx += (tvx - this.vx) * lerp;
        this.vy += (tvy - this.vy) * lerp;

        let nx = this.x + this.vx * dt;
        let ny = this.y + this.vy * dt;

        for (const obs of obstacles) {
          const col = this.checkRectCollision(nx, ny, obs);
          if (col) { nx = col.x; ny = col.y; }
        }

        this.x = clamp(nx, this.radius, world.width - this.radius);
        this.y = clamp(ny, this.radius, world.height - this.radius);
      }

      // Shoot rocket!
      tryShoot(world) {
        if (!this.alive || this.weaponCooldown > 0) return null;

        this.weaponCooldown = ROCKET.fireRate;

        // Rocket spawns from right shoulder position
        const shoulderOffset = this.radius * 0.7;
        const perpX = Math.cos(this.rotation - Math.PI / 2) * shoulderOffset; // right side
        const perpY = Math.sin(this.rotation - Math.PI / 2) * shoulderOffset;
        const forwardX = Math.cos(this.rotation) * (this.radius * 1.7);
        const forwardY = Math.sin(this.rotation) * (this.radius * 1.7);

        return {
          type: 'rocket',
          x: this.x + perpX + forwardX,
          y: this.y + perpY + forwardY,
          angle: this.rotation,
          owner: this,
          damage: ROCKET.damage,
          splashRadius: ROCKET.splashRadius,
          splashFalloff: ROCKET.splashFalloff,
          speed: ROCKET.speed,
          range: ROCKET.maxRange,
          traveled: 0,
          alive: true
        };
      }

      // Shoot rifle bullet!
      tryShootRifle(world) {
        if (!this.alive || this.weaponCooldown > 0) return null;

        this.weaponCooldown = RIFLE.fireRate;

        // Bullet spawns from rifle position (right side)
        const shoulderOffset = this.radius * 0.5;
        const perpX = Math.cos(this.rotation - Math.PI / 2) * shoulderOffset;
        const perpY = Math.sin(this.rotation - Math.PI / 2) * shoulderOffset;
        const forwardX = Math.cos(this.rotation) * (this.radius * 1.5);
        const forwardY = Math.sin(this.rotation) * (this.radius * 1.5);

        return {
          type: 'rifle',
          x: this.x + perpX + forwardX,
          y: this.y + perpY + forwardY,
          startX: this.x + perpX + forwardX, // Track start position for damage calc
          startY: this.y + perpY + forwardY,
          angle: this.rotation,
          owner: this,
          speed: RIFLE.speed,
          maxRange: RIFLE.maxRange,
          traveled: 0,
          alive: true
        };
      }

      checkRectCollision(newX, newY, rect) {
        const cx = Math.max(rect.x, Math.min(newX, rect.x + rect.w));
        const cy = Math.max(rect.y, Math.min(newY, rect.y + rect.h));
        const dx = newX - cx, dy = newY - cy;
        const dist = Math.hypot(dx, dy);
        if (dist < this.radius) {
          const ov = this.radius - dist;
          if (dist > 0) return { x: newX + (dx / dist) * ov, y: newY + (dy / dist) * ov };
          return { x: newX + this.radius, y: newY };
        }
        return null;
      }

      tryAttack(agents, world) {
        // No melee in Quake mode - rockets only!
        return null;
      }

      takeDamage(amount, attacker, world) {
        // Armor absorbs damage first
        if (this.armor > 0) {
          const armorDamage = Math.min(this.armor, amount);
          this.armor -= armorDamage;
          amount -= armorDamage;
        }
        
        this.health -= amount;
        this.damageTaken += amount;
        this.lifeDamageTaken += amount;

        // Track who hit us for assists
        if (attacker && attacker !== this.lastHitBy) {
          if (this.lastHitBy && this.health <= 0 && this.lastHitBy !== attacker) {
            this.lastHitBy.assists++;
          }
          this.lastHitBy = attacker;
        }

        if (this.health > 0) return false;

        // Death
        this.alive = false;
        this.deaths++;
        this.totalDeaths++;

        // Drop special weapon on death (unless forceWeapon debug mode is active)
        if (world && !forceWeapon && (this.weapon === 'laser' || this.weapon === 'sword')) {
          world.dropWeapon(this.x, this.y, this.weapon);
        }

        // Persistent mode: evaluate this life and evolve
        if (persistentMode && world) {
          const survivalTime = world.totalTime - this.lifeStartTime;
          const missPenalty = (this.lifeMisses || 0) * 20; // 20 points per missed shot
          const comboBonus = this.comboScore || 0; // Extra score from combos (5x HP mode)
          const lifeScore = this.lifeKills * 100 + this.lifeDamageDealt - (this.lifeDamageTaken * 0.3) - missPenalty + comboBonus;

          // Add to Hall of Fame
          const entry = {
            name: this.name,
            score: lifeScore,
            brain: this.brain.clone(),
            kills: this.lifeKills,
            damageDealt: this.lifeDamageDealt,
            survivalTime: survivalTime,
            timestamp: Date.now()
          };
          addToHallOfFame(this.team, entry);
          totalLivesEvaluated++;

          // Select parent and evolve
          const parent = selectParentFromHoF(this.team);
          if (parent) {
            const { rate, strength } = getMutationRateForRank(this.team, parent);
            this.brain = parent.brain.clone();
            this.brain.mutate(rate, strength);
          }

          // Immediate respawn in persistent mode
          this.respawnTimer = 0.1; // Tiny delay for visual feedback
        } else {
          this.respawnTimer = world ? world.respawnTime : 3; // Use world's respawn time
        }

        return true;
      }

      clone(newName, team) {
        const child = new Agent(this.x, this.y, newName, this.brain.clone(), team);
        return child;
      }
    }

    // --------------------
    // World
    // --------------------
    class World {
      constructor(width, height) {
        this.width = width;
        this.height = height;

        this.agents = [];
        this.obstacles = [];
        this.buildings = [];

        // Projectiles
        this.rockets = [];
        this.rifleBullets = []; // SKS rifle bullets
        this.explosions = [];
        this.smokeParticles = []; // Smoke trail particles

        // Pickups
        this.pickups = [];
        this.pickupTimer = 0;
        this.pickupInterval = 20; // Spawn every 20 seconds
        this.nextPickupType = 'health'; // Alternates between health and armor
        this.healthSpawnsEnabled = true;
        this.armorSpawnsEnabled = true;

        // Pit spawn locations (enclosed areas for health/armor)
        this.pickupPits = [];
        
        // Laser spawns
        this.laserSpawnsEnabled = true;
        this.laserSpawned = false; // Only spawn once per round
        this.laserBeams = []; // Active laser beam animations
        
        // Sword spawns
        this.swordSpawnsEnabled = true;
        this.swordSpawned = false;
        this.swordSlashes = []; // Active sword slash animations

        // Dropped weapons (laser/sword dropped on death or weapon swap)
        this.droppedWeapons = [];

        // Dodge trail animations
        this.dodgeTrails = [];

        this.roundTime = 180; // 3 minutes
        this.timeLeft = this.roundTime;
        this.totalTime = 0; // Total elapsed time (for persistent mode)

        this.usedNames = new Set();
        this.generation = 1;
        this.events = [];
        this.paused = false;

        this.population = 100; // 50 per team
        this.aliveCount = 0;
        
        // Team Deathmatch specific
        this.teamKills = [0, 0]; // [red kills, blue kills] - NET score (kills - ricochets)
        this.teamRawKills = [0, 0]; // Actual enemy kills
        this.teamRicochets = [0, 0]; // Friendly fire incidents
        this.killLimit = 20;
        this.winningTeam = null;
        this.teamWins = [0, 0]; // Track total wins per team

        // Global weapon kill stats (for balance tracking)
        this.weaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };
        this.totalWeaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };
        
        // Game modifiers
        this.friendlyFire = false;
        this.friendlyFireRicochet = false;
        this.dodgingEnabled = true; // Agents can dash/dodge
        this.respawnTime = 3; // seconds

        // Teleporters - pair of portals for quick map traversal
        this.teleportersEnabled = true;
        this.teleporters = []; // Will be populated in generateObstacles
        this.teleporterActive = false; // Currently usable?
        this.teleporterActiveTimer = 0; // Time remaining in active window
        this.teleporterActiveDuration = 30; // Active for 30 seconds
        this.teleporterNextActivation = 0; // When portals will activate
        this.teleporterWarpEffects = []; // Warp in/out animations

        // Team brains (evolved separately)
        this.teamBrains = [null, null];

        // Edge camping danger zones
        this.dangerZones = []; // {x, y, radius, lifetime, maxLifetime}
        this.edgeCampThreshold = 3; // Seconds before danger zone spawns
        this.edgeCampDistance = 80; // Distance from edge considered "camping"
        this.dangerZoneDamagePercent = 0.3; // 30% of max HP per second when in danger zone
        this.dangerZoneDuration = 5; // How long zones last

        this.spatialAgents = new SpatialHash(120);

        this.generateObstacles();
      }

      spawnLaserPickups() {
        if (this.laserSpawned || !this.laserSpawnsEnabled) return;

        // Spawn 10 lasers in a circle at map center (risk/reward)
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = 200; // Circle radius

        for (let i = 0; i < 10; i++) {
          // Offset angle so lasers alternate with swords
          const angle = (i / 10) * Math.PI * 2 + Math.PI / 20;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          this.pickups.push({
            x: x,
            y: y,
            type: 'laser',
            radius: 18
          });
        }

        this.laserSpawned = true;
        this.addEvent('‚ö° LASER WEAPONS SPAWNED AT CENTER!', 'laser');
      }

      spawnSwordPickups() {
        if (this.swordSpawned || !this.swordSpawnsEnabled) return;

        // Spawn 10 swords in a circle at map center (risk/reward)
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = 200; // Circle radius

        for (let i = 0; i < 10; i++) {
          // Offset angle so swords alternate with lasers
          const angle = (i / 10) * Math.PI * 2 - Math.PI / 20;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          this.pickups.push({
            x: x,
            y: y,
            type: 'sword',
            radius: 18
          });
        }

        this.swordSpawned = true;
        this.addEvent('üó°Ô∏è ENERGY SWORDS SPAWNED AT CENTER!', 'sword');
      }

      spawnPickupInPit(pit) {
        // Check if this type is enabled
        if (pit.type === 'health' && !this.healthSpawnsEnabled) return false;
        if (pit.type === 'armor' && !this.armorSpawnsEnabled) return false;

        // Spawn pickup at pit center
        this.pickups.push({
          x: pit.x,
          y: pit.y,
          type: pit.type,
          radius: 18,
          pitRef: pit
        });

        pit.hasPickup = true;
        pit.respawnTimer = 0;
        pit.respawnTime = 0;

        const icon = pit.type === 'health' ? 'ü©π' : 'üõ°Ô∏è';
        this.addEvent(icon + ' ' + pit.type.toUpperCase() + ' spawned in pit!', 'pickup');
        return true;
      }

      spawnPickups() {
        // Spawn pickups in all empty pits (used at round start)
        for (const pit of this.pickupPits) {
          if (!pit.hasPickup) {
            this.spawnPickupInPit(pit);
          }
        }
      }

      updatePitTimers(dt) {
        // Update per-pit respawn timers (Roshan-style random respawn)
        for (const pit of this.pickupPits) {
          if (pit.hasPickup) continue; // Pit has a pickup, no timer needed
          if (pit.respawnTime <= 0) continue; // No respawn scheduled

          pit.respawnTimer += dt;
          if (pit.respawnTimer >= pit.respawnTime) {
            this.spawnPickupInPit(pit);
          }
        }
      }

      // Set random respawn time when pickup is collected (15-25 seconds window)
      schedulePitRespawn(pit) {
        const baseTime = 20; // Base respawn time
        const variance = 5;  // +/- 5 seconds
        pit.respawnTime = baseTime + (Math.random() * 2 - 1) * variance; // 15-25 seconds
        pit.respawnTimer = 0;
      }

      fireLaser(agent) {
        if (!agent || !agent.alive) return;

        // Bouncing, piercing laser with 6 bounces
        var maxBounces = 6;
        var beamSegments = [];
        var hitTargets = {};  // Track hit target IDs
        var killCount = 0;

        var currentX = agent.x + Math.cos(agent.rotation) * agent.radius;
        var currentY = agent.y + Math.sin(agent.rotation) * agent.radius;
        currentX = Math.max(5, Math.min(this.width - 5, currentX));
        currentY = Math.max(5, Math.min(this.height - 5, currentY));

        var angle = agent.rotation;

        for (var bounce = 0; bounce <= maxBounces; bounce++) {
          var cosA = Math.cos(angle);
          var sinA = Math.sin(angle);

          // Find wall intersection
          var endX = currentX;
          var endY = currentY;

          for (var dist = 0; dist < 5000; dist += 10) {
            var testX = currentX + cosA * dist;
            var testY = currentY + sinA * dist;

            if (testX < 0 || testX > this.width || testY < 0 || testY > this.height) {
              endX = Math.max(0, Math.min(this.width, testX));
              endY = Math.max(0, Math.min(this.height, testY));
              break;
            }
            endX = testX;
            endY = testY;
          }

          // Check for enemy hits along this segment (piercing - hits all)
          var dx = endX - currentX;
          var dy = endY - currentY;
          var len = Math.sqrt(dx * dx + dy * dy);

          if (len > 1) {
            for (var i = 0; i < this.agents.length; i++) {
              var target = this.agents[i];
              if (!target || target === agent || !target.alive) continue;
              if (target.team === agent.team) continue;
              if (hitTargets[target.name]) continue;  // Already hit

              var px = target.x - currentX;
              var py = target.y - currentY;
              var dot = (px * dx + py * dy) / len;

              if (dot > 0 && dot < len) {
                var closestX = currentX + (dx / len) * dot;
                var closestY = currentY + (dy / len) * dot;
                var distToLine = Math.sqrt((target.x - closestX) * (target.x - closestX) + (target.y - closestY) * (target.y - closestY));

                if (distToLine < target.radius + 10) {
                  hitTargets[target.name] = true;
                  const laserDmg = 200;
                  // Register combo hit (5x HP mode)
                  agent.registerComboHit(target, laserDmg);
                  agent.damageDealt += laserDmg;
                  agent.lifeDamageDealt += laserDmg;
                  var killed = target.takeDamage(laserDmg, agent, this);
                  if (killed) {
                    // Get combo kill bonus before it resets
                    const comboKillBonus = agent.getComboKillBonus(target);
                    agent.comboScore += comboKillBonus;
                    agent.kills++;
                    agent.totalKills++;
                    agent.lifeKills++;
                    agent.weaponKills.laser++;
                    agent.totalWeaponKills.laser++;
                    this.weaponKills.laser++;
                    this.totalWeaponKills.laser++;
                    this.teamKills[agent.team]++;
                    this.teamRawKills[agent.team]++;
                    killCount++;
                  }
                }
              }
            }
          }

          // Store segment
          beamSegments.push({ startX: currentX, startY: currentY, endX: endX, endY: endY });

          // Calculate bounce direction
          var hitRight = Math.abs(endX - this.width) < 2;
          var hitLeft = endX < 2;
          var hitBottom = Math.abs(endY - this.height) < 2;
          var hitTop = endY < 2;

          if (hitRight || hitLeft) {
            angle = Math.PI - angle;
          }
          if (hitBottom || hitTop) {
            angle = -angle;
          }

          // Move to bounce point
          currentX = Math.max(2, Math.min(this.width - 2, endX));
          currentY = Math.max(2, Math.min(this.height - 2, endY));
        }

        // Miss penalty if no targets hit
        const hitCount = Object.keys(hitTargets).length;
        if (hitCount === 0) {
          agent.misses = (agent.misses || 0) + 1;
          agent.lifeMisses = (agent.lifeMisses || 0) + 1;
        }

        // Event messages
        if (killCount >= 3) {
          this.addEvent('‚ö° ' + agent.name + ' LASER DEVASTATION x' + killCount + '!', 'laser');
        } else if (killCount >= 2) {
          this.addEvent('‚ö° ' + agent.name + ' LASER PIERCE x' + killCount + '!', 'laser');
        } else if (killCount === 1) {
          this.addEvent('‚ö° ' + agent.name + ' LASER KILL!', 'laser');
        }

        // Add beam with all segments
        this.laserBeams.push({
          segments: beamSegments,
          team: agent.team,
          timer: 0,
          maxTime: 1.5
        });
      }

      createLaserExplosion(x, y, radius, damage, owner) {
        // Deal splash damage to nearby enemies
        for (const target of this.agents) {
          if (target === owner || !target.alive) continue;
          if (target.team === owner.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;

          const dist = Math.hypot(target.x - x, target.y - y);
          if (dist < radius) {
            const dmgFalloff = 1 - (dist / radius);
            const actualDmg = Math.round(damage * dmgFalloff);

            if (target.team === owner.team) {
              if (this.friendlyFireRicochet) {
                owner.takeDamage(actualDmg, owner, this);
              } else if (this.friendlyFire) {
                target.takeDamage(actualDmg, owner, this);
              }
            } else {
              const killed = target.takeDamage(actualDmg, owner, this);
              owner.lifeDamageDealt += actualDmg;
              if (killed) {
                owner.kills++;
                owner.totalKills++;
                owner.lifeKills++;
                owner.weaponKills.laser++;
                owner.totalWeaponKills.laser++;
                this.weaponKills.laser++;
                this.totalWeaponKills.laser++;
                this.teamKills[owner.team]++;
                this.teamRawKills[owner.team]++;
                this.addEvent('üí• ' + owner.name + ' LASER EXPLOSION KILL!', 'laser');
              }
            }
          }
        }

        // Add explosion visual effect
        this.effects.push({
          type: 'laser_explosion',
          x, y, radius,
          timer: 0,
          maxTime: 0.4,
          team: owner.team
        });
      }

      executeSwordLunge(agent, chargeTime) {
        // Calculate initial lunge distance based on charge time (0.5s min charge, 2s max)
        const minDist = 50;
        const maxDist = 500;
        const chargeRatio = Math.min(1, Math.max(0, (chargeTime - 0.3) / 1.7));
        const lungeDist = minDist + chargeRatio * (maxDist - minDist);
        const chainRange = 200; // Range for chaining to next enemy

        const startX = agent.x;
        const startY = agent.y;

        // Build chain of targets
        const chainTargets = [];
        let currentX = startX;
        let currentY = startY;
        let currentAngle = agent.rotation;
        let currentRange = lungeDist;
        const hitTargets = new Set(); // Track already hit targets

        // Find chain of enemies to hit
        let searching = true;
        while (searching) {
          // Find first enemy along current lunge path
          let firstHit = null;
          let firstHitDist = currentRange;

          const endX = currentX + Math.cos(currentAngle) * currentRange;
          const endY = currentY + Math.sin(currentAngle) * currentRange;

          for (const target of this.agents) {
            if (target === agent || !target.alive || hitTargets.has(target)) continue;
            if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;

            // Point-to-line distance check
            const dx = endX - currentX;
            const dy = endY - currentY;
            const len = Math.hypot(dx, dy);
            if (len === 0) continue;

            const nx = -dy / len;
            const ny = dx / len;
            const px = target.x - currentX;
            const py = target.y - currentY;
            const perpDist = Math.abs(px * nx + py * ny);
            const alongDist = px * (dx / len) + py * (dy / len);

            // Check if target is along the path and closer than current first hit
            if (perpDist < target.radius + 20 && alongDist > 0 && alongDist < firstHitDist) {
              firstHit = target;
              firstHitDist = alongDist;
            }
          }

          if (firstHit) {
            // Found an enemy - add to chain
            hitTargets.add(firstHit);
            chainTargets.push({
              target: firstHit,
              fromX: currentX,
              fromY: currentY,
              toX: firstHit.x,
              toY: firstHit.y
            });

            // Look for next chain target from this position
            currentX = firstHit.x;
            currentY = firstHit.y;
            currentRange = chainRange;

            // Find closest enemy within chain range (any direction)
            let nextTarget = null;
            let nextDist = chainRange;

            for (const target of this.agents) {
              if (target === agent || !target.alive || hitTargets.has(target)) continue;
              if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;

              const dist = Math.hypot(target.x - currentX, target.y - currentY);
              if (dist < nextDist) {
                nextTarget = target;
                nextDist = dist;
              }
            }

            if (nextTarget) {
              // Update angle to face next target
              currentAngle = Math.atan2(nextTarget.y - currentY, nextTarget.x - currentX);
            } else {
              searching = false; // No more targets in range
            }
          } else {
            searching = false; // No enemy hit on this path
          }
        }

        // Determine final destination
        let finalX, finalY;
        if (chainTargets.length > 0) {
          // End at last chain target
          const lastChain = chainTargets[chainTargets.length - 1];
          finalX = lastChain.toX;
          finalY = lastChain.toY;
        } else {
          // No hits - lunge to original destination
          finalX = startX + Math.cos(agent.rotation) * lungeDist;
          finalY = startY + Math.sin(agent.rotation) * lungeDist;
        }

        // Clamp to world bounds
        finalX = clamp(finalX, agent.radius, this.width - agent.radius);
        finalY = clamp(finalY, agent.radius, this.height - agent.radius);

        // Set up lunge (for now, teleport through chain - we'll animate later)
        agent.lungeStartX = startX;
        agent.lungeStartY = startY;
        agent.lungeEndX = finalX;
        agent.lungeEndY = finalY;
        agent.lungeProgress = 0;
        agent.lungeDist = Math.hypot(finalX - startX, finalY - startY);
        agent.swordLunging = true;
        agent.chainTargets = chainTargets; // Store for animation
        agent.chainIndex = 0;

        // Deal damage to all chain targets (300 base + 50 per hop)
        let killCount = 0;
        for (let i = 0; i < chainTargets.length; i++) {
          const chain = chainTargets[i];
          const target = chain.target;
          if (!target.alive) continue;

          const swordDamage = 300 + (i * 50); // 300, 350, 400, 450...

          if (target.team === agent.team) {
            if (this.friendlyFireRicochet) {
              const killed = agent.takeDamage(swordDamage, agent, this);
              this.teamRicochets[agent.team]++;
              if (killed) {
                this.addEvent('üîÑ ' + agent.name + ' SWORD RICOCHET!', 'sword');
              }
            } else if (this.friendlyFire) {
              const killed = target.takeDamage(swordDamage, agent, this);
              if (killed) {
                this.teamRicochets[agent.team]++;
                this.addEvent('üó°Ô∏è ' + agent.name + ' TEAMKILLED ' + target.name + '!', 'sword');
              }
            }
          } else {
            // Register combo hit (5x HP mode) - sword can hit same target multiple times in 5x HP mode
            agent.registerComboHit(target, swordDamage);
            agent.damageDealt += swordDamage;
            agent.lifeDamageDealt += swordDamage;
            const killed = target.takeDamage(swordDamage, agent, this);
            if (killed) {
              // Get combo kill bonus before it resets
              const comboKillBonus = agent.getComboKillBonus(target);
              agent.comboScore += comboKillBonus;
              agent.kills++;
              agent.totalKills++;
              agent.lifeKills++;
              agent.weaponKills.sword++;
              agent.totalWeaponKills.sword++;
              this.weaponKills.sword++;
              this.totalWeaponKills.sword++;
              this.teamKills[agent.team]++;
              this.teamRawKills[agent.team]++;
              killCount++;
            }
          }
        }

        // Event messages
        if (killCount > 0) {
          let msg;
          if (killCount >= 4) {
            msg = '‚öîÔ∏è ' + agent.name + ' SWORD RAMPAGE x' + killCount + '!';
          } else if (killCount >= 2) {
            msg = '‚öîÔ∏è ' + agent.name + ' CHAIN KILL x' + killCount + '!';
          } else {
            msg = 'üó°Ô∏è ' + agent.name + ' SWORD KILL!';
          }
          this.addEvent(msg, 'sword');
        }

        // Add slash animations for each chain segment
        const bladeLength = agent.radius * 1.7;
        const swordOffset = agent.radius * 1.35;

        if (chainTargets.length > 0) {
          // Create slash for each chain hop
          for (const chain of chainTargets) {
            const segAngle = Math.atan2(chain.toY - chain.fromY, chain.toX - chain.fromX);
            const perpX = Math.cos(segAngle + Math.PI / 2);
            const perpY = Math.sin(segAngle + Math.PI / 2);
            const segDist = Math.hypot(chain.toX - chain.fromX, chain.toY - chain.fromY);
            const segDuration = segDist / 500;

            this.swordSlashes.push({
              startX: chain.fromX + perpX * swordOffset,
              startY: chain.fromY + perpY * swordOffset,
              endX: chain.toX + perpX * swordOffset,
              endY: chain.toY + perpY * swordOffset,
              bladeLength: bladeLength,
              team: agent.team,
              timer: 0,
              maxTime: segDuration + 0.15,
              lungeDuration: segDuration,
              isChain: true
            });
          }
        } else {
          // No chain - regular slash
          const perpX = Math.cos(agent.rotation + Math.PI / 2);
          const perpY = Math.sin(agent.rotation + Math.PI / 2);
          const actualDist = Math.hypot(finalX - startX, finalY - startY);
          const lungeDuration = actualDist / 500;

          this.swordSlashes.push({
            startX: startX + perpX * swordOffset,
            startY: startY + perpY * swordOffset,
            endX: finalX + perpX * swordOffset,
            endY: finalY + perpY * swordOffset,
            bladeLength: bladeLength,
            team: agent.team,
            timer: 0,
            maxTime: lungeDuration + 0.2,
            lungeDuration: lungeDuration
          });
        }
      }

      setRoundTimeSeconds(sec) {
        this.roundTime = Math.max(10, sec);
        this.timeLeft = Math.min(this.timeLeft, this.roundTime);
      }

      generateObstacles() {
        this.obstacles = [];
        this.buildings = [];

        const bTypes = [
          { w: 100, h: 100 },
          { w: 150, h: 100 },
          { w: 80, h: 80 },
          { w: 120, h: 60 },
          { w: 60, h: 120 },
        ];

        // =====================
        // RESERVE PIT AREAS FIRST - prevent other obstacles from spawning here
        // =====================
        const pitSize = 100;
        const pitMargin = 60; // Extra space around pits
        const pitOffsetX = this.width * 0.2;
        const pitOffsetY = 300;

        // Store pit center locations for later
        this.pitLocations = [
          { x: pitOffsetX, y: pitOffsetY },
          { x: pitOffsetX, y: this.height - pitOffsetY },
          { x: this.width - pitOffsetX, y: pitOffsetY },
          { x: this.width - pitOffsetX, y: this.height - pitOffsetY }
        ];

        // Add temporary reservations (will be replaced by actual pit walls)
        const pitReservations = [];
        for (const loc of this.pitLocations) {
          const reservation = {
            x: loc.x - pitSize/2 - pitMargin,
            y: loc.y - pitSize/2 - pitMargin,
            w: pitSize + pitMargin * 2,
            h: pitSize + pitMargin * 2,
            isReservation: true
          };
          pitReservations.push(reservation);
          this.obstacles.push(reservation);
        }

        const overlaps = (x, y, w, h, margin = 30) => {
          for (const o of this.obstacles) {
            if (x < o.x + o.w + margin && x + w > o.x - margin &&
                y < o.y + o.h + margin && y + h > o.y - margin) return true;
          }
          return false;
        };

        const addBuilding = (x, y, w, h) => {
          if (!overlaps(x, y, w, h)) {
            this.buildings.push({ x, y, w, h });
            this.obstacles.push({ x, y, w, h });
            return true;
          }
          return false;
        };

        // =====================
        // SPAWN AREA COVER - Heavy protection near spawns
        // =====================
        
        // Red spawn cover (left side, x: 100-500)
        for (let i = 0; i < 8; i++) {
          const x = 120 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue spawn cover (right side, x: width-500 to width-100)
        for (let i = 0; i < 8; i++) {
          const x = this.width - 470 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // MID TRANSITION - Some cover between spawn and open middle
        // =====================
        
        // Red side transition (x: 500-800)
        for (let i = 0; i < 4; i++) {
          const x = 500 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue side transition (x: width-800 to width-500)
        for (let i = 0; i < 4; i++) {
          const x = this.width - 750 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // OPEN MIDDLE - Very sparse, just a few small covers
        // =====================
        
        // Only 2-3 small obstacles in the center zone (x: 900-1500)
        for (let i = 0; i < 3; i++) {
          const x = 950 + Math.random() * 500;
          const y = 300 + Math.random() * (this.height - 600);
          addBuilding(x, y, 60, 60); // Small cover only
        }

        // =====================
        // EDGE LANES - Cover along top and bottom for flanking
        // =====================
        
        // Top lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, 80 + Math.random() * 60, 80, 80);
        }
        
        // Bottom lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, this.height - 160 + Math.random() * 60, 80, 80);
        }

        // =====================
        // PICKUP PITS - Enclosed areas for health/armor (like Roshan pit)
        // =====================
        // Remove temporary reservations (keep only non-reservation obstacles)
        this.obstacles = this.obstacles.filter(o => !o.isReservation);

        this.pickupPits = [];
        const wallThick = 20;

        // Helper to create a pit with 3 walls (U-shape), opening facing outward (toward walls)
        const createPit = (cx, cy, openingDir, type) => {
          // openingDir: 'up', 'down' (which way the entrance faces - toward the wall)
          const walls = [];

          if (openingDir === 'down') {
            // Opening faces down (toward bottom wall)
            // Back wall (top)
            walls.push({ x: cx - pitSize/2, y: cy - pitSize/2 - wallThick, w: pitSize, h: wallThick });
            // Left wall
            walls.push({ x: cx - pitSize/2 - wallThick, y: cy - pitSize/2 - wallThick, w: wallThick, h: pitSize + wallThick });
            // Right wall
            walls.push({ x: cx + pitSize/2, y: cy - pitSize/2 - wallThick, w: wallThick, h: pitSize + wallThick });
          } else if (openingDir === 'up') {
            // Opening faces up (toward top wall)
            // Back wall (bottom)
            walls.push({ x: cx - pitSize/2, y: cy + pitSize/2, w: pitSize, h: wallThick });
            // Left wall
            walls.push({ x: cx - pitSize/2 - wallThick, y: cy - pitSize/2, w: wallThick, h: pitSize + wallThick });
            // Right wall
            walls.push({ x: cx + pitSize/2, y: cy - pitSize/2, w: wallThick, h: pitSize + wallThick });
          }

          // Add walls to obstacles
          for (const w of walls) {
            this.obstacles.push(w);
            this.buildings.push(w);
          }

          // Store pit info for spawning with random respawn timer
          this.pickupPits.push({
            x: cx, y: cy,
            type: type, // 'health' or 'armor'
            hasPickup: false,
            respawnTimer: 0,
            respawnTime: 0 // Will be set when pickup is taken
          });
        };

        // 4 pits - using stored locations from reservation phase
        // Top-left area: health pit (opening faces UP toward wall)
        createPit(pitOffsetX, pitOffsetY, 'up', 'health');

        // Bottom-left area: armor pit (opening faces DOWN toward wall)
        createPit(pitOffsetX, this.height - pitOffsetY, 'down', 'armor');

        // Top-right area: armor pit (opening faces UP toward wall)
        createPit(this.width - pitOffsetX, pitOffsetY, 'up', 'armor');

        // Bottom-right area: health pit (opening faces DOWN toward wall)
        createPit(this.width - pitOffsetX, this.height - pitOffsetY, 'down', 'health');

        // =====================
        // TELEPORTERS - Pair of portals for quick map traversal
        // =====================
        this.teleporters = [];
        const teleporterRadius = 35;
        const teleporterMargin = 150; // Distance from corners

        // Bottom-left teleporter (near red side)
        const tele1 = {
          x: teleporterMargin + 100,
          y: this.height - teleporterMargin,
          radius: teleporterRadius,
          linkedTo: null, // Will be set after both are created
          lastUsedBy: null, // Prevent instant re-teleport
          useCooldown: 0
        };

        // Top-right teleporter (near blue side)
        const tele2 = {
          x: this.width - teleporterMargin - 100,
          y: teleporterMargin,
          radius: teleporterRadius,
          linkedTo: null,
          lastUsedBy: null,
          useCooldown: 0
        };

        // Link them together
        tele1.linkedTo = tele2;
        tele2.linkedTo = tele1;

        this.teleporters.push(tele1, tele2);

        // Schedule first activation at random time (leaving 30s buffer at end)
        this.scheduleTeleporterActivation();
      }

      scheduleTeleporterActivation() {
        // Activate at random time, but ensure 30s active window fits before round ends
        // Random activation between 10s and (roundTime - 30s)
        const minTime = 10;
        const maxTime = Math.max(minTime, this.roundTime - this.teleporterActiveDuration);
        const activationTime = minTime + Math.random() * (maxTime - minTime);
        this.teleporterNextActivation = this.roundTime - activationTime; // timeLeft when it activates
        this.teleporterActive = false;
        this.teleporterActiveTimer = 0;
      }

      updateTeleporters(dt) {
        if (!this.teleportersEnabled || this.teleporters.length < 2) return;

        // Update warp effects
        for (const effect of this.teleporterWarpEffects) {
          effect.timer += dt;
        }
        this.teleporterWarpEffects = this.teleporterWarpEffects.filter(e => e.timer < e.maxTime);

        // Update teleporter cooldowns
        for (const tele of this.teleporters) {
          if (tele.useCooldown > 0) {
            tele.useCooldown -= dt;
            if (tele.useCooldown <= 0) {
              tele.lastUsedBy = null;
            }
          }
        }

        // Check for activation
        if (!this.teleporterActive) {
          // Waiting to activate
          if (this.timeLeft <= this.teleporterNextActivation && this.timeLeft > 0) {
            this.teleporterActive = true;
            this.teleporterActiveTimer = this.teleporterActiveDuration;
            this.addEvent('üåÄ TELEPORTERS ACTIVATED!', 'teleporter');

            // Add activation warp effects at both portals
            for (const tele of this.teleporters) {
              this.teleporterWarpEffects.push({
                x: tele.x, y: tele.y,
                type: 'activate',
                timer: 0,
                maxTime: 0.5
              });
            }
          }
        } else {
          // Currently active, count down
          this.teleporterActiveTimer -= dt;
          if (this.teleporterActiveTimer <= 0) {
            this.teleporterActive = false;
            this.teleporterNextActivation = -1; // Prevent reactivation this round
            this.addEvent('üåÄ Teleporters deactivated', 'teleporter');

            // Add deactivation effects
            for (const tele of this.teleporters) {
              this.teleporterWarpEffects.push({
                x: tele.x, y: tele.y,
                type: 'deactivate',
                timer: 0,
                maxTime: 0.3
              });
            }
          }
        }

        // Check for agent teleportation (only when active)
        if (this.teleporterActive) {
          for (const agent of this.agents) {
            if (!agent.alive) continue;

            for (const tele of this.teleporters) {
              // Skip if this agent just used this teleporter
              if (tele.lastUsedBy === agent || tele.useCooldown > 0) continue;

              const dist = Math.hypot(agent.x - tele.x, agent.y - tele.y);
              if (dist < tele.radius + agent.radius) {
                // Teleport!
                const dest = tele.linkedTo;

                // Warp out effect at entry
                this.teleporterWarpEffects.push({
                  x: agent.x, y: agent.y,
                  type: 'warp_out',
                  team: agent.team,
                  timer: 0,
                  maxTime: 0.25
                });

                // Move agent to destination (offset slightly so they don't instantly re-enter)
                const exitAngle = Math.atan2(this.height/2 - dest.y, this.width/2 - dest.x);
                agent.x = dest.x + Math.cos(exitAngle) * (dest.radius + agent.radius + 10);
                agent.y = dest.y + Math.sin(exitAngle) * (dest.radius + agent.radius + 10);

                // Warp in effect at exit
                this.teleporterWarpEffects.push({
                  x: agent.x, y: agent.y,
                  type: 'warp_in',
                  team: agent.team,
                  timer: 0,
                  maxTime: 0.25
                });

                // Set cooldown on destination to prevent instant return
                dest.lastUsedBy = agent;
                dest.useCooldown = 1.0; // 1 second cooldown

                this.addEvent('üåÄ ' + agent.name + ' teleported!', 'teleporter');
                break; // Only teleport once per frame
              }
            }
          }
        }
      }

      generateUniqueName() {
        let n;
        let att = 0;
        do {
          n = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)] + ' ' + LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
          if (this.usedNames.has(n)) {
            let s = 2;
            while (this.usedNames.has(n + ' (' + s + ')')) s++;
            n = n + ' (' + s + ')';
          }
          att++;
        } while (this.usedNames.has(n) && att < 100);
        this.usedNames.add(n);
        return n;
      }

      spawnAgents(count) {
        this.population = count;
        this.agents = [];
        this.usedNames.clear();

        this.rockets = [];
        this.rifleBullets = [];
        this.explosions = [];
        this.smokeParticles = [];

        // Reset pickups and weapon state
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        this.droppedWeapons = [];
        this.dodgeTrails = [];
        this.dangerZones = [];

        // Reset pit spawn flags and timers, then spawn initial pickups
        for (const pit of this.pickupPits) {
          pit.hasPickup = false;
          pit.respawnTimer = 0;
          pit.respawnTime = 0;
        }
        this.spawnPickups(); // Spawn initial pickups in all pits

        // Reset teleporters for new round
        this.teleporterActive = false;
        this.teleporterActiveTimer = 0;
        this.teleporterWarpEffects = [];
        for (const tele of this.teleporters) {
          tele.lastUsedBy = null;
          tele.useCooldown = 0;
        }
        this.scheduleTeleporterActivation();

        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.weaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };
        this.winningTeam = null;

        const perTeam = Math.floor(count / 2);

        // Create persistent soldiers for each team
        for (let team = 0; team < 2; team++) {
          const clusterX = team === 0 ? 80 : this.width - 80;
          const clusterY = this.height / 2;

          for (let i = 0; i < perTeam; i++) {
            let x = clusterX + (Math.random() - 0.5) * 150;
            let y = clusterY + (Math.random() - 0.5) * (this.height - 200);
            x = clamp(x, 40, this.width - 40);
            y = clamp(y, 40, this.height - 40);

            const brain = this.teamBrains[team]?.clone() || null;
            const agent = new Agent(x, y, this.generateUniqueName(), brain, team);
            agent.rotation = team === 0 ? 0 : Math.PI;

            if (this.teamBrains[team] && i > 0) {
              agent.brain.mutate(0.1, 0.3);
            }

            this.agents.push(agent);
          }
        }

        this.timeLeft = this.roundTime;

        // Apply forceWeapon if debug mode is active
        if (forceWeapon) {
          for (const agent of this.agents) {
            agent.weapon = forceWeapon;
            agent.hasPickedUpWeapon = true;
          }
        }

        // Spawn weapons at round start
        this.spawnLaserPickups();
        this.spawnSwordPickups();
      }

      spawnNextRound() {
        // Sort each team by score
        const redAgents = this.agents.filter(a => a.team === 0);
        const blueAgents = this.agents.filter(a => a.team === 1);
        
        redAgents.sort((a, b) => b.score - a.score);
        blueAgents.sort((a, b) => b.score - a.score);
        
        // Brain transfer: EVERYONE below top 10% gets a clone of a top performer
        const transferBrains = (agents) => {
          if (agents.length === 0) return;
          
          const top10pct = Math.max(1, Math.floor(agents.length * 0.1)); // Top 5 agents
          const top10Brains = agents.slice(0, top10pct).map(a => a.brain.clone());
          
          // Top 10% - keep their brains, tiny mutation to explore
          for (let i = 0; i < top10pct; i++) {
            agents[i].brain.mutate(0.02, 0.1);
          }
          
          // Everyone else gets a random top performer's brain with mutation
          for (let i = top10pct; i < agents.length; i++) {
            const parentBrain = top10Brains[Math.floor(Math.random() * top10Brains.length)];
            agents[i].brain = parentBrain.clone();
            
            // More mutation the worse they performed
            const performanceRatio = i / agents.length; // 0.1 to 1.0
            const mutationRate = 0.1 + performanceRatio * 0.2; // 0.1 to 0.3
            const mutationStrength = 0.2 + performanceRatio * 0.4; // 0.2 to 0.6
            agents[i].brain.mutate(mutationRate, mutationStrength);
          }
        };
        
        transferBrains(redAgents);
        transferBrains(blueAgents);
        
        // Update team brains to best performer
        if (redAgents[0]) this.teamBrains[0] = redAgents[0].brain.clone();
        if (blueAgents[0]) this.teamBrains[1] = blueAgents[0].brain.clone();
        
        // Reset round state
        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.weaponKills = { rocket: 0, laser: 0, sword: 0, rifle: 0 };
        this.winningTeam = null;
        this.timeLeft = this.roundTime;
        this.generateObstacles();

        this.rockets = [];
        this.rifleBullets = [];
        this.explosions = [];
        this.smokeParticles = [];
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        this.droppedWeapons = []; // Weapons dropped by dead players or weapon swaps
        this.dodgeTrails = [];
        this.dangerZones = []; // Reset edge camping danger zones

        // Reset pit spawn flags and timers, then spawn initial pickups
        for (const pit of this.pickupPits) {
          pit.hasPickup = false;
          pit.respawnTimer = 0;
          pit.respawnTime = 0;
        }
        this.spawnPickups(); // Spawn initial pickups in all pits

        // Reset teleporters for new round
        this.teleporterActive = false;
        this.teleporterActiveTimer = 0;
        this.teleporterWarpEffects = [];
        for (const tele of this.teleporters) {
          tele.lastUsedBy = null;
          tele.useCooldown = 0;
        }
        this.scheduleTeleporterActivation();

        // Reset all agents for new round (but keep names and lifetime stats)
        for (const agent of this.agents) {
          const clusterX = agent.team === 0 ? 80 : this.width - 80;
          agent.x = clusterX + (Math.random() - 0.5) * 150;
          agent.y = this.height / 2 + (Math.random() - 0.5) * (this.height - 200);
          agent.x = clamp(agent.x, 40, this.width - 40);
          agent.y = clamp(agent.y, 40, this.height - 40);
          agent.rotation = agent.team === 0 ? 0 : Math.PI;
          agent.resetForRound();
        }

        // Apply forceWeapon after reset if debug mode is active
        if (forceWeapon) {
          for (const agent of this.agents) {
            agent.weapon = forceWeapon;
            agent.hasPickedUpWeapon = true;
          }
        }

        // Spawn weapons at round start (near team spawns)
        this.spawnLaserPickups();
        this.spawnSwordPickups();
      }

      // Keep for compatibility
      spawnFromParents(parents, total) {
        this.spawnNextRound();
      }

      rebuildSpatial() {
        this.spatialAgents.clear();
        for (const a of this.agents) if (a.alive) this.spatialAgents.insert(a, a.x, a.y);
      }

      update(dt) {
        if (this.paused) return;

        this.totalTime += dt;
        if (!persistentMode) {
          this.timeLeft -= dt;
        }

        // Pickup spawning (health/armor only - weapons spawn at round start)
        // Update per-pit respawn timers (Roshan-style random respawn)
        this.updatePitTimers(dt);

        // Teleporter activation and usage
        this.updateTeleporters(dt);

        // Pickup collection
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            const dist = Math.hypot(agent.x - p.x, agent.y - p.y);
            
            if (dist < agent.radius + p.radius) {
              // Collect pickup
              if (p.type === 'health') {
                const healed = Math.min(50, agent.maxHealth - agent.health);
                agent.health = Math.min(agent.maxHealth, agent.health + 50);
                if (healed > 0) {
                  this.addEvent('ü©π ' + agent.name + ' +' + healed + 'hp', 'pickup');
                }
                // Schedule random respawn for this pit
                if (p.pitRef) {
                  p.pitRef.hasPickup = false;
                  this.schedulePitRespawn(p.pitRef);
                }
                this.pickups.splice(i, 1);
              } else if (p.type === 'armor') {
                if (agent.armor < agent.maxArmor) {
                  const gained = Math.min(50, agent.maxArmor - agent.armor);
                  agent.armor = Math.min(agent.maxArmor, agent.armor + 50);
                  this.addEvent('üõ°Ô∏è ' + agent.name + ' +' + gained + ' armor', 'pickup');
                  // Schedule random respawn for this pit
                  if (p.pitRef) {
                    p.pitRef.hasPickup = false;
                    this.schedulePitRespawn(p.pitRef);
                  }
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'laser') {
                // Auto pickup on walk-over, but only once per round
                if (!agent.hasPickedUpWeapon) {
                  agent.weapon = 'laser';
                  agent.laserCharge = 0;
                  agent.weaponCooldown = 0;
                  agent.hasPickedUpWeapon = true;
                  this.addEvent('‚ö° ' + agent.name + ' GOT THE LASER!', 'laser');
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'sword') {
                // Auto pickup on walk-over, but only once per round
                if (!agent.hasPickedUpWeapon) {
                  agent.weapon = 'sword';
                  agent.swordCharge = 0;
                  agent.swordCharging = false;
                  agent.weaponCooldown = 0;
                  agent.hasPickedUpWeapon = true;
                  this.addEvent('üó°Ô∏è ' + agent.name + ' GOT THE ENERGY SWORD!', 'sword');
                  this.pickups.splice(i, 1);
                }
              }
            }
          }
        }

        // Check for dropped weapon pickups (auto pickup, but only once per round)
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          // Only pick up if agent hasn't picked up a weapon this round
          if (agent.hasPickedUpWeapon) continue;

          for (let i = this.droppedWeapons.length - 1; i >= 0; i--) {
            const w = this.droppedWeapons[i];
            const dx = agent.x - w.x;
            const dy = agent.y - w.y;
            if (dx * dx + dy * dy < (agent.radius + w.radius) * (agent.radius + w.radius)) {
              if (w.type === 'laser') {
                agent.weapon = 'laser';
                agent.laserCharge = 0;
                agent.weaponCooldown = 0;
                agent.hasPickedUpWeapon = true;
                this.addEvent('‚ö° ' + agent.name + ' PICKED UP DROPPED LASER!', 'laser');
                this.droppedWeapons.splice(i, 1);
              } else if (w.type === 'sword') {
                agent.weapon = 'sword';
                agent.swordCharge = 0;
                agent.swordCharging = false;
                agent.weaponCooldown = 0;
                agent.hasPickedUpWeapon = true;
                this.addEvent('üó°Ô∏è ' + agent.name + ' PICKED UP DROPPED SWORD!', 'sword');
                this.droppedWeapons.splice(i, 1);
              }
            }
          }
        }

        // Update alive count + spatial hash
        let alive = 0;
        for (const a of this.agents) if (a.alive) alive++;
        this.aliveCount = alive;
        this.rebuildSpatial();
        
        // Handle respawns (skip in no respawn mode)
        if (!noRespawnMode) {
          for (const agent of this.agents) {
            if (!agent.alive && agent.respawnTimer > 0) {
              agent.respawnTimer -= dt;
              if (agent.respawnTimer <= 0) {
                agent.respawn(this);
                this.addEvent('üîÑ ' + agent.name + ' respawned', 'damage');
              }
            }
          }
        }

        // Update rockets
        for (const r of this.rockets) {
          if (!r.alive) continue;
          
          // Move rocket
          r.x += Math.cos(r.angle) * r.speed * dt;
          r.y += Math.sin(r.angle) * r.speed * dt;
          r.traveled += r.speed * dt;
          
          // Spawn smoke particles behind rocket
          r.smokeTimer = (r.smokeTimer || 0) + dt;
          if (r.smokeTimer > 0.02) { // Every 20ms
            r.smokeTimer = 0;
            this.smokeParticles.push({
              x: r.x - Math.cos(r.angle) * 15,
              y: r.y - Math.sin(r.angle) * 15,
              vx: (Math.random() - 0.5) * 30,
              vy: (Math.random() - 0.5) * 30,
              life: 0.4, // 400ms lifetime
              maxLife: 0.4,
              size: 8 + Math.random() * 6
            });
          }
          
          let explode = false;
          let explodeX = r.x;
          let explodeY = r.y;
          
          // Check range
          if (r.traveled >= r.range) {
            explode = true;
          }
          
          // Check wall collision
          if (r.x < 0 || r.x > this.width || r.y < 0 || r.y > this.height) {
            explode = true;
            explodeX = clamp(r.x, 0, this.width);
            explodeY = clamp(r.y, 0, this.height);
          }
          
          // Check obstacle collision
          if (!explode) {
            for (const obs of this.obstacles) {
              if (r.x >= obs.x && r.x <= obs.x + obs.w && r.y >= obs.y && r.y <= obs.y + obs.h) {
                explode = true;
                break;
              }
            }
          }
          
          // Check agent collision (direct hit)
          if (!explode) {
            for (const agent of this.agents) {
              if (agent === r.owner || !agent.alive) continue;
              if (Math.hypot(r.x - agent.x, r.y - agent.y) < agent.radius + 8) {
                explode = true;
                explodeX = agent.x;
                explodeY = agent.y;
                break;
              }
            }
          }
          
          // Create explosion
          if (explode) {
            r.alive = false;
            this.explosions.push({
              x: explodeX, y: explodeY, 
              owner: r.owner, 
              damage: r.damage,
              splashRadius: r.splashRadius,
              splashFalloff: r.splashFalloff,
              timer: 0, 
              maxTime: 0.4, 
              dealtDamage: false
            });
          }
        }
        this.rockets = this.rockets.filter(r => r.alive);

        // Update rifle bullets
        for (const b of this.rifleBullets) {
          if (!b.alive) continue;

          // Move bullet
          const prevX = b.x;
          const prevY = b.y;
          b.x += Math.cos(b.angle) * b.speed * dt;
          b.y += Math.sin(b.angle) * b.speed * dt;
          b.traveled += b.speed * dt;

          let hit = false;
          let hitAgent = null;

          // Check range
          if (b.traveled >= b.maxRange) {
            hit = true;
          }

          // Check wall collision
          if (!hit && (b.x < 0 || b.x > this.width || b.y < 0 || b.y > this.height)) {
            hit = true;
          }

          // Check obstacle collision
          if (!hit) {
            for (const obs of this.obstacles) {
              if (b.x >= obs.x && b.x <= obs.x + obs.w && b.y >= obs.y && b.y <= obs.y + obs.h) {
                hit = true;
                break;
              }
            }
          }

          // Check agent collision (line trace from prev to current position)
          if (!hit) {
            for (const agent of this.agents) {
              if (agent === b.owner || !agent.alive) continue;
              // Simple circle collision with bullet path
              const dist = Math.hypot(b.x - agent.x, b.y - agent.y);
              if (dist < agent.radius + RIFLE.bulletSize) {
                hit = true;
                hitAgent = agent;
                break;
              }
            }
          }

          if (hit) {
            b.alive = false;

            if (hitAgent && b.owner) {
              // Calculate damage based on distance (quadratic dropoff)
              const distRatio = Math.min(1, b.traveled / b.maxRange);
              const dropoff = distRatio * distRatio; // Quadratic
              const damage = Math.floor(RIFLE.damageClose - (RIFLE.damageClose - RIFLE.damageFar) * dropoff);

              // Check friendly fire
              if (hitAgent.team === b.owner.team) {
                if (this.friendlyFire) {
                  const killed = hitAgent.takeDamage(damage, b.owner, this);
                  if (killed) {
                    this.teamRicochets[b.owner.team]++;
                    this.addEvent('üíÄ ' + b.owner.name + ' TEAMKILLED ' + hitAgent.name + '!', 'kill');
                  }
                } else if (this.friendlyFireRicochet) {
                  const killed = b.owner.takeDamage(damage, b.owner, this);
                  this.teamRicochets[b.owner.team]++;
                  if (killed) {
                    this.addEvent('üîÑ ' + b.owner.name + ' RIFLE RICOCHET!', 'kill');
                  }
                }
              } else {
                // Enemy hit
                const comboMultiplier = b.owner.registerComboHit(hitAgent, damage);
                b.owner.damageDealt += damage;
                b.owner.lifeDamageDealt += damage;
                const killed = hitAgent.takeDamage(damage, b.owner, this);
                if (killed) {
                  const comboKillBonus = b.owner.getComboKillBonus(hitAgent);
                  b.owner.comboScore += comboKillBonus;
                  b.owner.kills++;
                  b.owner.totalKills = (b.owner.totalKills || 0) + 1;
                  b.owner.lifeKills++;
                  b.owner.weaponKills.rifle = (b.owner.weaponKills.rifle || 0) + 1;
                  b.owner.totalWeaponKills.rifle = (b.owner.totalWeaponKills.rifle || 0) + 1;
                  this.weaponKills.rifle = (this.weaponKills.rifle || 0) + 1;
                  this.totalWeaponKills.rifle = (this.totalWeaponKills.rifle || 0) + 1;
                  this.teamKills[b.owner.team]++;
                  this.teamRawKills[b.owner.team]++;
                  this.addEvent('üéØ ' + b.owner.name + ' SHOT ' + hitAgent.name + '!', 'kill');
                }
              }
            } else if (!hitAgent && b.owner) {
              // Miss penalty
              b.owner.misses = (b.owner.misses || 0) + 1;
              b.owner.lifeMisses = (b.owner.lifeMisses || 0) + 1;
            }
          }
        }
        this.rifleBullets = this.rifleBullets.filter(b => b.alive);

        // Update smoke particles
        for (const p of this.smokeParticles) {
          p.life -= dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.95; // Slow down
          p.vy *= 0.95;
          p.size += dt * 10; // Expand
        }
        this.smokeParticles = this.smokeParticles.filter(p => p.life > 0);

        // Update explosions - SPLASH DAMAGE
        for (const e of this.explosions) {
          e.timer += dt;

          if (!e.dealtDamage && e.timer >= 0.05) {
            e.dealtDamage = true;
            let hitEnemy = false; // Track if any enemy was damaged

            for (const agent of this.agents) {
              if (!agent.alive) continue;

              const dist = Math.hypot(agent.x - e.x, agent.y - e.y);
              if (dist > e.splashRadius) continue;

              // Damage falloff based on distance
              const falloff = 1 - (dist / e.splashRadius) * e.splashFalloff;
              const dmg = Math.floor(e.damage * falloff);

              if (agent === e.owner) {
                // Direct self-damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (killed) {
                  this.addEvent('üíÄ ' + e.owner.name + ' ROCKET JUMPED TOO HARD!', 'kill');
                }
              } else if (e.owner && agent.team === e.owner.team) {
                // Teammate hit
                if (this.friendlyFire) {
                  // Direct friendly fire - damage teammate
                  const killed = agent.takeDamage(dmg, e.owner, this);
                  if (killed) {
                    this.teamRicochets[e.owner.team]++;
                    this.addEvent('üíÄ ' + e.owner.name + ' TEAMKILLED ' + agent.name + '!', 'kill');
                  }
                } else if (this.friendlyFireRicochet) {
                  // Ricochet - damage reflects to shooter
                  const killed = e.owner.takeDamage(dmg, e.owner, this);
                  this.teamRicochets[e.owner.team]++;
                  if (killed) {
                    this.addEvent('üîÑ ' + e.owner.name + ' DIED FROM RICOCHET!', 'kill');
                  } else {
                    this.addEvent('üîÑ ' + e.owner.name + ' ricochet -' + dmg + 'hp', 'damage');
                  }
                }
                // Else: no friendly fire, skip
              } else {
                // Enemy damage
                hitEnemy = true;
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (e.owner) {
                  // Register combo hit (5x HP mode)
                  const comboMultiplier = e.owner.registerComboHit(agent, dmg);
                  e.owner.damageDealt += dmg;
                  e.owner.lifeDamageDealt += dmg;
                  if (killed) {
                    // Get combo kill bonus before it resets
                    const comboKillBonus = e.owner.getComboKillBonus(agent);
                    e.owner.comboScore += comboKillBonus;
                    e.owner.kills++;
                    e.owner.totalKills = (e.owner.totalKills || 0) + 1;
                    e.owner.lifeKills++;
                    e.owner.weaponKills.rocket++;
                    e.owner.totalWeaponKills.rocket++;
                    this.weaponKills.rocket++;
                    this.totalWeaponKills.rocket++;
                    this.teamKills[e.owner.team]++;
                    this.teamRawKills[e.owner.team]++;
                    this.addEvent('üöÄ ' + e.owner.name + ' FRAGGED ' + agent.name + '!', 'kill');
                  }
                }
              }
            }

            // Miss penalty if no enemy was hit
            if (!hitEnemy && e.owner) {
              e.owner.misses = (e.owner.misses || 0) + 1;
              e.owner.lifeMisses = (e.owner.lifeMisses || 0) + 1;
            }
          }
        }
        this.explosions = this.explosions.filter(e => e.timer < e.maxTime);

        // Get decisions
        const decisions = new Array(this.agents.length);
        for (let i = 0; i < this.agents.length; i++) {
          decisions[i] = this.agents[i].think(this);
        }

        // Update agents
        for (let i = 0; i < this.agents.length; i++) {
          const a = this.agents[i];
          const d = decisions[i];
          a.update(d, dt, this, this.obstacles);

          // Handle shooting based on weapon type
          if (d && d.wantsShoot) {
            if (a.weapon === 'rocket') {
              // Use base weapon (rocket or rifle)
              if (baseWeapon === 'rifle') {
                const bullet = a.tryShootRifle(this);
                if (bullet) {
                  this.rifleBullets.push(bullet);
                }
              } else {
                const rocket = a.tryShoot(this);
                if (rocket) {
                  this.rockets.push(rocket);
                }
              }
            } else if (a.weapon === 'laser') {
              // Laser charging
              if (a.weaponCooldown <= 0) {
                a.laserCharging = true;
                a.laserCharge += dt;
                
                // Fire when fully charged
                if (a.laserCharge >= 3.0) {
                  this.fireLaser(a);
                  a.laserCharge = 0;
                  a.laserCharging = false;
                  a.weaponCooldown = 1.0; // 1 second cooldown
                }
              }
            } else if (a.weapon === 'sword') {
              // Hold to aim - instantly max charged
              if (a.weaponCooldown <= 0 && !a.swordLunging) {
                a.swordCharging = true;
                a.swordCharge = 2.0; // Instant max charge
              }
            }
          } else {
            // Reset laser charge if not holding shoot
            if (a.weapon === 'laser' && a.laserCharging) {
              a.laserCharge = 0;
              a.laserCharging = false;
            }
            // Execute sword lunge when releasing
            if (a.weapon === 'sword' && a.swordCharging) {
              this.executeSwordLunge(a, a.swordCharge);
              a.swordCharge = 0;
              a.swordCharging = false;
            }
          }
        }
        
        // Update laser beams animation
        for (const beam of this.laserBeams) {
          beam.timer += dt;
        }
        this.laserBeams = this.laserBeams.filter(b => b.timer < b.maxTime);
        
        // Update sword slash animations
        for (const slash of this.swordSlashes) {
          slash.timer += dt;
        }
        this.swordSlashes = this.swordSlashes.filter(s => s.timer < s.maxTime);

        // Update dodge trail animations
        for (const trail of this.dodgeTrails) {
          trail.timer += dt;
        }
        this.dodgeTrails = this.dodgeTrails.filter(t => t.timer < t.maxTime);

        // Edge camping detection and danger zone spawning
        for (const agent of this.agents) {
          if (!agent.alive) {
            agent.edgeCampTime = 0;
            agent.inDangerZone = false;
            continue;
          }

          // Check if agent is near any edge
          const distToLeft = agent.x;
          const distToRight = this.width - agent.x;
          const distToTop = agent.y;
          const distToBottom = this.height - agent.y;
          const minDistToEdge = Math.min(distToLeft, distToRight, distToTop, distToBottom);

          if (minDistToEdge < this.edgeCampDistance) {
            agent.edgeCampTime += dt;

            // Spawn danger zone after threshold
            if (agent.edgeCampTime >= this.edgeCampThreshold) {
              // Check if there's already a danger zone near this agent
              const hasNearbyZone = this.dangerZones.some(z =>
                Math.hypot(z.x - agent.x, z.y - agent.y) < z.radius
              );

              if (!hasNearbyZone) {
                this.dangerZones.push({
                  x: agent.x,
                  y: agent.y,
                  radius: 100,
                  lifetime: 0,
                  maxLifetime: this.dangerZoneDuration,
                  targetTeam: agent.team // Only damages the camping team
                });
                this.addEvent('‚ö†Ô∏è DANGER ZONE spawned on ' + agent.name + '!', 'damage');
              }
            }
          } else {
            // Reset timer when not near edge
            agent.edgeCampTime = Math.max(0, agent.edgeCampTime - dt * 2); // Decay faster than buildup
          }
        }

        // Update danger zones and apply damage
        for (let i = this.dangerZones.length - 1; i >= 0; i--) {
          const zone = this.dangerZones[i];
          zone.lifetime += dt;

          // Apply damage to agents in zone
          for (const agent of this.agents) {
            if (!agent.alive) continue;

            const dist = Math.hypot(agent.x - zone.x, agent.y - zone.y);
            if (dist < zone.radius) {
              agent.inDangerZone = true;
              // Damage scales with how deep in the zone (more damage at center)
              // 30% of max HP per second at center, less at edges
              const intensity = 1 - (dist / zone.radius);
              const damage = agent.maxHealth * this.dangerZoneDamagePercent * intensity * dt;
              const killed = agent.takeDamage(damage, null, this); // Environmental damage
              if (killed) {
                this.addEvent('‚ò†Ô∏è ' + agent.name + ' died in DANGER ZONE!', 'death');
              }
            } else if (agent.inDangerZone) {
              agent.inDangerZone = false;
            }
          }

          // Remove expired zones
          if (zone.lifetime >= zone.maxLifetime) {
            this.dangerZones.splice(i, 1);
          }
        }

        // Agent-agent collision (push apart)
        const aliveAgents = this.agents.filter(a => a.alive);
        for (let i = 0; i < aliveAgents.length; i++) {
          for (let j = i + 1; j < aliveAgents.length; j++) {
            const a = aliveAgents[i];
            const b = aliveAgents[j];
            
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = a.radius + b.radius;
            
            if (dist < minDist && dist > 0) {
              // Push apart
              const overlap = minDist - dist;
              const pushX = (dx / dist) * overlap * 0.5;
              const pushY = (dy / dist) * overlap * 0.5;
              
              a.x -= pushX;
              a.y -= pushY;
              b.x += pushX;
              b.y += pushY;
              
              // Clamp to world bounds
              a.x = clamp(a.x, a.radius, this.width - a.radius);
              a.y = clamp(a.y, a.radius, this.height - a.radius);
              b.x = clamp(b.x, b.radius, this.width - b.radius);
              b.y = clamp(b.y, b.radius, this.height - b.radius);
            }
          }
        }

        // Check win condition (only in generational mode)
        if (!persistentMode) {
          // In no respawn mode, check if one team is eliminated
          if (noRespawnMode) {
            const redAlive = this.agents.filter(a => a.team === 0 && a.alive).length;
            const blueAlive = this.agents.filter(a => a.team === 1 && a.alive).length;
            if (redAlive === 0 || blueAlive === 0 || this.timeLeft <= 0) {
              this.endRound();
            }
          } else if (this.teamKills[0] >= this.killLimit || this.teamKills[1] >= this.killLimit || this.timeLeft <= 0) {
            this.endRound();
          }
        }
      }
      endRound() {
        // Determine winner
        if (noRespawnMode) {
          // In no respawn mode, check which team was eliminated
          const redAlive = this.agents.filter(a => a.team === 0 && a.alive).length;
          const blueAlive = this.agents.filter(a => a.team === 1 && a.alive).length;
          if (blueAlive === 0 && redAlive > 0) {
            this.winningTeam = 0;
            this.teamWins[0]++;
            this.addEvent('üî¥ RED TEAM WINS! Blue team eliminated!', 'kill');
          } else if (redAlive === 0 && blueAlive > 0) {
            this.winningTeam = 1;
            this.teamWins[1]++;
            this.addEvent('üîµ BLUE TEAM WINS! Red team eliminated!', 'kill');
          } else {
            // Time out or both eliminated - team with more alive wins, or most kills as tiebreaker
            if (redAlive !== blueAlive) {
              this.winningTeam = redAlive > blueAlive ? 0 : 1;
            } else {
              this.winningTeam = this.teamKills[0] > this.teamKills[1] ? 0 : 1;
            }
            this.teamWins[this.winningTeam]++;
            const winnerName = this.winningTeam === 0 ? 'RED' : 'BLUE';
            this.addEvent('‚è±Ô∏è TIME! ' + winnerName + ' WINS (' + (this.winningTeam === 0 ? redAlive : blueAlive) + ' alive)', 'kill');
          }
        } else if (this.teamKills[0] >= this.killLimit) {
          this.winningTeam = 0;
          this.teamWins[0]++;
          this.addEvent('üî¥ RED TEAM WINS! ' + this.teamKills[0] + ' kills!', 'kill');
        } else if (this.teamKills[1] >= this.killLimit) {
          this.winningTeam = 1;
          this.teamWins[1]++;
          this.addEvent('üîµ BLUE TEAM WINS! ' + this.teamKills[1] + ' kills!', 'kill');
        } else {
          // Time out - team with most kills wins
          this.winningTeam = this.teamKills[0] > this.teamKills[1] ? 0 : 1;
          this.teamWins[this.winningTeam]++;
          const winnerName = this.winningTeam === 0 ? 'RED' : 'BLUE';
          this.addEvent('‚è±Ô∏è TIME! ' + winnerName + ' WINS ' + this.teamKills[this.winningTeam] + '-' + this.teamKills[1-this.winningTeam], 'kill');
        }
        
        // Get best brain from winning team
        const winningAgents = this.agents.filter(a => a.team === this.winningTeam);
        const bestAgent = winningAgents.sort((a, b) => b.score - a.score)[0];
        
        // Update the winning team's brain
        this.teamBrains[this.winningTeam] = bestAgent.brain.clone();
        
        // Losing team gets a mutated version of their best, or copy winner if they had none
        const losingTeam = 1 - this.winningTeam;
        const losingAgents = this.agents.filter(a => a.team === losingTeam);
        const bestLoser = losingAgents.sort((a, b) => b.score - a.score)[0];
        if (bestLoser) {
          this.teamBrains[losingTeam] = bestLoser.brain.clone();
          this.teamBrains[losingTeam].mutate(0.2, 0.5);
        }
        
        this.addEvent('GENERATION ' + this.generation + ' COMPLETE', 'kill');
        this.generation++;
        this.spawnNextRound();
      }

      // Drop a weapon on the ground (when player dies)
      dropWeapon(x, y, weaponType) {
        if (weaponType !== 'laser' && weaponType !== 'sword') return;

        this.droppedWeapons.push({
          x: x,
          y: y,
          type: weaponType,
          radius: 15
        });

        this.addEvent('üí´ ' + weaponType.toUpperCase() + ' DROPPED!', weaponType);
      }

      addEvent(text, type) {
        this.events.unshift({ text, type, time: Date.now() });
        if (this.events.length > 80) this.events.pop();
      }

      getLeaderboard() {
        return [...this.agents].sort((a, b) => b.score - a.score).slice(0, 10);
      }
    }

    // --------------------
    // Renderer
    // --------------------
    class Renderer {
      constructor(canvas, world) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.world = world;

        // Viewport state
        this.viewportWidth = 0;
        this.viewportHeight = 0;
        this.dpr = 1;

        // Camera: position is CENTER of view in world coordinates
        this.camX = world.width / 2;
        this.camY = world.height / 2;
        this.zoom = 1; // 1 = fit arena to screen
        this.minZoom = 1;
        this.maxZoom = 4;

        // Interaction state
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.dragStartCamX = 0;
        this.dragStartCamY = 0;
        this.dragDistance = 0;
        this.followAgent = null;

        this.setupInput();
        this.resize();
      }

      // Convert screen pixel to world coordinate
      screenToWorld(screenX, screenY) {
        const scale = this.getScale();
        const [arenaScreenX, arenaScreenY] = this.getArenaScreenPosition();
        return {
          x: (screenX - arenaScreenX) / scale,
          y: (screenY - arenaScreenY) / scale
        };
      }

      // Get the scale factor (pixels per world unit)
      getScale() {
        const fitScale = Math.min(
          this.viewportWidth / this.world.width,
          this.viewportHeight / this.world.height
        );
        return fitScale * this.zoom;
      }

      // Get where arena's top-left corner appears on screen
      getArenaScreenPosition() {
        const scale = this.getScale();
        const arenaPixelW = this.world.width * scale;
        const arenaPixelH = this.world.height * scale;

        // Center of arena in screen pixels (center of viewport + camera offset)
        const centerScreenX = this.viewportWidth / 2 - (this.camX - this.world.width / 2) * scale;
        const centerScreenY = this.viewportHeight / 2 - (this.camY - this.world.height / 2) * scale;

        // Top-left of arena
        return [
          centerScreenX - arenaPixelW / 2,
          centerScreenY - arenaPixelH / 2
        ];
      }

      setupInput() {
        // Mouse wheel zoom
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          // World position under mouse before zoom
          const worldBefore = this.screenToWorld(mouseX, mouseY);

          // Apply zoom
          const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
          this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom * zoomDelta));

          // World position under mouse after zoom
          const worldAfter = this.screenToWorld(mouseX, mouseY);

          // Adjust camera to keep same world point under mouse
          this.camX += worldBefore.x - worldAfter.x;
          this.camY += worldBefore.y - worldAfter.y;

          this.clampCamera();
        }, { passive: false });

        // Drag to pan
        const startDrag = (x, y) => {
          this.isDragging = true;
          this.dragStartX = x;
          this.dragStartY = y;
          this.dragStartCamX = this.camX;
          this.dragStartCamY = this.camY;
          this.dragDistance = 0;
          this.canvas.style.cursor = 'grabbing';
        };

        const moveDrag = (x, y) => {
          if (!this.isDragging) return;
          const dx = x - this.dragStartX;
          const dy = y - this.dragStartY;
          this.dragDistance = Math.hypot(dx, dy);

          const scale = this.getScale();
          this.camX = this.dragStartCamX - dx / scale;
          this.camY = this.dragStartCamY - dy / scale;
          this.clampCamera();

          if (this.dragDistance > 5) {
            this.followAgent = null;
          }
        };

        const endDrag = (x, y) => {
          const wasClick = this.dragDistance < 5;
          this.isDragging = false;
          this.canvas.style.cursor = 'grab';

          if (wasClick && x !== undefined) {
            this.handleClick(x, y);
          }
        };

        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
        window.addEventListener('mouseup', (e) => endDrag(e.clientX, e.clientY));

        // Touch events
        this.canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            startDrag(e.touches[0].clientX, e.touches[0].clientY);
          }
        }, { passive: true });

        this.canvas.addEventListener('touchmove', (e) => {
          if (!this.isDragging || e.touches.length !== 1) return;
          e.preventDefault();
          moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        this.canvas.addEventListener('touchend', (e) => endDrag());

        this.canvas.style.cursor = 'grab';
      }

      clampCamera() {
        const scale = this.getScale();
        const viewW = this.viewportWidth / scale;
        const viewH = this.viewportHeight / scale;

        // At zoom=1, camera should be centered (camX = world.width/2, camY = world.height/2)
        // At higher zoom, allow panning but keep arena edges visible

        const halfViewW = viewW / 2;
        const halfViewH = viewH / 2;

        // Minimum: camera can't go so far left that right edge of view goes past arena
        // Maximum: camera can't go so far right that left edge of view goes past arena
        const minX = Math.min(halfViewW, this.world.width / 2);
        const maxX = Math.max(this.world.width - halfViewW, this.world.width / 2);
        const minY = Math.min(halfViewH, this.world.height / 2);
        const maxY = Math.max(this.world.height - halfViewH, this.world.height / 2);

        this.camX = Math.max(minX, Math.min(maxX, this.camX));
        this.camY = Math.max(minY, Math.min(maxY, this.camY));
      }

      handleClick(clientX, clientY) {
        const rect = this.canvas.getBoundingClientRect();
        const screenX = clientX - rect.left;
        const screenY = clientY - rect.top;
        const world = this.screenToWorld(screenX, screenY);

        let closestAgent = null;
        let closestDist = 30;

        for (const agent of this.world.agents) {
          const dist = Math.hypot(agent.x - world.x, agent.y - world.y);
          if (dist < closestDist) {
            closestDist = dist;
            closestAgent = agent;
          }
        }

        this.followAgent = closestAgent;
      }

      updateFollow() {
        if (!this.followAgent) return;
        if (this.followAgent.alive) {
          this.camX = this.followAgent.x;
          this.camY = this.followAgent.y;
          this.clampCamera();
        }
      }

      resize() {
        const container = this.canvas.parentElement;
        this.viewportWidth = container.clientWidth;
        this.viewportHeight = container.clientHeight;
        this.dpr = window.devicePixelRatio || 1;

        // Set canvas buffer size (for sharp rendering)
        this.canvas.width = Math.floor(this.viewportWidth * this.dpr);
        this.canvas.height = Math.floor(this.viewportHeight * this.dpr);

        // Set canvas CSS size (actual display size)
        this.canvas.style.width = this.viewportWidth + 'px';
        this.canvas.style.height = this.viewportHeight + 'px';

        // Reset camera to center
        this.camX = this.world.width / 2;
        this.camY = this.world.height / 2;
        this.clampCamera();
      }

      render() {
        const ctx = this.ctx;
        const scale = this.getScale();
        const [arenaX, arenaY] = this.getArenaScreenPosition();

        // Apply DPR scaling
        ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        // Clear entire canvas with background color
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, this.viewportWidth, this.viewportHeight);

        // Set up transform for world rendering
        ctx.save();
        ctx.translate(arenaX, arenaY);
        ctx.scale(scale, scale);

        // Now all drawing is in world coordinates (0,0 is top-left of arena)
        // Use worldW/worldH for sizes, coordinates are direct world units
        const w = this.world.width;
        const h = this.world.height;

        if (turboMode) {
          // TURBO: Simple solid background and border
          ctx.fillStyle = '#0a0b14';
          ctx.fillRect(0, 0, w, h);
          ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
          ctx.lineWidth = 2 / scale;
          ctx.strokeRect(1, 1, w - 2, h - 2);
        } else {
          // Arena floor - deeper space gradient
          const floorGrad = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, w * 0.7);
          floorGrad.addColorStop(0, '#0d0e1a');
          floorGrad.addColorStop(0.5, '#090a14');
          floorGrad.addColorStop(1, '#05060c');
          ctx.fillStyle = floorGrad;
          ctx.fillRect(0, 0, w, h);

          // Holodeck-style hex grid with cyan glow
          const hexSize = 60;
          const time = Date.now() / 3000;
          ctx.lineWidth = 1 / scale;
          for (let row = 0; row < h / (hexSize * 0.866) + 1; row++) {
            for (let col = 0; col < w / hexSize + 1; col++) {
              const cx = col * hexSize * 1.5 + (row % 2) * hexSize * 0.75;
              const cy = row * hexSize * 0.866;
              if (cx > w + hexSize || cy > h + hexSize) continue;

              // Distance from center for intensity falloff
              const distFromCenter = Math.hypot(cx - w/2, cy - h/2) / (w * 0.5);
              const centerIntensity = Math.max(0, 1 - distFromCenter * 0.7);

              // Subtle pulse based on position
              const pulse = Math.sin(time + col * 0.3 + row * 0.2) * 0.2 + 0.8;
              const alpha = pulse * 0.4 * (0.3 + centerIntensity * 0.4);
              ctx.strokeStyle = `rgba(0, 180, 220, ${alpha})`;

              ctx.beginPath();
              for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3 - Math.PI / 6;
                const hx = cx + Math.cos(angle) * hexSize * 0.4;
                const hy = cy + Math.sin(angle) * hexSize * 0.4;
                if (i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
              }
              ctx.closePath();
              ctx.stroke();
            }
          }

          // Center danger zone glow (where weapons spawn)
          const centerGlow = ctx.createRadialGradient(w / 2, h / 2, 30, w / 2, h / 2, 350);
          centerGlow.addColorStop(0, 'rgba(255, 50, 100, 0.12)');
          centerGlow.addColorStop(0.3, 'rgba(255, 50, 100, 0.06)');
          centerGlow.addColorStop(1, 'rgba(255, 50, 100, 0)');
          ctx.fillStyle = centerGlow;
          ctx.fillRect(0, 0, w, h);

          // Team spawn zone hints - enhanced glow
          const redZone = ctx.createRadialGradient(100, h / 2, 30, 100, h / 2, 250);
          redZone.addColorStop(0, 'rgba(255, 68, 102, 0.15)');
          redZone.addColorStop(0.5, 'rgba(255, 68, 102, 0.05)');
          redZone.addColorStop(1, 'rgba(255, 68, 102, 0)');
          ctx.fillStyle = redZone;
          ctx.fillRect(0, 0, w, h);

          const blueZone = ctx.createRadialGradient(w - 100, h / 2, 30, w - 100, h / 2, 250);
          blueZone.addColorStop(0, 'rgba(68, 153, 255, 0.15)');
          blueZone.addColorStop(0.5, 'rgba(68, 153, 255, 0.05)');
          blueZone.addColorStop(1, 'rgba(68, 153, 255, 0)');
          ctx.fillStyle = blueZone;
          ctx.fillRect(0, 0, w, h);

          // Edge camping danger zones - pulsing red warning zones
          for (const zone of this.world.dangerZones) {
            const progress = zone.lifetime / zone.maxLifetime;
            const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
            const fadeIn = Math.min(1, zone.lifetime * 3); // Quick fade in
            const fadeOut = zone.lifetime > zone.maxLifetime - 0.5 ? (zone.maxLifetime - zone.lifetime) * 2 : 1;
            const alpha = fadeIn * fadeOut * pulse;

            // Outer warning ring
            const outerGrad = ctx.createRadialGradient(zone.x, zone.y, zone.radius * 0.6, zone.x, zone.y, zone.radius);
            outerGrad.addColorStop(0, `rgba(255, 0, 50, 0)`);
            outerGrad.addColorStop(0.7, `rgba(255, 0, 50, ${0.2 * alpha})`);
            outerGrad.addColorStop(1, `rgba(255, 0, 50, ${0.4 * alpha})`);
            ctx.fillStyle = outerGrad;
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
            ctx.fill();

            // Inner danger core
            const innerGrad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius * 0.5);
            innerGrad.addColorStop(0, `rgba(255, 50, 100, ${0.5 * alpha})`);
            innerGrad.addColorStop(0.5, `rgba(255, 0, 50, ${0.3 * alpha})`);
            innerGrad.addColorStop(1, `rgba(255, 0, 50, 0)`);
            ctx.fillStyle = innerGrad;
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius * 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Warning ring stroke
            ctx.strokeStyle = `rgba(255, 100, 100, ${0.8 * alpha})`;
            ctx.lineWidth = 3 * px;
            ctx.setLineDash([10 * px, 10 * px]);
            ctx.lineDashOffset = -Date.now() / 50; // Animated dash
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Skull/warning icon at center
            ctx.font = `${24 * px}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * alpha})`;
            ctx.fillText('‚ò†Ô∏è', zone.x, zone.y);
          }

          // Border - glowing tech frame with softer color
          ctx.shadowBlur = 20 / scale;
          ctx.shadowColor = 'rgba(0, 200, 255, 0.5)';
          ctx.strokeStyle = 'rgba(0, 200, 255, 0.6)';
          ctx.lineWidth = 2 / scale;
          ctx.strokeRect(2, 2, w - 4, h - 4);
          ctx.shadowBlur = 0;

          // Corner accents - matching cyan theme
          const cornerSize = 50;
          ctx.strokeStyle = 'rgba(0, 243, 255, 0.8)';
          ctx.lineWidth = 2 / scale;
          ctx.shadowBlur = 8 / scale;
          ctx.shadowColor = 'rgba(0, 243, 255, 0.5)';
          // Top-left
          ctx.beginPath(); ctx.moveTo(0, cornerSize); ctx.lineTo(0, 0); ctx.lineTo(cornerSize, 0); ctx.stroke();
          // Top-right
          ctx.beginPath(); ctx.moveTo(w - cornerSize, 0); ctx.lineTo(w, 0); ctx.lineTo(w, cornerSize); ctx.stroke();
          // Bottom-left
          ctx.beginPath(); ctx.moveTo(0, h - cornerSize); ctx.lineTo(0, h); ctx.lineTo(cornerSize, h); ctx.stroke();
          // Bottom-right
          ctx.beginPath(); ctx.moveTo(w - cornerSize, h); ctx.lineTo(w, h); ctx.lineTo(w, h - cornerSize); ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Buildings/Obstacles (coordinates are already in world units)
        for (const b of this.world.buildings) {
          const x = b.x, y = b.y, bw = b.w, bh = b.h;

          if (turboMode) {
            // TURBO: Simple solid rectangle
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(x, y, bw, bh);
          } else {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(x + 6, y + 6, bw, bh);

            // Main body gradient
            const obstacleGrad = ctx.createLinearGradient(x, y, x + bw, y + bh);
            obstacleGrad.addColorStop(0, '#1a1a2e');
            obstacleGrad.addColorStop(0.5, '#12121f');
            obstacleGrad.addColorStop(1, '#0a0a15');
            ctx.fillStyle = obstacleGrad;
            ctx.fillRect(x, y, bw, bh);

            // Top highlight
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(x, y, bw, 3);
            ctx.fillRect(x, y, 3, bh);

            // Bottom shadow edge
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(x, y + bh - 3, bw, 3);
            ctx.fillRect(x + bw - 3, y, 3, bh);

            // Tech lines
            ctx.strokeStyle = 'rgba(0, 255, 200, 0.15)';
            ctx.lineWidth = 1 / scale;
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(x + 5, y + bh / 2);
            ctx.lineTo(x + bw - 5, y + bh / 2);
            ctx.stroke();
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(x + bw / 2, y + 5);
            ctx.lineTo(x + bw / 2, y + bh - 5);
            ctx.stroke();

            // Corner brackets
            const bracketSize = Math.min(bw, bh) * 0.2;
            ctx.strokeStyle = 'rgba(0, 255, 200, 0.3)';
            ctx.lineWidth = 2 / scale;
            // Top-left bracket
            ctx.beginPath();
            ctx.moveTo(x + bracketSize, y + 4);
            ctx.lineTo(x + 4, y + 4);
            ctx.lineTo(x + 4, y + bracketSize);
            ctx.stroke();
            // Top-right bracket
            ctx.beginPath();
            ctx.moveTo(x + bw - bracketSize, y + 4);
            ctx.lineTo(x + bw - 4, y + 4);
            ctx.lineTo(x + bw - 4, y + bracketSize);
            ctx.stroke();
            // Bottom-left bracket
            ctx.beginPath();
            ctx.moveTo(x + bracketSize, y + bh - 4);
            ctx.lineTo(x + 4, y + bh - 4);
            ctx.lineTo(x + 4, y + bh - bracketSize);
            ctx.stroke();
            // Bottom-right bracket
            ctx.beginPath();
            ctx.moveTo(x + bw - bracketSize, y + bh - 4);
            ctx.lineTo(x + bw - 4, y + bh - 4);
            ctx.lineTo(x + bw - 4, y + bh - bracketSize);
            ctx.stroke();

            // Outer glow
            ctx.strokeStyle = 'rgba(0, 200, 255, 0.2)';
            ctx.lineWidth = 1 / scale;
            ctx.strokeRect(x - 1, y - 1, bw + 2, bh + 2);
          }
        }

        // Compatibility: s=1 since scale transform handles scaling
        // Old code used x*s, y*s - now just x, y works (transform does it)
        const s = 1;
        // Helper for pixel-based values (lineWidth, shadowBlur)
        const px = 1 / scale;

        // Teleporters
        this.drawTeleporters(ctx, s);

        // Pickups (coordinates are in world units, px for pixel-based values)
        for (const p of this.world.pickups) {
          const pX = p.x, pY = p.y, pr = p.radius;

          if (turboMode) {
            // TURBO: Simple colored circles
            const colors = { health: '#00ff9d', armor: '#00aaff', laser: '#00ffff', sword: '#ff00ff' };
            ctx.fillStyle = colors[p.type] || '#fff';
            ctx.beginPath();
            ctx.arc(pX, pY, pr, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Glow effect
            const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;

            if (p.type === 'health') {
              // Health pack - green cross shape
              ctx.shadowBlur = 15 * pulse * px;
              ctx.shadowColor = '#00ff9d';
              ctx.fillStyle = '#00ff9d';

              // Horizontal bar of cross
              ctx.fillRect(pX - pr, pY - pr * 0.3, pr * 2, pr * 0.6);
              // Vertical bar of cross
              ctx.fillRect(pX - pr * 0.3, pY - pr, pr * 0.6, pr * 2);

            } else if (p.type === 'armor') {
              // Armor pack - blue kite shield
              ctx.shadowBlur = 15 * pulse * px;
              ctx.shadowColor = '#00aaff';
              ctx.fillStyle = '#00aaff';

              // Kite shield shape (wider at top, pointed at bottom)
              ctx.beginPath();
              ctx.moveTo(pX, pY - pr * 1.1);           // Top center
              ctx.lineTo(pX + pr * 0.8, pY - pr * 0.3); // Top right
              ctx.lineTo(pX + pr * 0.6, pY + pr * 0.4); // Mid right
              ctx.lineTo(pX, pY + pr * 1.1);            // Bottom point
              ctx.lineTo(pX - pr * 0.6, pY + pr * 0.4); // Mid left
              ctx.lineTo(pX - pr * 0.8, pY - pr * 0.3); // Top left
              ctx.closePath();
              ctx.fill();

              // Inner highlight
              ctx.strokeStyle = 'rgba(255,255,255,0.5)';
              ctx.lineWidth = 2 * px;
              ctx.stroke();
            } else if (p.type === 'laser') {
              // Laser pickup - electric bolt shape
              ctx.shadowBlur = 20 * pulse * px;
              ctx.shadowColor = '#00ffff';
              ctx.fillStyle = '#00ffff';

              // Lightning bolt shape
              ctx.beginPath();
              ctx.moveTo(pX + pr * 0.3, pY - pr * 1.2);
              ctx.lineTo(pX - pr * 0.1, pY - pr * 0.2);
              ctx.lineTo(pX + pr * 0.3, pY - pr * 0.2);
              ctx.lineTo(pX - pr * 0.3, pY + pr * 1.2);
              ctx.lineTo(pX + pr * 0.1, pY + pr * 0.2);
              ctx.lineTo(pX - pr * 0.3, pY + pr * 0.2);
              ctx.closePath();
              ctx.fill();

              // Inner glow
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2 * px;
              ctx.stroke();
            } else if (p.type === 'sword') {
              // Sword pickup - energy sword shape (neutral purple until picked up)
              ctx.shadowBlur = 20 * pulse * px;
              ctx.shadowColor = '#ff00ff';
              ctx.fillStyle = '#ff00ff';

              // Sword blade shape
              ctx.beginPath();
              ctx.moveTo(pX, pY - pr * 1.5);           // Tip
              ctx.lineTo(pX + pr * 0.3, pY - pr * 0.5); // Right edge upper
              ctx.lineTo(pX + pr * 0.2, pY + pr * 0.8); // Right edge lower
              ctx.lineTo(pX, pY + pr * 1.2);            // Handle
              ctx.lineTo(pX - pr * 0.2, pY + pr * 0.8); // Left edge lower
              ctx.lineTo(pX - pr * 0.3, pY - pr * 0.5); // Left edge upper
              ctx.closePath();
              ctx.fill();

              // Inner glow line
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2 * px;
              ctx.stroke();
            }
            ctx.shadowBlur = 0;
          }
        }

        // Dropped weapons
        if (!turboMode) {
          for (const w of this.world.droppedWeapons) {
            const wx = w.x * s, wy = w.y * s, wr = w.radius * s;

            // Faster pulse for dropped weapons + slight bounce effect
            const pulse = Math.sin(Date.now() / 100) * 0.4 + 0.6;
            const bounce = Math.abs(Math.sin(Date.now() / 300)) * 3 * s;

            if (w.type === 'laser') {
              // Dropped laser - cyan lightning bolt with flash effect
              ctx.shadowBlur = 25 * pulse;
              ctx.shadowColor = '#00ffff';
              ctx.fillStyle = `rgba(0, 255, 255, ${0.7 + pulse * 0.3})`;

              // Lightning bolt shape (slightly larger than pickup)
              ctx.beginPath();
              ctx.moveTo(wx + wr * 0.35, wy - bounce - wr * 1.4);
              ctx.lineTo(wx - wr * 0.1, wy - bounce - wr * 0.25);
              ctx.lineTo(wx + wr * 0.35, wy - bounce - wr * 0.25);
              ctx.lineTo(wx - wr * 0.35, wy - bounce + wr * 1.4);
              ctx.lineTo(wx + wr * 0.1, wy - bounce + wr * 0.25);
              ctx.lineTo(wx - wr * 0.35, wy - bounce + wr * 0.25);
              ctx.closePath();
              ctx.fill();

              // Bright core
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.stroke();

              // "DROPPED" indicator ring
              ctx.strokeStyle = `rgba(0, 255, 255, ${pulse * 0.5})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(wx, wy - bounce, wr * 1.8, 0, Math.PI * 2);
              ctx.stroke();

            } else if (w.type === 'sword') {
              // Dropped sword - magenta sword shape with flash effect
              ctx.shadowBlur = 25 * pulse;
              ctx.shadowColor = '#ff00ff';
              ctx.fillStyle = `rgba(255, 0, 255, ${0.7 + pulse * 0.3})`;

              // Sword blade shape (slightly larger than pickup)
              ctx.beginPath();
              ctx.moveTo(wx, wy - bounce - wr * 1.7);           // Tip
              ctx.lineTo(wx + wr * 0.35, wy - bounce - wr * 0.6); // Right edge upper
              ctx.lineTo(wx + wr * 0.25, wy - bounce + wr * 0.9); // Right edge lower
              ctx.lineTo(wx, wy - bounce + wr * 1.4);             // Handle
              ctx.lineTo(wx - wr * 0.25, wy - bounce + wr * 0.9); // Left edge lower
              ctx.lineTo(wx - wr * 0.35, wy - bounce - wr * 0.6); // Left edge upper
              ctx.closePath();
              ctx.fill();

              // Bright core
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.stroke();

              // "DROPPED" indicator ring
              ctx.strokeStyle = `rgba(255, 0, 255, ${pulse * 0.5})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(wx, wy - bounce, wr * 1.8, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.shadowBlur = 0;
          }
        } else {
          // TURBO: Simple circles for dropped weapons
          for (const w of this.world.droppedWeapons) {
            const wx = w.x * s, wy = w.y * s, wr = w.radius * s;
            ctx.fillStyle = w.type === 'laser' ? '#00ffff' : '#ff00ff';
            ctx.beginPath();
            ctx.arc(wx, wy, wr, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Draw raycast visualization for followed agent (behind everything)
        if (this.followAgent && this.followAgent.alive && this.followAgent.lastRayData) {
          const agent = this.followAgent;
          const x = agent.x * s, y = agent.y * s;
          const rayData = agent.lastRayData;
          const numRays = 21;
          const fov = Math.PI * 0.8; // 144 degree FOV
          const startAngle = agent.rotation - fov / 2;
          const angleStep = fov / (numRays - 1);
          const maxDist = Math.hypot(this.world.width, this.world.height);

          ctx.save();
          ctx.globalAlpha = 0.4;

          for (let i = 0; i < numRays; i++) {
            const dist = rayData[i * 2] * maxDist;
            const type = rayData[i * 2 + 1];
            const angle = startAngle + angleStep * i;

            const endX = x + Math.cos(angle) * dist * s;
            const endY = y + Math.sin(angle) * dist * s;

            // Color based on what the ray hit
            // Types: 0=wall, 0.25=pickup, 0.5=obstacle, 1=agent
            let color;
            if (type >= 0.9) {
              color = '#ff4444'; // Hit an agent
            } else if (type >= 0.4) {
              color = '#ffaa00'; // Hit an obstacle
            } else if (type >= 0.2) {
              color = '#00ff88'; // Hit a pickup (weapon/health/armor)
            } else {
              color = '#444444'; // Hit a wall
            }

            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Small dot at hit point
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(endX, endY, 3 * s, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        // Agents with class-based rendering
        for (const agent of this.world.agents) {
          if (!agent.alive) continue;
          const x = agent.x * s, y = agent.y * s, r = agent.radius * s;

          if (turboMode) {
            // TURBO: Simple colored circle with direction line
            ctx.fillStyle = agent.team === 0 ? '#ff4466' : '#4499ff';
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
            // Direction indicator
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(agent.rotation) * r * 1.5, y + Math.sin(agent.rotation) * r * 1.5);
            ctx.stroke();
            continue; // Skip detailed rendering
          }

          // Selection highlight for followed agent
          if (agent === this.followAgent) {
            ctx.save();
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffff00';
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.arc(x, y, r + 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            ctx.restore();
          }

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(agent.rotation);

          // Vision cone
          const fov = Math.PI * 0.4;
          const viewDist = 200 * s;
          const grad = ctx.createRadialGradient(0, 0, r, 0, 0, viewDist);
          grad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
          grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, viewDist, -fov / 2, fov / 2);
          ctx.fill();

          // Body with enhanced glow
          const baseColor = agent.team === 0 ? '#ff4466' : '#4499ff';
          const swordColor = agent.team === 0 ? '#ff4466' : '#4499ff';
          const laserColor = agent.team === 0 ? '#ff00aa' : '#00aaff';
          const activeColor = agent.weapon === 'laser' ? laserColor : (agent.weapon === 'sword' ? swordColor : baseColor);

          // Outer glow
          ctx.shadowBlur = 20;
          ctx.shadowColor = activeColor;
          ctx.fillStyle = '#0a0a12';
          ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();

          // Inner ring with gradient
          const ringGrad = ctx.createRadialGradient(0, 0, r * 0.7, 0, 0, r);
          ringGrad.addColorStop(0, 'transparent');
          ringGrad.addColorStop(0.8, activeColor + '40');
          ringGrad.addColorStop(1, activeColor);
          ctx.strokeStyle = ringGrad;
          ctx.lineWidth = 3;
          ctx.stroke();

          // Core highlight
          ctx.shadowBlur = 0;
          ctx.fillStyle = activeColor + '20';
          ctx.beginPath(); ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2); ctx.fill();

          if (agent.weapon === 'rocket') {
            // Rocket launcher on right shoulder
            ctx.save();
            const shoulderOffset = r * 0.7; // offset to right shoulder
            ctx.translate(0, -shoulderOffset);

            // Launcher body - military style tube
            const gradient = ctx.createLinearGradient(r * 0.2, -5 * s, r * 0.2, 5 * s);
            gradient.addColorStop(0, '#666');
            gradient.addColorStop(0.3, '#444');
            gradient.addColorStop(0.7, '#333');
            gradient.addColorStop(1, '#222');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(r * 0.2, -5 * s, r * 1.5, 10 * s, 3 * s);
            ctx.fill();

            // Launcher tube opening
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(r * 1.7, 0, 5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Orange warning stripes
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(r * 0.4, -4 * s);
            ctx.lineTo(r * 0.4, 4 * s);
            ctx.moveTo(r * 0.6, -4 * s);
            ctx.lineTo(r * 0.6, 4 * s);
            ctx.stroke();

            // Scope/sight on top
            ctx.fillStyle = '#555';
            ctx.fillRect(r * 0.8, -8 * s, r * 0.4, 3 * s);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(r * 0.9, -7 * s, r * 0.2, 1.5 * s);

            // Exhaust vents at back
            ctx.fillStyle = '#333';
            ctx.fillRect(r * 0.1, -4 * s, r * 0.15, 8 * s);

            ctx.restore();

            // Small rocket icon on body
            ctx.fillStyle = '#ff6600';
            ctx.font = 'bold ' + (r * 0.5) + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üöÄ', 0, 0);
          } else if (agent.weapon === 'laser') {
            // Legendary Plasma Cannon - Team colored
            const chargeProgress = agent.laserCharging ? agent.laserCharge / 3.0 : 0;

            // Team-specific colors
            const isRed = agent.team === 0;
            const primaryColor = isRed ? '#ff00aa' : '#00aaff';
            const primaryRGB = isRed ? '255, 0, 170' : '0, 170, 255';
            const secondaryRGB = isRed ? '255, 100, 200' : '100, 200, 255';
            const darkTint = isRed ? '#2a1a2a' : '#1a2a3a';
            const midTint = isRed ? '#3a1a3a' : '#0a1a2a';

            // Main body - sleek futuristic design
            const bodyGradient = ctx.createLinearGradient(r * 0.2, -6 * s, r * 0.2, 6 * s);
            bodyGradient.addColorStop(0, darkTint);
            bodyGradient.addColorStop(0.3, midTint);
            bodyGradient.addColorStop(0.7, '#0a0a1a');
            bodyGradient.addColorStop(1, midTint);
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.moveTo(r * 0.2, -5 * s);
            ctx.lineTo(r * 1.4, -4 * s);
            ctx.lineTo(r * 1.6, -3 * s);
            ctx.lineTo(r * 1.6, 3 * s);
            ctx.lineTo(r * 1.4, 4 * s);
            ctx.lineTo(r * 0.2, 5 * s);
            ctx.closePath();
            ctx.fill();

            // Energy coils around barrel
            ctx.shadowBlur = 8;
            ctx.shadowColor = primaryColor;
            ctx.strokeStyle = primaryColor;
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 3; i++) {
              const cx = r * 0.6 + i * r * 0.35;
              const coilAlpha = 0.4 + chargeProgress * 0.6;
              ctx.strokeStyle = `rgba(${primaryRGB}, ${coilAlpha})`;
              ctx.beginPath();
              ctx.arc(cx, 0, 5 * s, -Math.PI * 0.7, Math.PI * 0.7);
              ctx.stroke();
            }

            // Central energy conduit
            const conduitGradient = ctx.createLinearGradient(r * 0.3, 0, r * 1.5, 0);
            conduitGradient.addColorStop(0, `rgba(${primaryRGB}, 0.4)`);
            conduitGradient.addColorStop(0.5, `rgba(${primaryRGB}, ${0.3 + chargeProgress * 0.7})`);
            conduitGradient.addColorStop(1, `rgba(${secondaryRGB}, 0.9)`);
            ctx.fillStyle = conduitGradient;
            ctx.fillRect(r * 0.3, -2 * s, r * 1.2, 4 * s);

            // Barrel tip - focusing lens
            ctx.shadowBlur = 10 + chargeProgress * 15;
            ctx.fillStyle = '#0a0a1a';
            ctx.beginPath();
            ctx.arc(r * 1.7, 0, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = `rgba(${primaryRGB}, ${0.6 + chargeProgress * 0.4})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Inner focusing ring
            ctx.fillStyle = `rgba(${primaryRGB}, ${0.3 + chargeProgress * 0.7})`;
            ctx.beginPath();
            ctx.arc(r * 1.7, 0, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Charging effect - energy spiral
            if (agent.laserCharging && agent.laserCharge > 0) {
              ctx.shadowBlur = 20 * chargeProgress;
              ctx.shadowColor = primaryColor;

              // Rotating energy particles converging to barrel tip
              for (let i = 0; i < 8; i++) {
                const angle = (Date.now() / 120 + i * Math.PI / 4) % (Math.PI * 2);
                const dist = (1 - chargeProgress * 0.7) * r * 0.9;
                const px = r * 1.7 + Math.cos(angle) * dist;
                const py = Math.sin(angle) * dist;
                const pSize = (2 + chargeProgress * 4) * s;

                ctx.fillStyle = `rgba(${primaryRGB}, ${chargeProgress * 0.9})`;
                ctx.beginPath();
                ctx.arc(px, py, pSize, 0, Math.PI * 2);
                ctx.fill();
              }

              // Secondary particle ring
              for (let i = 0; i < 4; i++) {
                const angle = (Date.now() / 200 + i * Math.PI / 2 + Math.PI / 4) % (Math.PI * 2);
                const dist = (1 - chargeProgress * 0.5) * r * 1.2;
                const px = r * 1.7 + Math.cos(angle) * dist;
                const py = Math.sin(angle) * dist;

                ctx.fillStyle = `rgba(255, 255, 255, ${chargeProgress * 0.5})`;
                ctx.beginPath();
                ctx.arc(px, py, 2 * s, 0, Math.PI * 2);
                ctx.fill();
              }

              // Energy buildup at tip
              ctx.fillStyle = `rgba(255, 255, 255, ${chargeProgress * 0.8})`;
              ctx.beginPath();
              ctx.arc(r * 1.7, 0, (2 + chargeProgress * 6) * s, 0, Math.PI * 2);
              ctx.fill();

              // Warning indicator - pulsing ring
              if (chargeProgress > 0.7) {
                const pulse = (Math.sin(Date.now() / 50) + 1) * 0.5;
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(r * 1.7, 0, (8 + chargeProgress * 4) * s, 0, Math.PI * 2);
                ctx.stroke();

                // Additional warning particles
                for (let i = 0; i < 3; i++) {
                  const sparkAngle = Date.now() / 30 + i * Math.PI * 2 / 3;
                  const sparkDist = (10 + chargeProgress * 5) * s;
                  ctx.fillStyle = `rgba(${primaryRGB}, ${pulse})`;
                  ctx.beginPath();
                  ctx.arc(r * 1.7 + Math.cos(sparkAngle) * sparkDist, Math.sin(sparkAngle) * sparkDist, 2 * s, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
            }

            ctx.shadowBlur = 0;
          } else if (agent.weapon === 'sword') {
            // Legendary Energy Katana
            // Define sword color locally to ensure correct team color
            const localSwordColor = agent.team === 0 ? '#ff4444' : '#4488ff';

            ctx.save();
            if (agent.swordCharging) {
              // Ready stance - sword held to right side with backward angle (samurai style)
              ctx.rotate(Math.PI / 2 + Math.PI / 6);
            }

            const bladeLength = r * 2.0;
            const bladeWidth = 4 * s;
            const hiltLength = r * 0.5;

            // Hilt/handle - wrapped grip style
            const hiltGradient = ctx.createLinearGradient(0, -3 * s, 0, 3 * s);
            hiltGradient.addColorStop(0, '#2a2a2a');
            hiltGradient.addColorStop(0.5, '#1a1a1a');
            hiltGradient.addColorStop(1, '#2a2a2a');
            ctx.fillStyle = hiltGradient;
            ctx.fillRect(r * 0.1, -3 * s, hiltLength, 6 * s);

            // Hilt wrapping lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
              const wx = r * 0.15 + i * (hiltLength / 4);
              ctx.beginPath();
              ctx.moveTo(wx, -3 * s);
              ctx.lineTo(wx + 3 * s, 3 * s);
              ctx.stroke();
            }

            // Guard (tsuba) - circular with team color accent
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(r * 0.6, 0, 6 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = localSwordColor;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Blade (no shadowBlur for performance)

            // Blade shape - katana style with curved edge
            ctx.beginPath();
            ctx.moveTo(r * 0.65, -bladeWidth);           // blade start top
            ctx.lineTo(r * 0.65 + bladeLength * 0.9, -bladeWidth * 0.7);  // taper to tip
            ctx.quadraticCurveTo(r * 0.65 + bladeLength * 1.05, 0, r * 0.65 + bladeLength * 0.9, bladeWidth * 0.3); // curved tip
            ctx.lineTo(r * 0.65, bladeWidth * 0.3);      // blade start bottom (thinner back edge)
            ctx.closePath();

            // Blade gradient - energy core effect
            const bladeGradient = ctx.createLinearGradient(r * 0.65, -bladeWidth, r * 0.65, bladeWidth);
            const baseColor = agent.team === 0 ? [255, 68, 68] : [68, 136, 255];
            bladeGradient.addColorStop(0, `rgba(${baseColor.join(',')}, 0.9)`);
            bladeGradient.addColorStop(0.3, '#fff');
            bladeGradient.addColorStop(0.5, `rgba(${baseColor.join(',')}, 0.95)`);
            bladeGradient.addColorStop(1, `rgba(${baseColor.join(',')}, 0.7)`);
            ctx.fillStyle = bladeGradient;
            ctx.fill();

            // Blade edge highlight (sharp edge)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(r * 0.65, -bladeWidth);
            ctx.lineTo(r * 0.65 + bladeLength * 0.9, -bladeWidth * 0.7);
            ctx.quadraticCurveTo(r * 0.65 + bladeLength * 1.05, 0, r * 0.65 + bladeLength * 0.9, bladeWidth * 0.3);
            ctx.stroke();

            // Energy core line along blade
            ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(r * 0.7, -bladeWidth * 0.3);
            ctx.lineTo(r * 0.65 + bladeLength * 0.85, -bladeWidth * 0.4);
            ctx.stroke();

            ctx.restore();

            // Simple ready indicator when charging (no heavy effects)
            if (agent.swordCharging) {
              ctx.strokeStyle = localSwordColor;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, r * 1.5, -0.3, 0.3);
              ctx.stroke();
            }
          }

          ctx.restore();
          ctx.shadowBlur = 0;

          // Health bar
          const barW = 30 * s;
          const barH = 4 * s;
          ctx.fillStyle = '#333';
          ctx.fillRect(x - barW / 2, y - r - 12 * s, barW, barH);
          ctx.fillStyle = agent.health > 50 ? '#00ff9d' : '#ff0055';
          ctx.fillRect(x - barW / 2, y - r - 12 * s, barW * (agent.health / agent.maxHealth), barH);
          
          // Armor bar (blue, below health bar)
          if (agent.armor > 0) {
            ctx.fillStyle = '#333';
            ctx.fillRect(x - barW / 2, y - r - 7 * s, barW, barH);
            ctx.fillStyle = '#00aaff';
            ctx.fillRect(x - barW / 2, y - r - 7 * s, barW * (agent.armor / agent.maxArmor), barH);
          }
          
          // Weapon cooldown indicator
          if (agent.weaponCooldown > 0) {
            const cooldownPct = agent.weaponCooldown / ROCKET.fireRate;
            const cooldownY = agent.armor > 0 ? y - r - 2 * s : y - r - 6 * s;
            ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
            ctx.fillRect(x - barW / 2, cooldownY, barW * cooldownPct, 2 * s);
          }
        }

        // Projectiles
        ctx.shadowBlur = 0;

        // Smoke particles (skip in turbo mode)
        if (!turboMode) {
          for (const p of this.world.smokeParticles) {
            const px = p.x * s, py = p.y * s;
            const alpha = (p.life / p.maxLife) * 0.6;
            const size = p.size * s;

            ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
            ctx.beginPath();
            ctx.arc(px, py, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Rockets
        for (const r of this.world.rockets) {
          if (!r.alive) continue;
          const rx = r.x * s, ry = r.y * s;

          if (turboMode) {
            // TURBO: Simple orange rectangle
            ctx.fillStyle = '#ff6600';
            ctx.save();
            ctx.translate(rx, ry);
            ctx.rotate(r.angle);
            ctx.fillRect(-8 * s, -3 * s, 16 * s, 6 * s);
            ctx.restore();
          } else {
            ctx.save();
            ctx.translate(rx, ry);
            ctx.rotate(r.angle);

            // Flame trail (behind rocket)
            const flameGrad = ctx.createLinearGradient(-35 * s, 0, 0, 0);
            flameGrad.addColorStop(0, 'rgba(255, 100, 0, 0)');
            flameGrad.addColorStop(0.3, 'rgba(255, 150, 0, 0.8)');
            flameGrad.addColorStop(0.6, 'rgba(255, 200, 50, 1)');
            flameGrad.addColorStop(1, 'rgba(255, 255, 200, 1)');

            ctx.fillStyle = flameGrad;
            ctx.beginPath();
            ctx.moveTo(-35 * s, 0);
            ctx.lineTo(-8 * s, -6 * s);
            ctx.lineTo(-8 * s, 6 * s);
            ctx.closePath();
            ctx.fill();

            // Rocket body
            ctx.fillStyle = '#444';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(0, 0, 12 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Rocket nose (red tip)
            ctx.fillStyle = '#ff3300';
            ctx.beginPath();
            ctx.moveTo(12 * s, 0);
            ctx.lineTo(6 * s, -4 * s);
            ctx.lineTo(6 * s, 4 * s);
            ctx.closePath();
            ctx.fill();

            // Fins
            ctx.fillStyle = '#ff3300';
            ctx.beginPath();
            ctx.moveTo(-8 * s, -5 * s);
            ctx.lineTo(-12 * s, -10 * s);
            ctx.lineTo(-6 * s, -5 * s);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-8 * s, 5 * s);
            ctx.lineTo(-12 * s, 10 * s);
            ctx.lineTo(-6 * s, 5 * s);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
          }
        }

        // Rifle bullets (tracer style)
        for (const b of this.world.rifleBullets) {
          if (!b.alive) continue;
          const bx = b.x * s, by = b.y * s;

          if (turboMode) {
            // TURBO: Simple yellow line
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bx, by);
            ctx.lineTo(bx - Math.cos(b.angle) * 20 * s, by - Math.sin(b.angle) * 20 * s);
            ctx.stroke();
          } else {
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(b.angle);

            // Tracer trail (glowing line behind bullet)
            const tracerLength = 40 * s;
            const tracerGrad = ctx.createLinearGradient(-tracerLength, 0, 0, 0);
            tracerGrad.addColorStop(0, 'rgba(255, 200, 50, 0)');
            tracerGrad.addColorStop(0.5, 'rgba(255, 220, 100, 0.6)');
            tracerGrad.addColorStop(1, 'rgba(255, 255, 200, 1)');

            ctx.strokeStyle = tracerGrad;
            ctx.lineWidth = 3 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-tracerLength, 0);
            ctx.lineTo(0, 0);
            ctx.stroke();

            // Bright bullet tip
            ctx.fillStyle = '#ffffcc';
            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(0, 0, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
          }
        }

        // Explosions
        ctx.globalCompositeOperation = 'lighter';
        if (!turboMode) {
          for (const e of this.world.explosions) {
            const ex = e.x * s, ey = e.y * s;
            const progress = e.timer / e.maxTime;
            const currentRadius = e.splashRadius * s * (0.3 + progress * 0.7);

            // Outer shockwave ring
            ctx.strokeStyle = `rgba(255, 100, 0, ${1 - progress})`;
            ctx.lineWidth = 8 * (1 - progress);
            ctx.beginPath();
            ctx.arc(ex, ey, currentRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner flash
            const innerGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, currentRadius * 0.8);
            innerGrad.addColorStop(0, `rgba(255, 255, 200, ${0.9 - progress * 0.9})`);
            innerGrad.addColorStop(0.3, `rgba(255, 200, 0, ${0.7 - progress * 0.7})`);
            innerGrad.addColorStop(0.6, `rgba(255, 100, 0, ${0.5 - progress * 0.5})`);
            innerGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = innerGrad;
            ctx.beginPath();
            ctx.arc(ex, ey, currentRadius * 0.8, 0, Math.PI * 2);
            ctx.fill();
          }
        } else {
          // TURBO: Simple orange circles for explosions
          for (const e of this.world.explosions) {
            const ex = e.x * s, ey = e.y * s;
            const progress = e.timer / e.maxTime;
            ctx.fillStyle = `rgba(255, 100, 0, ${0.5 - progress * 0.5})`;
            ctx.beginPath();
            ctx.arc(ex, ey, e.splashRadius * s * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Laser beams
        for (var bi = 0; bi < this.world.laserBeams.length; bi++) {
          var beam = this.world.laserBeams[bi];
          if (!beam || !beam.segments || beam.segments.length === 0) continue;

          var progress = beam.timer / beam.maxTime;
          var alpha = Math.max(0, 1 - progress);
          var isRed = beam.team === 0;

          if (turboMode) {
            // TURBO: Simple thin lines
            ctx.strokeStyle = isRed ? `rgba(255, 50, 100, ${alpha})` : `rgba(50, 150, 255, ${alpha})`;
            ctx.lineWidth = 3 * s;
            ctx.lineCap = 'round';
            for (var si = 0; si < beam.segments.length; si++) {
              var seg = beam.segments[si];
              if (!seg) continue;
              ctx.beginPath();
              ctx.moveTo(seg.startX * s, seg.startY * s);
              ctx.lineTo(seg.endX * s, seg.endY * s);
              ctx.stroke();
            }
          } else {
            var beamWidth = Math.max(2, 20 * alpha);
            var beamColor = isRed ? '255, 50, 100' : '50, 150, 255';

            // Draw each segment as simple lines
            for (var si = 0; si < beam.segments.length; si++) {
              var seg = beam.segments[si];
              if (!seg) continue;

              var sx = seg.startX * s;
              var sy = seg.startY * s;
              var ex = seg.endX * s;
              var ey = seg.endY * s;

              // Outer glow
              ctx.strokeStyle = 'rgba(' + beamColor + ', ' + (alpha * 0.3) + ')';
              ctx.lineWidth = beamWidth * s * 3;
              ctx.lineCap = 'round';
              ctx.beginPath();
              ctx.moveTo(sx, sy);
              ctx.lineTo(ex, ey);
              ctx.stroke();

              // Core beam
              ctx.strokeStyle = 'rgba(255, 255, 255, ' + alpha + ')';
              ctx.lineWidth = beamWidth * s * 0.5;
              ctx.beginPath();
              ctx.moveTo(sx, sy);
              ctx.lineTo(ex, ey);
              ctx.stroke();
            }
          }
        }

        // Sword slashes - blade sweep arc effect
        for (const slash of this.world.swordSlashes) {
          const progress = slash.timer / slash.maxTime;
          const sx = slash.startX * s, sy = slash.startY * s;
          const ex = slash.endX * s, ey = slash.endY * s;

          const alpha = 1 - progress * progress; // Faster initial fade
          const baseColor = slash.team === 0 ? [255, 68, 68] : [68, 136, 255];
          const glowColor = slash.team === 0 ? '#ff4444' : '#4488ff';

          // Direction and perpendicular vectors
          const dx = ex - sx;
          const dy = ey - sy;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;

          // TURBO MODE: Simple line slash
          if (turboMode) {
            const lungeDuration = slash.lungeDuration || (slash.maxTime * 0.8);
            const sweepProgress = Math.min(1, slash.timer / lungeDuration);
            const currentX = sx + dx * sweepProgress;
            const currentY = sy + dy * sweepProgress;
            ctx.strokeStyle = glowColor;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            ctx.globalAlpha = 1;
            continue;
          }

          const dirX = dx / len;
          const dirY = dy / len;
          const nx = -dirY; // perpendicular
          const ny = dirX;

          const bladeWidth = (slash.bladeLength || 30) * s;

          // Animate the sweep - blade position synced with agent lunge
          // Blade reaches end when timer equals lungeDuration
          const lungeDuration = slash.lungeDuration || (slash.maxTime * 0.8);
          const sweepProgress = Math.min(1, slash.timer / lungeDuration);
          const currentX = sx + dx * sweepProgress;
          const currentY = sy + dy * sweepProgress;

          ctx.shadowBlur = 15 * alpha;
          ctx.shadowColor = glowColor;

          // Draw multiple trailing ghost blades for motion blur effect
          const numTrails = 5;
          for (let t = 0; t < numTrails; t++) {
            const trailProgress = Math.max(0, sweepProgress - t * 0.15);
            if (trailProgress <= 0) continue;

            const trailX = sx + dx * trailProgress;
            const trailY = sy + dy * trailProgress;
            const trailAlpha = alpha * (1 - t / numTrails) * 0.6;

            // Draw arc-shaped trail segment
            ctx.fillStyle = `rgba(${baseColor.join(',')}, ${trailAlpha * 0.3})`;
            ctx.beginPath();
            ctx.moveTo(trailX + nx * bladeWidth, trailY + ny * bladeWidth);
            ctx.quadraticCurveTo(
              trailX + dirX * bladeWidth * 0.3 + nx * bladeWidth * 0.5,
              trailY + dirY * bladeWidth * 0.3 + ny * bladeWidth * 0.5,
              trailX - nx * bladeWidth * 0.2, trailY - ny * bladeWidth * 0.2
            );
            ctx.lineTo(trailX - nx * bladeWidth * 0.1, trailY - ny * bladeWidth * 0.1);
            ctx.quadraticCurveTo(
              trailX + dirX * bladeWidth * 0.2,
              trailY + dirY * bladeWidth * 0.2,
              trailX + nx * bladeWidth * 0.9, trailY + ny * bladeWidth * 0.9
            );
            ctx.closePath();
            ctx.fill();
          }

          // Main sweep arc - curved trail from start to current blade position
          if (sweepProgress > 0.05) {
            const gradient = ctx.createLinearGradient(
              sx + nx * bladeWidth, sy + ny * bladeWidth,
              sx - nx * bladeWidth * 0.2, sy - ny * bladeWidth * 0.2
            );
            gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.9})`);
            gradient.addColorStop(0.2, `rgba(${baseColor.join(',')}, ${alpha * 0.8})`);
            gradient.addColorStop(0.6, `rgba(${baseColor.join(',')}, ${alpha * 0.4})`);
            gradient.addColorStop(1, `rgba(${baseColor.join(',')}, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            // Outer edge (blade tip path) - slight curve
            ctx.moveTo(sx + nx * bladeWidth, sy + ny * bladeWidth);
            ctx.quadraticCurveTo(
              (sx + currentX) / 2 + nx * bladeWidth * 1.1,
              (sy + currentY) / 2 + ny * bladeWidth * 1.1,
              currentX + nx * bladeWidth, currentY + ny * bladeWidth
            );
            // Blade tip at current position
            ctx.lineTo(currentX - nx * bladeWidth * 0.15, currentY - ny * bladeWidth * 0.15);
            // Inner edge (near hilt) - curves back
            ctx.quadraticCurveTo(
              (sx + currentX) / 2 - nx * bladeWidth * 0.1,
              (sy + currentY) / 2 - ny * bladeWidth * 0.1,
              sx - nx * bladeWidth * 0.1, sy - ny * bladeWidth * 0.1
            );
            ctx.closePath();
            ctx.fill();
          }

          // Current blade position - sharp leading edge
          if (sweepProgress < 1) {
            ctx.shadowBlur = 20 * alpha;

            // Blade shape at current position
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.95})`;
            ctx.beginPath();
            ctx.moveTo(currentX + nx * bladeWidth, currentY + ny * bladeWidth); // tip
            ctx.lineTo(currentX + dirX * 3 * s, currentY + dirY * 3 * s); // sharp point forward
            ctx.lineTo(currentX - nx * bladeWidth * 0.15, currentY - ny * bladeWidth * 0.15); // back edge
            ctx.closePath();
            ctx.fill();

            // Blade edge glow
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(currentX + nx * bladeWidth, currentY + ny * bladeWidth);
            ctx.lineTo(currentX + dirX * 3 * s, currentY + dirY * 3 * s);
            ctx.stroke();
          }

          // Energy particles along the sweep
          ctx.shadowBlur = 10 * alpha;
          for (let i = 0; i < 4; i++) {
            const particleT = (sweepProgress - i * 0.12) % 1;
            if (particleT < 0 || particleT > sweepProgress) continue;

            const px = sx + dx * particleT + nx * bladeWidth * (0.7 + Math.sin(i * 2) * 0.3);
            const py = sy + dy * particleT + ny * bladeWidth * (0.7 + Math.sin(i * 2) * 0.3);
            const particleAlpha = alpha * (1 - i * 0.2);
            const particleSize = (3 - i * 0.5) * s;

            ctx.fillStyle = `rgba(255, 255, 255, ${particleAlpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.shadowBlur = 0;
        }

        // Dodge trails - motion blur afterimage effect
        for (const trail of this.world.dodgeTrails) {
          const progress = trail.timer / trail.maxTime;
          const alpha = 1 - progress;

          const sx = trail.startX * s, sy = trail.startY * s;
          const ex = trail.endX * s, ey = trail.endY * s;

          // Direction vector
          const dx = ex - sx;
          const dy = ey - sy;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;

          // TURBO MODE: Simple dashed line
          if (turboMode) {
            const isRed = trail.team === 0;
            ctx.strokeStyle = isRed ? '#ff6666' : '#6699ff';
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
            continue;
          }

          const dirX = dx / len;
          const dirY = dy / len;
          const nx = -dirY; // perpendicular
          const ny = dirX;

          // Team colors
          const isRed = trail.team === 0;
          const baseColor = isRed ? [255, 100, 100] : [100, 150, 255];
          const glowColor = isRed ? '#ff6666' : '#6699ff';

          ctx.shadowBlur = 20 * alpha;
          ctx.shadowColor = glowColor;

          // Draw multiple afterimage circles along the path
          const numGhosts = 8;
          for (let i = 0; i < numGhosts; i++) {
            const t = i / (numGhosts - 1);
            // Ghosts fade out from start to end
            const ghostAlpha = alpha * (1 - t * 0.7) * 0.5;
            const ghostX = sx + dx * t;
            const ghostY = sy + dy * t;
            const ghostRadius = (15 - i * 0.8) * s * (1 - progress * 0.3);

            // Ghost circle
            const gradient = ctx.createRadialGradient(
              ghostX, ghostY, 0,
              ghostX, ghostY, ghostRadius
            );
            gradient.addColorStop(0, `rgba(${baseColor.join(',')}, ${ghostAlpha})`);
            gradient.addColorStop(0.5, `rgba(${baseColor.join(',')}, ${ghostAlpha * 0.5})`);
            gradient.addColorStop(1, `rgba(${baseColor.join(',')}, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ghostX, ghostY, ghostRadius, 0, Math.PI * 2);
            ctx.fill();
          }

          // Speed lines along the path
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
          ctx.lineWidth = 2 * (1 - progress);

          const lineSpacing = 20 * s;
          const numLines = Math.floor(len / lineSpacing);
          for (let i = 0; i < numLines; i++) {
            const t = (i + 0.5) / numLines;
            const lineX = sx + dx * t;
            const lineY = sy + dy * t;
            const lineLen = 8 * s * (1 - progress);
            const offset = (Math.sin(i * 1.5) * 8) * s;

            ctx.beginPath();
            ctx.moveTo(lineX + nx * offset, lineY + ny * offset);
            ctx.lineTo(lineX + nx * offset - dirX * lineLen, lineY + ny * offset - dirY * lineLen);
            ctx.stroke();
          }

          ctx.shadowBlur = 0;
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.restore();

        // Agent stats now displayed in sidebar profile card
      }

      // Deprecated: stats now in sidebar
      drawAgentStats(ctx) {
        const agent = this.followAgent;
        if (!agent) return;

        const padding = 12;
        const lineHeight = 18;
        const boxWidth = 180;
        const boxHeight = 130;
        const boxX = 10;
        const boxY = this.canvas.height / this.dpr - boxHeight - 10;

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

        // Border
        ctx.strokeStyle = agent.team === 0 ? '#ff4444' : '#4488ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

        // Text
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px JetBrains Mono, monospace';
        ctx.textAlign = 'left';

        let y = boxY + padding + 12;

        // Name
        ctx.fillStyle = agent.team === 0 ? '#ff6666' : '#6699ff';
        ctx.fillText(agent.name, boxX + padding, y);
        y += lineHeight + 4;

        ctx.font = '12px JetBrains Mono, monospace';
        ctx.fillStyle = '#cccccc';

        // Health
        ctx.fillText(`HP: ${Math.ceil(agent.health)}/${agent.maxHealth}`, boxX + padding, y);
        y += lineHeight;

        // Armor
        ctx.fillText(`Armor: ${Math.ceil(agent.armor)}/${agent.maxArmor}`, boxX + padding, y);
        y += lineHeight;

        // Weapon
        const weaponName = agent.weapon.charAt(0).toUpperCase() + agent.weapon.slice(1);
        ctx.fillText(`Weapon: ${weaponName}`, boxX + padding, y);
        y += lineHeight;

        // Kills this round
        ctx.fillText(`Kills: ${agent.kills}`, boxX + padding, y);
        y += lineHeight;

        // Total kills
        ctx.fillStyle = '#888888';
        ctx.fillText(`Total: ${agent.totalKills} kills, ${agent.totalDeaths} deaths`, boxX + padding, y);
      }

      drawTeleporters(ctx, s) {
        const world = this.world;
        if (!world.teleporters || world.teleporters.length === 0) return;

        const isEnabled = world.teleportersEnabled;
        const isActive = world.teleporterActive;
        const time = Date.now() / 1000; // For animations

        // TURBO MODE: Simple circles for teleporters
        if (turboMode) {
          for (const tele of world.teleporters) {
            const x = tele.x * s;
            const y = tele.y * s;
            const r = tele.radius * s;

            if (!isEnabled) {
              ctx.strokeStyle = '#444';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.stroke();
            } else if (!isActive) {
              ctx.strokeStyle = '#448888';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.stroke();
            } else {
              ctx.strokeStyle = '#00ffff';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = '#00ffff';
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          return;
        }

        for (let i = 0; i < world.teleporters.length; i++) {
          const tele = world.teleporters[i];
          const x = tele.x * s;
          const y = tele.y * s;
          const r = tele.radius * s;

          ctx.save();

          if (!isEnabled) {
            // DISABLED STATE - Dim and gray
            // Outer ring
            ctx.strokeStyle = 'rgba(60, 60, 60, 0.5)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();

            // Inner circle
            ctx.fillStyle = 'rgba(30, 30, 30, 0.4)';
            ctx.beginPath();
            ctx.arc(x, y, r * 0.7, 0, Math.PI * 2);
            ctx.fill();

            // X mark
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - r * 0.4, y - r * 0.4);
            ctx.lineTo(x + r * 0.4, y + r * 0.4);
            ctx.moveTo(x + r * 0.4, y - r * 0.4);
            ctx.lineTo(x - r * 0.4, y + r * 0.4);
            ctx.stroke();

          } else if (!isActive) {
            // INACTIVE STATE - Waiting to activate (cyan/purple neutral)
            const pulse = 0.5 + Math.sin(time * 2) * 0.2;

            // Outer ring - dim cyan
            ctx.strokeStyle = `rgba(100, 200, 220, ${pulse * 0.4})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();

            // Inner dormant circle
            const innerGrad = ctx.createRadialGradient(x, y, 0, x, y, r * 0.8);
            innerGrad.addColorStop(0, `rgba(60, 40, 80, ${pulse * 0.3})`);
            innerGrad.addColorStop(0.7, `rgba(40, 60, 80, ${pulse * 0.2})`);
            innerGrad.addColorStop(1, 'rgba(20, 30, 40, 0.1)');
            ctx.fillStyle = innerGrad;
            ctx.beginPath();
            ctx.arc(x, y, r * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Dormant symbol (circle with dot)
            ctx.strokeStyle = `rgba(150, 200, 220, ${pulse * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, r * 0.3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = `rgba(150, 200, 220, ${pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();

          } else {
            // ACTIVE STATE - Clean glowing portal
            const spinAngle = time * 2;
            const pulse = 0.85 + Math.sin(time * 6) * 0.15;
            const timeRemaining = world.teleporterActiveTimer;
            const urgency = timeRemaining < 10 ? (1 + Math.sin(time * 12) * 0.2) : 1;

            // Strong glow effect
            ctx.shadowBlur = 30 * pulse * urgency;
            ctx.shadowColor = 'rgba(0, 255, 255, 0.9)';

            // Outer ring
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.9 * urgency})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();

            // Inner rotating ring with team accent colors
            ctx.lineWidth = 3;
            const innerR = r * 0.75;
            for (let j = 0; j < 2; j++) {
              const arcStart = spinAngle + j * Math.PI;
              const arcEnd = arcStart + Math.PI * 0.8;
              ctx.strokeStyle = j === 0
                ? `rgba(255, 120, 120, ${0.6 * pulse})` // Red accent
                : `rgba(120, 160, 255, ${0.6 * pulse})`; // Blue accent
              ctx.beginPath();
              ctx.arc(x, y, innerR, arcStart, arcEnd);
              ctx.stroke();
            }

            // Core gradient - deep to bright
            const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, r * 0.65);
            coreGrad.addColorStop(0, `rgba(255, 255, 255, ${0.95 * pulse})`);
            coreGrad.addColorStop(0.2, `rgba(150, 255, 255, ${0.8 * pulse})`);
            coreGrad.addColorStop(0.5, `rgba(0, 200, 255, ${0.6 * pulse})`);
            coreGrad.addColorStop(0.8, `rgba(80, 0, 180, ${0.4 * pulse})`);
            coreGrad.addColorStop(1, 'rgba(20, 0, 60, 0.2)');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(x, y, r * 0.65, 0, Math.PI * 2);
            ctx.fill();

            // Pulsing inner rings
            ctx.strokeStyle = `rgba(200, 255, 255, ${0.4 * pulse})`;
            ctx.lineWidth = 1.5;
            for (let j = 1; j <= 3; j++) {
              const ringPulse = (time * 2 + j * 0.3) % 1;
              const ringR = r * 0.15 + r * 0.45 * ringPulse;
              const ringAlpha = 0.5 * (1 - ringPulse);
              ctx.strokeStyle = `rgba(200, 255, 255, ${ringAlpha * pulse})`;
              ctx.beginPath();
              ctx.arc(x, y, ringR, 0, Math.PI * 2);
              ctx.stroke();
            }

            // Bright center
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Timer when running low
            if (timeRemaining < 10) {
              ctx.fillStyle = `rgba(255, 220, 100, ${urgency * 0.9})`;
              ctx.font = `bold ${14 * s}px monospace`;
              ctx.textAlign = 'center';
              ctx.fillText(Math.ceil(timeRemaining) + 's', x, y + r + 22);
            }
          }

          ctx.restore();
        }

        // Draw warp effects
        for (const effect of world.teleporterWarpEffects) {
          const progress = effect.timer / effect.maxTime;
          const x = effect.x * s;
          const y = effect.y * s;

          ctx.save();

          if (effect.type === 'warp_out') {
            // Quick implosion flash - agent disappearing
            const shrink = 1 - progress;
            const teamColor = effect.team === 0 ? [255, 100, 100] : [100, 150, 255];

            // Bright flash that shrinks to nothing
            ctx.shadowBlur = 20 * shrink;
            ctx.shadowColor = `rgb(${teamColor.join(',')})`;

            // Single shrinking ring
            ctx.globalAlpha = shrink;
            ctx.strokeStyle = `rgb(${teamColor.join(',')})`;
            ctx.lineWidth = 4 * shrink;
            ctx.beginPath();
            ctx.arc(x, y, 30 * s * shrink, 0, Math.PI * 2);
            ctx.stroke();

            // Bright center that implodes
            const impRadius = Math.max(2, 25 * s * shrink);
            const flashGrad = ctx.createRadialGradient(x, y, 0, x, y, impRadius);
            flashGrad.addColorStop(0, `rgba(255, 255, 255, ${shrink})`);
            flashGrad.addColorStop(0.4, `rgba(${teamColor.join(',')}, ${shrink * 0.8})`);
            flashGrad.addColorStop(1, `rgba(${teamColor.join(',')}, 0)`);
            ctx.fillStyle = flashGrad;
            ctx.beginPath();
            ctx.arc(x, y, impRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

          } else if (effect.type === 'warp_in') {
            // Pop-in burst - agent appearing
            const expand = progress;
            const pop = Math.sin(progress * Math.PI); // peaks at middle
            const teamColor = effect.team === 0 ? [255, 100, 100] : [100, 150, 255];

            ctx.shadowBlur = 25 * pop;
            ctx.shadowColor = `rgb(${teamColor.join(',')})`;

            // Expanding ring that fades
            ctx.globalAlpha = 1 - progress;
            ctx.strokeStyle = `rgb(${teamColor.join(',')})`;
            ctx.lineWidth = 3 * (1 - progress);
            ctx.beginPath();
            ctx.arc(x, y, (15 + expand * 35) * s, 0, Math.PI * 2);
            ctx.stroke();

            // Bright flash at arrival
            const warpRadius = Math.max(2, 35 * s * pop);
            const flashGrad = ctx.createRadialGradient(x, y, 0, x, y, warpRadius);
            flashGrad.addColorStop(0, `rgba(255, 255, 255, ${pop * 0.9})`);
            flashGrad.addColorStop(0.5, `rgba(${teamColor.join(',')}, ${pop * 0.6})`);
            flashGrad.addColorStop(1, `rgba(${teamColor.join(',')}, 0)`);
            ctx.fillStyle = flashGrad;
            ctx.beginPath();
            ctx.arc(x, y, warpRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

          } else if (effect.type === 'activate') {
            // Portal activation burst
            const expand = progress;
            ctx.globalAlpha = 1 - progress;
            ctx.strokeStyle = 'rgba(0, 255, 255, 1)';
            ctx.lineWidth = 4 * (1 - progress);

            // Big expanding ring
            ctx.beginPath();
            ctx.arc(x, y, (50 + expand * 100) * s, 0, Math.PI * 2);
            ctx.stroke();

            // Inner flash
            const flashGrad = ctx.createRadialGradient(x, y, 0, x, y, 60 * s);
            flashGrad.addColorStop(0, `rgba(255, 255, 255, ${0.8 * (1 - progress)})`);
            flashGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
            ctx.fillStyle = flashGrad;
            ctx.beginPath();
            ctx.arc(x, y, 60 * s, 0, Math.PI * 2);
            ctx.fill();

          } else if (effect.type === 'deactivate') {
            // Portal deactivation fade
            ctx.globalAlpha = 1 - progress;
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.8)';
            ctx.lineWidth = 2;

            // Collapsing ring
            const collapse = 1 - progress;
            ctx.beginPath();
            ctx.arc(x, y, 40 * s * collapse, 0, Math.PI * 2);
            ctx.stroke();

          } else if (effect.type === 'laser_explosion') {
            // Laser 4th hit explosion
            const radius = (effect.radius || 80) * s;
            const teamColor = effect.team === 0 ? [255, 0, 100] : [0, 150, 255];

            // Expanding shockwave
            const expandProgress = Math.min(1, progress * 2);
            const shockwaveRadius = Math.max(1, radius * expandProgress);
            const shockwaveAlpha = (1 - progress) * 0.8;

            ctx.strokeStyle = `rgba(${teamColor.join(',')}, ${shockwaveAlpha})`;
            ctx.lineWidth = Math.max(1, (8 - progress * 6) * s);
            ctx.shadowBlur = 20;
            ctx.shadowColor = `rgb(${teamColor.join(',')})`;
            ctx.beginPath();
            ctx.arc(x, y, shockwaveRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner flash
            if (progress < 0.25) {
              const flashAlpha = (1 - progress / 0.25);
              const innerRadius = Math.max(2, radius * 0.6 * (1 - progress * 3));

              const grad = ctx.createRadialGradient(x, y, 0, x, y, innerRadius);
              grad.addColorStop(0, `rgba(255, 255, 255, ${flashAlpha})`);
              grad.addColorStop(0.4, `rgba(${teamColor.join(',')}, ${flashAlpha * 0.8})`);
              grad.addColorStop(1, `rgba(${teamColor.join(',')}, 0)`);

              ctx.fillStyle = grad;
              ctx.beginPath();
              ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.shadowBlur = 0;
          }

          ctx.restore();
        }
      }
    }

    // --------------------
    // Init
    // --------------------
    const canvas = document.getElementById('canvas');
    const world = new World(3600, 2400); // 50% wider arena
    const renderer = new Renderer(canvas, world);

    let population = 100;
    let simSpeed = 1;

    world.spawnAgents(population);

    const ui = {
      gen: document.getElementById('generation'),
      genRow: document.getElementById('generation-row'),
      alive: document.getElementById('alive'),
      time: document.getElementById('time-left'),
      leaderboard: document.getElementById('leaderboard'),

      zoom: document.getElementById('zoom'),
      speed: document.getElementById('speed'),
      population: document.getElementById('population'),
      roundTime: document.getElementById('round-time'),
      killLimit: document.getElementById('kill-limit'),

      zoomValue: document.getElementById('zoom-value'),
      speedValue: document.getElementById('speed-value'),
      populationValue: document.getElementById('population-value'),
      roundTimeValue: document.getElementById('round-time-value'),
      killLimitValue: document.getElementById('kill-limit-value'),
      killLimitDisplay: document.getElementById('kill-limit-display'),

      // Team score elements (new layout)
      redScore: document.getElementById('red-score'),
      blueScore: document.getElementById('blue-score'),
      redWins: document.getElementById('red-wins'),
      blueWins: document.getElementById('blue-wins'),
      redTopLives: document.querySelector('#red-top-lives .top-lives-list'),
      blueTopLives: document.querySelector('#blue-top-lives .top-lives-list'),
      redAvgLife: document.getElementById('red-avg-life'),
      blueAvgLife: document.getElementById('blue-avg-life'),

      // Modifiers (now in dropdown menu)
      toggleHealth: document.getElementById('mod-health'),
      toggleArmor: document.getElementById('mod-armor'),
      toggleLaser: document.getElementById('mod-laser'),
      toggleSword: document.getElementById('mod-sword'),
      toggleDodge: document.getElementById('mod-dodge'),
      toggleTeleporter: document.getElementById('mod-teleporter'),
      toggleFf: document.getElementById('mod-ff'),
      toggleRicochet: document.getElementById('mod-ricochet'),
      toggleNoRespawn: document.getElementById('mod-no-respawn'),
      noRespawnRow: document.getElementById('mod-no-respawn-row'),
      toggle5xHp: document.getElementById('mod-5x-hp'),
      weaponRocket: document.getElementById('mod-weapon-rocket'),
      weaponRifle: document.getElementById('mod-weapon-rifle'),
      // Modifiers dropdown
      modifiersBtn: document.getElementById('modifiers-btn'),
      modifiersMenu: document.getElementById('modifiers-menu'),
      // Mode selector
      modeRounds: document.getElementById('mode-rounds'),
      modePersistent: document.getElementById('mode-persistent'),
      modeSub: document.getElementById('mode-sub'),

      // Pre-simulation screen
      preSimScreen: document.getElementById('pre-sim-screen'),
      preSimTitle: document.getElementById('pre-sim-title'),
      preSimSubtitle: document.getElementById('pre-sim-subtitle'),
      preSimDescription: document.getElementById('pre-sim-description'),
      preSimFeatures: document.getElementById('pre-sim-features'),
      startSimBtn: document.getElementById('start-sim-btn'),

      // Stats panel (now accessed via right sidebar toggle)
      statsPanel: document.getElementById('stats-panel'),
      statsClose: document.getElementById('stats-close'),
      statsMode: document.getElementById('stats-mode'),
      statsTotalLives: document.getElementById('stats-total-lives'),
      statsRocketKills: document.getElementById('stats-rocket-kills'),
      statsLaserKills: document.getElementById('stats-laser-kills'),
      statsSwordKills: document.getElementById('stats-sword-kills'),

      // Respawn time slider
      respawnTime: document.getElementById('respawn-time'),
      respawnTimeValue: document.getElementById('respawn-time-value'),

      pauseBtn: document.getElementById('pause-btn'),
      restartBtn: document.getElementById('restart-btn'),
      saveBtn: document.getElementById('save-btn'),
      loadBtn: document.getElementById('load-btn'),
      copyBtn: document.getElementById('copy-btn'),
      demoBtn: document.getElementById('demo-btn'),
      loadFile: document.getElementById('load-file'),
      headlessBtn: document.getElementById('headless-btn'),
      turboBtn: document.getElementById('turbo-btn'),
      headlessOverlay: document.getElementById('headless-overlay'),

      // Global weapon stats
      globalRocketKills: document.getElementById('global-rocket-kills'),
      globalLaserKills: document.getElementById('global-laser-kills'),
      globalSwordKills: document.getElementById('global-sword-kills'),

      // Agent profile card
      agentProfile: document.getElementById('agent-profile'),
      profileName: document.getElementById('profile-name'),
      profileTeam: document.getElementById('profile-team'),
      profileHealthBar: document.getElementById('profile-health-bar'),
      profileHealthVal: document.getElementById('profile-health-val'),
      profileArmorBar: document.getElementById('profile-armor-bar'),
      profileArmorVal: document.getElementById('profile-armor-val'),
      profileWeapon: document.getElementById('profile-weapon'),
      profileKd: document.getElementById('profile-kd'),
      neuralTurn: document.getElementById('neural-turn'),
      neuralSpeed: document.getElementById('neural-speed'),
      neuralStrafe: document.getElementById('neural-strafe'),
      neuralShoot: document.getElementById('neural-shoot'),
      neuralDash: document.getElementById('neural-dash'),
      awarenessEnemy: document.getElementById('awareness-enemy'),
      awarenessAlly: document.getElementById('awareness-ally'),

      // Control bar
      ctrlSave: document.getElementById('ctrl-save'),
      ctrlLoad: document.getElementById('ctrl-load'),
      ctrlReset: document.getElementById('ctrl-reset'),
      ctrlPlay: document.getElementById('ctrl-play'),
      ctrlHeadless: document.getElementById('ctrl-headless'),
      ctrlPerformance: document.getElementById('ctrl-performance'),

      // Stats panel elements
      statsUps: document.getElementById('stats-ups'),
      statsLeaderboard: document.getElementById('stats-leaderboard'),
      statsCombatLog: document.getElementById('stats-combat-log'),
      statsTotalLivesRow: document.getElementById('stats-total-lives-row'),

      // Sidebar toggles
      leftSidebar: document.getElementById('left-sidebar'),
      toggleLeftSidebar: document.getElementById('toggle-left-sidebar'),
      toggleRightSidebar: document.getElementById('toggle-right-sidebar'),
    };

    // Sidebar toggle handlers
    function openLeftSidebar() {
      ui.leftSidebar.classList.add('open');
      ui.toggleLeftSidebar.classList.add('open');
    }
    function closeLeftSidebar() {
      ui.leftSidebar.classList.remove('open');
      ui.toggleLeftSidebar.classList.remove('open');
    }

    // Right toggle now opens stats-panel
    function openStatsPanel() {
      ui.statsPanel.classList.add('open');
      ui.toggleRightSidebar.classList.add('open');
    }
    function closeStatsPanel() {
      ui.statsPanel.classList.remove('open');
      ui.toggleRightSidebar.classList.remove('open');
    }

    ui.toggleLeftSidebar.addEventListener('click', () => {
      if (ui.leftSidebar.classList.contains('open')) {
        closeLeftSidebar();
      } else {
        openLeftSidebar();
      }
    });
    ui.toggleRightSidebar.addEventListener('click', () => {
      if (ui.statsPanel.classList.contains('open')) {
        closeStatsPanel();
      } else {
        openStatsPanel();
      }
    });

    // Close buttons
    document.getElementById('close-left-sidebar').addEventListener('click', closeLeftSidebar);
    ui.statsClose.addEventListener('click', closeStatsPanel);

    // Click outside to close sidebars and modifiers dropdown
    document.addEventListener('click', (e) => {
      // Close left sidebar if clicking outside
      if (ui.leftSidebar.classList.contains('open')) {
        const clickedInSidebar = ui.leftSidebar.contains(e.target);
        const clickedOnToggle = ui.toggleLeftSidebar.contains(e.target);
        if (!clickedInSidebar && !clickedOnToggle) {
          closeLeftSidebar();
        }
      }
      // Close stats panel if clicking outside
      if (ui.statsPanel.classList.contains('open')) {
        const clickedInPanel = ui.statsPanel.contains(e.target);
        const clickedOnToggle = ui.toggleRightSidebar.contains(e.target);
        if (!clickedInPanel && !clickedOnToggle) {
          closeStatsPanel();
        }
      }
      // Close modifiers dropdown if clicking outside
      if (ui.modifiersMenu.classList.contains('open')) {
        const clickedInDropdown = ui.modifiersMenu.contains(e.target);
        const clickedOnBtn = ui.modifiersBtn.contains(e.target);
        if (!clickedInDropdown && !clickedOnBtn) {
          ui.modifiersMenu.classList.remove('open');
          ui.modifiersBtn.classList.remove('active');
        }
      }
    });

    // Modifiers dropdown toggle
    ui.modifiersBtn.addEventListener('click', () => {
      ui.modifiersMenu.classList.toggle('open');
      ui.modifiersBtn.classList.toggle('active');
    });

    // Headless mode
    let headlessMode = true;
    ui.headlessOverlay.classList.add('visible');

    ui.headlessBtn.addEventListener('click', () => {
      headlessMode = !headlessMode;
      ui.headlessBtn.textContent = headlessMode ? 'üñ•Ô∏è HEADLESS MODE (ON)' : 'üñ•Ô∏è HEADLESS MODE (OFF)';
      ui.headlessBtn.style.background = headlessMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(100, 100, 100, 0.1)';
      ui.headlessBtn.style.borderColor = headlessMode ? '#0f0' : '#888';
      ui.headlessBtn.style.color = headlessMode ? '#0f0' : '#888';
      ui.headlessOverlay.classList.toggle('visible', headlessMode);
      ui.ctrlHeadless.classList.toggle('active', headlessMode);
    });

    // Turbo mode - ultra performance rendering
    ui.turboBtn.addEventListener('click', () => {
      turboMode = !turboMode;
      ui.turboBtn.textContent = turboMode ? '‚ö° TURBO MODE (ON)' : '‚ö° TURBO MODE (OFF)';
      ui.turboBtn.style.background = turboMode ? 'rgba(255, 100, 0, 0.5)' : 'rgba(255, 100, 0, 0.2)';
      ui.turboBtn.style.borderColor = turboMode ? '#ff6400' : '#ff6400';
      ui.turboBtn.style.color = turboMode ? '#fff' : '#ff6400';
      world.addEvent(turboMode ? '‚ö° TURBO MODE ON - Max Performance!' : '‚ö° TURBO MODE OFF', 'kill');
      ui.ctrlPerformance.classList.toggle('active', turboMode);
    });

    // Debug buttons - give all agents a weapon (persists after death)
    const debugSwordBtn = document.getElementById('debug-sword-btn');
    const debugLaserBtn = document.getElementById('debug-laser-btn');

    function updateDebugButtonStyles() {
      // Sword button
      if (forceWeapon === 'sword') {
        debugSwordBtn.style.background = 'rgba(255, 0, 255, 0.5)';
        debugSwordBtn.style.color = '#fff';
        debugSwordBtn.textContent = 'üó°Ô∏è SWORD (ON)';
      } else {
        debugSwordBtn.style.background = 'rgba(255, 0, 255, 0.1)';
        debugSwordBtn.style.color = '#ff00ff';
        debugSwordBtn.textContent = 'üó°Ô∏è ALL SWORD';
      }
      // Laser button
      if (forceWeapon === 'laser') {
        debugLaserBtn.style.background = 'rgba(0, 200, 255, 0.5)';
        debugLaserBtn.style.color = '#fff';
        debugLaserBtn.textContent = '‚ö° LASER (ON)';
      } else {
        debugLaserBtn.style.background = 'rgba(0, 200, 255, 0.1)';
        debugLaserBtn.style.color = '#00aaff';
        debugLaserBtn.textContent = '‚ö° ALL LASER';
      }
    }

    debugSwordBtn.addEventListener('click', () => {
      if (forceWeapon === 'sword') {
        // Toggle off - reset all to rocket
        forceWeapon = null;
        for (const agent of world.agents) {
          agent.weapon = 'rocket';
          agent.hasPickedUpWeapon = false;
        }
        world.addEvent('üó°Ô∏è Sword mode OFF - weapons reset', 'sword');
      } else {
        forceWeapon = 'sword';
        for (const agent of world.agents) {
          agent.weapon = 'sword';
          agent.hasPickedUpWeapon = true;
        }
        world.addEvent('üó°Ô∏è Sword mode ON - persists after death!', 'sword');
      }
      updateDebugButtonStyles();
    });

    debugLaserBtn.addEventListener('click', () => {
      if (forceWeapon === 'laser') {
        // Toggle off - reset all to rocket
        forceWeapon = null;
        for (const agent of world.agents) {
          agent.weapon = 'rocket';
          agent.hasPickedUpWeapon = false;
        }
        world.addEvent('‚ö° Laser mode OFF - weapons reset', 'laser');
      } else {
        forceWeapon = 'laser';
        for (const agent of world.agents) {
          agent.weapon = 'laser';
          agent.hasPickedUpWeapon = true;
        }
        world.addEvent('‚ö° Laser mode ON - persists after death!', 'laser');
      }
      updateDebugButtonStyles();
    });

    // Toggle handlers - connect to world
    ui.toggleFf.addEventListener('click', () => {
      if (ui.toggleFf.classList.contains('disabled')) return;
      ui.toggleFf.classList.toggle('active');
      world.friendlyFire = ui.toggleFf.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFire) {
        ui.toggleRicochet.classList.add('disabled');
        ui.toggleRicochet.classList.remove('active');
        world.friendlyFireRicochet = false;
      } else {
        ui.toggleRicochet.classList.remove('disabled');
      }
    });

    ui.toggleRicochet.addEventListener('click', () => {
      if (ui.toggleRicochet.classList.contains('disabled')) return;
      ui.toggleRicochet.classList.toggle('active');
      world.friendlyFireRicochet = ui.toggleRicochet.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFireRicochet) {
        ui.toggleFf.classList.add('disabled');
        ui.toggleFf.classList.remove('active');
        world.friendlyFire = false;
      } else {
        ui.toggleFf.classList.remove('disabled');
      }
    });

    // Respawn time slider
    ui.respawnTime.addEventListener('input', (e) => {
      const seconds = parseInt(e.target.value, 10);
      world.respawnTime = seconds;
      ui.respawnTimeValue.textContent = seconds + 's';
    });

    // Health/Armor toggle handlers
    ui.toggleHealth.addEventListener('click', () => {
      ui.toggleHealth.classList.toggle('active');
      world.healthSpawnsEnabled = ui.toggleHealth.classList.contains('active');
    });

    ui.toggleArmor.addEventListener('click', () => {
      ui.toggleArmor.classList.toggle('active');
      world.armorSpawnsEnabled = ui.toggleArmor.classList.contains('active');
    });

    ui.toggleLaser.addEventListener('click', () => {
      ui.toggleLaser.classList.toggle('active');
      world.laserSpawnsEnabled = ui.toggleLaser.classList.contains('active');
    });

    ui.toggleSword.addEventListener('click', () => {
      ui.toggleSword.classList.toggle('active');
      world.swordSpawnsEnabled = ui.toggleSword.classList.contains('active');
    });

    ui.toggleDodge.addEventListener('click', () => {
      ui.toggleDodge.classList.toggle('active');
      world.dodgingEnabled = ui.toggleDodge.classList.contains('active');
    });

    ui.toggleTeleporter.addEventListener('click', () => {
      ui.toggleTeleporter.classList.toggle('active');
      world.teleportersEnabled = ui.toggleTeleporter.classList.contains('active');
    });

    // No Respawn toggle (rounds mode only)
    ui.toggleNoRespawn.addEventListener('click', () => {
      if (ui.toggleNoRespawn.classList.contains('disabled')) return;
      ui.toggleNoRespawn.classList.toggle('active');
      noRespawnMode = ui.toggleNoRespawn.classList.contains('active');
      // Gray out kill limit when no respawn is active
      ui.killLimit.disabled = noRespawnMode;
      ui.killLimit.parentElement.style.opacity = noRespawnMode ? '0.4' : '1';
    });

    // 5x HP toggle
    ui.toggle5xHp.addEventListener('click', () => {
      ui.toggle5xHp.classList.toggle('active');
      fiveXHpMode = ui.toggle5xHp.classList.contains('active');
      // Update HP for all agents
      const newMaxHealth = fiveXHpMode ? 500 : 100;
      for (const agent of world.agents) {
        agent.maxHealth = newMaxHealth;
        agent.health = Math.min(agent.health, newMaxHealth);
      }
    });

    // Base weapon selector
    ui.weaponRocket.addEventListener('click', () => {
      baseWeapon = 'rocket';
      ui.weaponRocket.classList.add('active');
      ui.weaponRifle.classList.remove('active');
    });

    ui.weaponRifle.addEventListener('click', () => {
      baseWeapon = 'rifle';
      ui.weaponRifle.classList.add('active');
      ui.weaponRocket.classList.remove('active');
    });

    // Mode info content
    const modeInfo = {
      rounds: {
        title: 'ROUNDS MODE',
        subtitle: 'Generation-based Evolution',
        description: 'Teams battle in timed rounds. After each round, the losing team evolves by learning from the winners. Watch neural networks improve over generations.',
        features: [
          { icon: '‚è±Ô∏è', text: 'Timed rounds with kill limit' },
          { icon: 'üß¨', text: 'Losers evolve after each round' },
          { icon: 'üèÜ', text: 'Track wins across generations' }
        ]
      },
      persistent: {
        title: 'PERSISTENT MODE',
        subtitle: 'Continuous Per-Life Evolution',
        description: 'No rounds - evolution happens continuously. When an agent dies, it immediately respawns with an evolved brain based on the Hall of Fame. Best performers are remembered.',
        features: [
          { icon: '‚ôæÔ∏è', text: 'Continuous gameplay - no rounds' },
          { icon: 'üíÄ', text: 'Evolve immediately on death' },
          { icon: 'üèÖ', text: 'Hall of Fame tracks best lives' }
        ]
      }
    };

    // Update pre-sim screen content
    function updatePreSimScreen() {
      const mode = persistentMode ? modeInfo.persistent : modeInfo.rounds;
      ui.preSimTitle.textContent = mode.title;
      ui.preSimSubtitle.textContent = mode.subtitle;
      ui.preSimDescription.textContent = mode.description;
      ui.preSimFeatures.innerHTML = mode.features.map(f =>
        '<div class="feature"><span class="icon">' + f.icon + '</span> ' + f.text + '</div>'
      ).join('');
    }

    // Show pre-sim screen
    function showPreSimScreen() {
      world.paused = true;
      updatePreSimScreen();
      ui.preSimScreen.classList.remove('hidden');
    }

    // Hide pre-sim screen and start
    function hidePreSimScreen() {
      ui.preSimScreen.classList.add('hidden');
      world.paused = false;
    }

    // Switch mode function
    function switchMode(toPersistent) {
      if (persistentMode === toPersistent) return;

      persistentMode = toPersistent;

      // Toggle body class for CSS
      document.body.classList.toggle('persistent-mode', persistentMode);

      // Update button states
      ui.modeRounds.classList.toggle('active', !persistentMode);
      ui.modePersistent.classList.toggle('active', persistentMode);

      // Update header display
      ui.modeSub.textContent = persistentMode ? 'elapsed' : 'first to';
      ui.killLimitDisplay.textContent = persistentMode ? formatTime(world.totalTime) : world.killLimit;

      // Full reset when switching modes - they are separate
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      world.teamWins = [0, 0];
      forceWeapon = null;
      updateDebugButtonStyles();
      clearHallOfFame();
      world.spawnAgents(population);

      // Hide generation row in persistent mode (not relevant)
      ui.genRow.style.display = persistentMode ? 'none' : 'flex';

      // Disable round-based sliders in persistent mode (not population)
      ui.roundTime.disabled = persistentMode;
      ui.killLimit.disabled = persistentMode || noRespawnMode;
      ui.roundTime.parentElement.style.opacity = persistentMode ? '0.4' : '1';
      ui.killLimit.parentElement.style.opacity = (persistentMode || noRespawnMode) ? '0.4' : '1';

      // Disable no respawn toggle in persistent mode (only works in rounds mode)
      if (persistentMode) {
        ui.toggleNoRespawn.classList.remove('active');
        ui.toggleNoRespawn.classList.add('disabled');
        ui.noRespawnRow.style.opacity = '0.4';
        noRespawnMode = false;
      } else {
        ui.toggleNoRespawn.classList.remove('disabled');
        ui.noRespawnRow.style.opacity = '1';
      }

      if (persistentMode) {
        // Initialize life stats for all agents
        for (const agent of world.agents) {
          agent.lifeStartTime = world.totalTime;
          agent.lifeKills = 0;
          agent.lifeDamageDealt = 0;
          agent.lifeMisses = 0;
        }
      }

      // Show pre-sim screen
      showPreSimScreen();
    }

    // Mode selector button handlers
    ui.modeRounds.addEventListener('click', () => switchMode(false));
    ui.modePersistent.addEventListener('click', () => switchMode(true));

    // Start simulation button
    ui.startSimBtn.addEventListener('click', hidePreSimScreen);

    // Show pre-sim screen on initial load
    showPreSimScreen();

    // Control bar event handlers
    function updatePlayButton() {
      ui.ctrlPlay.classList.toggle('paused', world.paused);
    }

    ui.ctrlPlay.addEventListener('click', () => {
      world.paused = !world.paused;
      updatePlayButton();
      ui.pauseBtn.textContent = world.paused ? 'RESUME' : 'PAUSE';
    });

    ui.ctrlReset.addEventListener('click', () => {
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      forceWeapon = null;
      updateDebugButtonStyles();
      world.spawnAgents(population);
    });

    ui.ctrlSave.addEventListener('click', () => {
      const checkpoint = {
        version: '2.8',
        timestamp: Date.now(),
        generation: world.generation,
        teamWins: world.teamWins,
        teamBrains: world.teamBrains.map(b => b ? {
          weightsIH: b.weightsIH.map(row => Array.from(row)),
          weightsHO: b.weightsHO.map(row => Array.from(row)),
          biasH: Array.from(b.biasH),
          biasO: Array.from(b.biasO),
          inputSize: b.inputSize,
          hiddenSize: b.hiddenSize,
          outputSize: b.outputSize
        } : null)
      };
      localStorage.setItem('quake-checkpoint', JSON.stringify(checkpoint));
      world.addEvent('üíæ Checkpoint saved! Gen ' + world.generation, 'kill');
      ui.ctrlSave.classList.add('active');
      setTimeout(() => ui.ctrlSave.classList.remove('active'), 1000);
    });

    ui.ctrlLoad.addEventListener('click', () => {
      try {
        const data = localStorage.getItem('quake-checkpoint');
        if (!data) {
          world.addEvent('‚ùå No checkpoint saved!', 'kill');
          return;
        }

        const checkpoint = JSON.parse(data);
        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];

        world.teamBrains = checkpoint.teamBrains.map(data => {
          if (!data) return null;
          const nn = new NeuralNetwork(data.inputSize, data.hiddenSize, data.outputSize);
          nn.weightsIH = data.weightsIH.map(row => Float64Array.from(row));
          nn.weightsHO = data.weightsHO.map(row => Float64Array.from(row));
          nn.biasH = Float64Array.from(data.biasH);
          nn.biasO = Float64Array.from(data.biasO);
          return nn;
        });

        world.spawnAgents(population);
        world.addEvent('üìÇ Loaded! Gen ' + world.generation, 'kill');
        ui.ctrlLoad.classList.add('active');
        setTimeout(() => ui.ctrlLoad.classList.remove('active'), 1000);
      } catch (err) {
        world.addEvent('‚ùå Failed to load checkpoint', 'kill');
      }
    });

    function updateHeadlessButton() {
      ui.ctrlHeadless.classList.toggle('active', headlessMode);
    }

    ui.ctrlHeadless.addEventListener('click', () => {
      headlessMode = !headlessMode;
      ui.headlessBtn.textContent = headlessMode ? 'üñ•Ô∏è HEADLESS MODE (ON)' : 'üñ•Ô∏è HEADLESS MODE (OFF)';
      ui.headlessBtn.style.background = headlessMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(100, 100, 100, 0.1)';
      ui.headlessBtn.style.borderColor = headlessMode ? '#0f0' : '#888';
      ui.headlessBtn.style.color = headlessMode ? '#0f0' : '#888';
      ui.headlessOverlay.classList.toggle('visible', headlessMode);
      updateHeadlessButton();
    });

    function updatePerformanceButton() {
      ui.ctrlPerformance.classList.toggle('active', turboMode);
    }

    ui.ctrlPerformance.addEventListener('click', () => {
      turboMode = !turboMode;
      ui.turboBtn.textContent = turboMode ? '‚ö° TURBO MODE (ON)' : '‚ö° TURBO MODE (OFF)';
      ui.turboBtn.style.background = turboMode ? 'rgba(255, 100, 0, 0.5)' : 'rgba(255, 100, 0, 0.2)';
      ui.turboBtn.style.borderColor = turboMode ? '#ff6400' : '#ff6400';
      ui.turboBtn.style.color = turboMode ? '#fff' : '#ff6400';
      world.addEvent(turboMode ? '‚ö° PERFORMANCE MODE ON' : '‚ö° PERFORMANCE MODE OFF', 'kill');
      updatePerformanceButton();
    });

    // Initialize control bar button states
    updatePlayButton();
    updateHeadlessButton();
    updatePerformanceButton();

    // Sliders
    ui.zoom.addEventListener('input', (e) => {
      renderer.zoom = parseInt(e.target.value, 10) / 100;
      renderer.clampCamera();
      ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    });

    ui.speed.addEventListener('input', (e) => {
      simSpeed = parseInt(e.target.value, 10);
      ui.speedValue.textContent = simSpeed + 'x';
    });

    ui.population.addEventListener('input', (e) => {
      population = parseInt(e.target.value, 10);
      ui.populationValue.textContent = String(population);
      world.spawnAgents(population);
    });

    ui.roundTime.addEventListener('input', (e) => {
      const minutes = parseInt(e.target.value, 10);
      world.setRoundTimeSeconds(minutes * 60);
      ui.roundTimeValue.textContent = String(minutes);
    });
    
    ui.killLimit.addEventListener('input', (e) => {
      world.killLimit = parseInt(e.target.value, 10);
      ui.killLimitValue.textContent = String(world.killLimit);
      ui.killLimitDisplay.textContent = String(world.killLimit);
    });

    // Pause/Reset
    ui.pauseBtn.addEventListener('click', (e) => {
      world.paused = !world.paused;
      e.target.textContent = world.paused ? 'RESUME' : 'PAUSE';
      updatePlayButton();
    });

    ui.restartBtn.addEventListener('click', () => {
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      forceWeapon = null; // Reset forced weapon mode
      updateDebugButtonStyles();
      world.spawnAgents(population);
    });

    // Save checkpoint to localStorage
    ui.saveBtn.addEventListener('click', () => {
      const checkpoint = {
        version: '2.8',
        timestamp: Date.now(),
        generation: world.generation,
        teamWins: world.teamWins,
        teamBrains: world.teamBrains.map(b => b ? {
          weightsIH: b.weightsIH.map(row => Array.from(row)),
          weightsHO: b.weightsHO.map(row => Array.from(row)),
          biasH: Array.from(b.biasH),
          biasO: Array.from(b.biasO),
          inputSize: b.inputSize,
          hiddenSize: b.hiddenSize,
          outputSize: b.outputSize
        } : null)
      };
      
      localStorage.setItem('quake-checkpoint', JSON.stringify(checkpoint));
      world.addEvent('üíæ Checkpoint saved! Gen ' + world.generation, 'kill');
      ui.saveBtn.textContent = 'üíæ SAVED!';
      setTimeout(() => ui.saveBtn.textContent = 'üíæ SAVE', 1000);
    });

    // Copy checkpoint to clipboard (for sharing)
    ui.copyBtn.addEventListener('click', async () => {
      const data = localStorage.getItem('quake-checkpoint');
      if (!data) {
        alert('No checkpoint saved! Click SAVE first.');
        return;
      }

      try {
        await navigator.clipboard.writeText(data);
        world.addEvent('üìã Checkpoint copied to clipboard!', 'kill');
        ui.copyBtn.textContent = 'üìã COPIED!';
        setTimeout(() => ui.copyBtn.textContent = 'üìã COPY', 1000);
      } catch (err) {
        // Fallback for iPad/iOS
        const textarea = document.createElement('textarea');
        textarea.value = data;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '50%';
        textarea.style.transform = 'translate(-50%, -50%)';
        textarea.style.width = '80%';
        textarea.style.height = '200px';
        textarea.style.zIndex = '9999';
        textarea.style.background = '#000';
        textarea.style.color = '#0f0';
        textarea.style.border = '2px solid #0f0';
        textarea.style.padding = '10px';
        textarea.style.fontSize = '12px';
        document.body.appendChild(textarea);
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        alert('Select all text (Cmd+A) and copy (Cmd+C), then tap outside to close.');
        textarea.addEventListener('blur', () => textarea.remove());
      }
    });

    // Load checkpoint from localStorage
    ui.loadBtn.addEventListener('click', () => {
      try {
        const data = localStorage.getItem('quake-checkpoint');
        if (!data) {
          alert('No checkpoint found!');
          return;
        }
        
        const checkpoint = JSON.parse(data);
        
        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];
        
        // Restore brains
        world.teamBrains = checkpoint.teamBrains.map(b => {
          if (!b) return null;
          const brain = new NeuralNetwork(b.inputSize, b.hiddenSize, b.outputSize);
          brain.weightsIH = b.weightsIH.map(row => [...row]);
          brain.weightsHO = b.weightsHO.map(row => [...row]);
          brain.biasH = [...b.biasH];
          brain.biasO = [...b.biasO];
          return brain;
        });
        
        // Respawn with loaded brains
        world.spawnAgents(population);
        
        const savedTime = new Date(checkpoint.timestamp).toLocaleTimeString();
        world.addEvent('üìÇ Loaded Gen ' + world.generation + ' (saved ' + savedTime + ')', 'kill');
        ui.loadBtn.textContent = 'üìÇ LOADED!';
        setTimeout(() => ui.loadBtn.textContent = 'üìÇ LOAD', 1000);
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    });

    // Load demo checkpoint (pre-trained AI)
    ui.demoBtn.addEventListener('click', () => {
      if (!DEMO_CHECKPOINT) {
        alert('No demo available yet! Train an AI, save it, then embed it in the code.');
        return;
      }

      try {
        const checkpoint = typeof DEMO_CHECKPOINT === 'string'
          ? JSON.parse(DEMO_CHECKPOINT)
          : DEMO_CHECKPOINT;

        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];

        // Restore brains
        world.teamBrains = checkpoint.teamBrains.map(b => {
          if (!b) return null;
          const brain = new NeuralNetwork(b.inputSize, b.hiddenSize, b.outputSize);
          brain.weightsIH = b.weightsIH.map(row => [...row]);
          brain.weightsHO = b.weightsHO.map(row => [...row]);
          brain.biasH = [...b.biasH];
          brain.biasO = [...b.biasO];
          return brain;
        });

        // Respawn with demo brains
        world.spawnAgents(population);

        world.addEvent('üéÆ DEMO LOADED! Gen ' + world.generation, 'kill');
        ui.demoBtn.textContent = 'üéÆ LOADED!';
        setTimeout(() => ui.demoBtn.textContent = 'üéÆ DEMO', 1000);
      } catch (err) {
        alert('Failed to load demo: ' + err.message);
      }
    });

    // Hotkeys: Space pause, R reset, F fullscreen
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        world.paused = !world.paused;
        ui.pauseBtn.textContent = world.paused ? 'RESUME' : 'PAUSE';
      } else if (e.code === 'KeyR') {
        world.generation = 1;
        world.events = [];
        world.teamBrains = [null, null];
        world.spawnAgents(population);
      } else if (e.code === 'KeyF') {
        ui.fullscreenBtn.click();
      }
    });

    // Resize
    window.addEventListener('resize', () => renderer.resize());

    // --------------------
    // Game loop (fixed timestep)
    // --------------------
    const FIXED_DT = 1 / 60;
    let accumulator = 0;
    let lastTime = performance.now();

    // UPS tracking
    let upsCounter = 0;
    let upsTimer = 0;
    let currentUps = 60;

    let uiTimer = 0;
    const UI_INTERVAL = 0.2; // seconds

    function drawUI(dt) {
      uiTimer += dt;
      if (uiTimer < UI_INTERVAL) return;
      uiTimer = 0;

      // Only update generation in rounds mode (hidden in persistent mode)
      if (!persistentMode) {
        ui.gen.textContent = world.generation;
      }
      ui.alive.textContent = world.agents.filter(a => a.alive).length;
      ui.time.textContent = persistentMode
        ? formatTime(world.totalTime)
        : Math.ceil(world.timeLeft) + 's';

      // Team scores (new layout)
      ui.redScore.textContent = world.teamKills[0];
      ui.blueScore.textContent = world.teamKills[1];
      ui.redWins.textContent = world.teamWins[0];
      ui.blueWins.textContent = world.teamWins[1];

      // Update stats panel
      ui.statsMode.textContent = persistentMode ? 'Persistent' : 'Rounds';
      ui.statsTotalLives.textContent = totalLivesEvaluated;
      ui.statsRocketKills.textContent = world.weaponKills.rocket + ' / ' + world.totalWeaponKills.rocket;
      ui.statsLaserKills.textContent = world.weaponKills.laser + ' / ' + world.totalWeaponKills.laser;
      ui.statsSwordKills.textContent = world.weaponKills.sword + ' / ' + world.totalWeaponKills.sword;

      // Update stats panel UPS
      ui.statsUps.textContent = currentUps;
      if (currentUps >= 55) {
        ui.statsUps.style.color = '#00ff9d';
      } else if (currentUps >= 30) {
        ui.statsUps.style.color = '#ffc800';
      } else {
        ui.statsUps.style.color = '#ff4444';
      }

      // Show/hide Total Lives row based on mode (only relevant in persistent mode)
      ui.statsTotalLivesRow.style.display = persistentMode ? 'flex' : 'none';

      // Update Overall Kill Leaderboard in stats panel (works in both modes)
      const allAgents = world.agents.slice().sort((a, b) => b.totalKills - a.totalKills).slice(0, 10);
      ui.statsLeaderboard.innerHTML = allAgents.length > 0
        ? allAgents.map((a, i) => {
            const medal = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : ''));
            const teamColor = a.team === 0 ? '#ff6666' : '#6699ff';
            return '<div class="hof-entry" style="border-left: 2px solid ' + teamColor + '"><span>' + medal + ' ' + a.name + '</span><span style="color:#00ff9d">' + a.totalKills + 'K</span></div>';
          }).join('')
        : '<div style="opacity: 0.5; font-size: 0.75rem;">No data yet</div>';

      // Update Combat Log in stats panel
      ui.statsCombatLog.innerHTML = world.events.slice(-15).reverse().map(e => {
        const typeColors = { kill: '#ff4444', death: '#888', spawn: '#00ff9d', damage: '#ffc800', sword: '#ff00ff', laser: '#00aaff', pickup: '#00ff9d', teleporter: '#aa00ff' };
        const color = typeColors[e.type] || '#888';
        return '<div style="color: ' + color + '; padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">' + e.text + '</div>';
      }).join('');

      // Update top lives and avg score in top-bar (persistent mode only)
      if (persistentMode) {
        // Average life scores
        ui.redAvgLife.textContent = getAverageScoreAtDeath(0).toFixed(0);
        ui.blueAvgLife.textContent = getAverageScoreAtDeath(1).toFixed(0);

        // Top 5 lives with names
        function renderTopLives(hofList) {
          if (hofList.length === 0) {
            return '<div class="top-lives-empty">Waiting for data...</div>';
          }
          return hofList.slice(0, 5).map((e, i) => {
            const rank = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : '#' + (i + 1)));
            const name = e.name || 'Unknown';
            return '<div class="top-life-entry">' +
              '<span class="rank">' + rank + '</span>' +
              '<span class="name">' + name + '</span>' +
              '<span class="kills">' + e.kills + 'K</span>' +
            '</div>';
          }).join('');
        }

        ui.redTopLives.innerHTML = renderTopLives(hallOfFame[0]);
        ui.blueTopLives.innerHTML = renderTopLives(hallOfFame[1]);
      }

      // Update header display in persistent mode
      if (persistentMode) {
        ui.killLimitDisplay.textContent = formatTime(world.totalTime);
      }

      // Leaderboard - different in persistent mode
      if (persistentMode) {
        // Show Hall of Fame entries (combined from both teams, sorted by score)
        const combinedHoF = [
          ...hallOfFame[0].slice(0, 5).map(e => ({ ...e, team: 0 })),
          ...hallOfFame[1].slice(0, 5).map(e => ({ ...e, team: 1 }))
        ].sort((a, b) => b.score - a.score).slice(0, 10);

        ui.leaderboard.innerHTML = combinedHoF.length > 0
          ? combinedHoF.map((e, i) => {
              const timeAgo = Math.floor((Date.now() - e.timestamp) / 1000);
              const timeStr = timeAgo < 60 ? timeAgo + 's' : Math.floor(timeAgo / 60) + 'm';
              return '<div class="leader-entry" style="border-left: 2px solid ' + (e.team === 0 ? '#ff4444' : '#4488ff') + '">' +
                '<span class="name" style="color: ' + (e.team === 0 ? '#ff8888' : '#88aaff') + '">' + e.kills + 'K ' + timeStr + ' ago</span>' +
                '<span class="score">' + e.score + '</span>' +
              '</div>';
            }).join('')
          : '<div class="stat-row" style="opacity: 0.5;">No entries yet - start dying!</div>';

        // Legends moved to stats panel
      } else {
        // Normal round leaderboard
        ui.leaderboard.innerHTML = world.getLeaderboard().map((a, i) => {
          const status = a.alive ? '' : (a.respawnTimer > 0 ? ' (' + Math.ceil(a.respawnTimer) + 's)' : '');
          const kd = a.kills + '/' + a.deaths;
          return '<div class="leader-entry ' + (a.alive ? '' : 'dead') + '" style="border-left: 2px solid ' + (a.team === 0 ? '#ff4444' : '#4488ff') + '">' +
            '<span class="name" style="color: ' + (a.team === 0 ? '#ff8888' : '#88aaff') + '">' + a.name + status + '</span>' +
            '<span class="score">' + a.score + '</span>' +
          '</div>';
        }).join('');

        // Legends moved to stats panel
      }

      // Combat log moved to stats panel

      // Update agent profile card
      updateAgentProfile();
    }

    function updateAgentProfile() {
      const agent = renderer.followAgent;

      if (!agent) {
        ui.agentProfile.style.display = 'none';
        return;
      }

      ui.agentProfile.style.display = 'block';

      // Header - show dead status and respawn timer
      ui.profileName.textContent = agent.name;
      if (!agent.alive) {
        ui.profileName.style.color = '#666';
        const respawnSec = Math.ceil(agent.respawnTimer);
        ui.profileTeam.textContent = 'DEAD - Respawn in ' + respawnSec + 's';
        ui.profileTeam.style.color = '#888';
      } else {
        ui.profileName.style.color = agent.team === 0 ? '#ff6666' : '#6699ff';
        ui.profileTeam.textContent = agent.team === 0 ? 'RED TEAM' : 'BLUE TEAM';
        ui.profileTeam.style.color = agent.team === 0 ? '#ff4444' : '#4488ff';
      }

      // Health and armor bars
      const healthPct = agent.alive ? Math.max(0, agent.health / agent.maxHealth * 100) : 0;
      const armorPct = agent.alive ? Math.max(0, agent.armor / agent.maxArmor * 100) : 0;
      ui.profileHealthBar.style.width = healthPct + '%';
      ui.profileHealthVal.textContent = agent.alive ? Math.ceil(agent.health) : '0';
      ui.profileArmorBar.style.width = armorPct + '%';
      ui.profileArmorVal.textContent = agent.alive ? Math.ceil(agent.armor) : '0';

      // Weapon
      const weaponDisplay = {
        'rocket': 'üöÄ Rocket',
        'laser': '‚ö° Laser',
        'sword': 'üó°Ô∏è Sword'
      };
      ui.profileWeapon.textContent = weaponDisplay[agent.weapon] || agent.weapon;

      // K/D
      ui.profileKd.textContent = agent.kills + '/' + agent.deaths;

      // Neural activity (from last decision)
      if (agent.lastDecision) {
        const d = agent.lastDecision;

        // Turn: -1 to 1, show as bar from center
        const turnVal = Math.abs(d.turnAmount) * 50;
        ui.neuralTurn.style.setProperty('--bar-height', turnVal + '%');
        ui.neuralTurn.className = 'indicator-bar ' + (d.turnAmount >= 0 ? 'positive' : 'negative');

        // Speed: 0 to 1
        ui.neuralSpeed.style.setProperty('--bar-height', d.speedAmount * 50 + '%');
        ui.neuralSpeed.className = 'indicator-bar positive';

        // Strafe: -1 to 1
        const strafeVal = Math.abs(d.strafe) * 50;
        ui.neuralStrafe.style.setProperty('--bar-height', strafeVal + '%');
        ui.neuralStrafe.className = 'indicator-bar ' + (d.strafe >= 0 ? 'positive' : 'negative');

        // Fire and Dash: boolean
        ui.neuralShoot.className = 'indicator-light' + (d.wantsShoot ? ' active' : '');
        ui.neuralDash.className = 'indicator-light' + (d.wantsDash ? ' active' : '');
      }

      // Awareness
      if (agent.lastAwareness) {
        const a = agent.lastAwareness;
        if (a.enemyDist < 1) {
          const dist = Math.round(a.enemyDist * 1000);
          const dir = a.enemyAngle > 0 ? 'R' : 'L';
          ui.awarenessEnemy.textContent = dist + 'm ' + dir;
        } else {
          ui.awarenessEnemy.textContent = 'None';
        }
        if (a.allyDist < 1) {
          const dist = Math.round(a.allyDist * 500);
          const dir = a.allyAngle > 0 ? 'R' : 'L';
          ui.awarenessAlly.textContent = dist + 'm ' + dir;
        } else {
          ui.awarenessAlly.textContent = 'None';
        }
      }
    }

    // Background tab support - keep simulation running when tab is hidden
    let pageHidden = document.hidden;
    let backgroundLoopId = null;

    document.addEventListener('visibilitychange', () => {
      pageHidden = document.hidden;
      if (pageHidden) {
        // Start background loop when tab is hidden
        lastTime = performance.now();
        backgroundLoop();
      } else {
        // Stop background loop, RAF will take over
        if (backgroundLoopId) {
          clearTimeout(backgroundLoopId);
          backgroundLoopId = null;
        }
        lastTime = performance.now();
      }
    });

    // Background loop using setTimeout (not throttled as much as RAF)
    function backgroundLoop() {
      if (!pageHidden) return;

      const curr = performance.now();
      const realDt = Math.min((curr - lastTime) / 1000, 0.1);
      lastTime = curr;

      // UPS tracking
      upsTimer += realDt;
      if (upsTimer >= 1.0) {
        currentUps = upsCounter;
        upsCounter = 0;
        upsTimer = 0;
      }

      // scale by simSpeed into the simulation accumulator
      accumulator += realDt * simSpeed;

      // In background, allow many more steps since we're not rendering
      const maxSteps = 200;
      let steps = 0;
      while (accumulator >= FIXED_DT && steps < maxSteps) {
        world.update(FIXED_DT);
        accumulator -= FIXED_DT;
        steps++;
        upsCounter++;
      }
      if (steps === maxSteps) accumulator = 0;

      // Schedule next background tick (setTimeout is less throttled than RAF)
      backgroundLoopId = setTimeout(backgroundLoop, 16);
    }

    function gameLoop(curr) {
      // Skip if page is hidden (background loop handles it)
      if (pageHidden) {
        requestAnimationFrame(gameLoop);
        return;
      }

      const realDt = Math.min((curr - lastTime) / 1000, 0.1);
      lastTime = curr;

      // UPS tracking
      upsTimer += realDt;
      if (upsTimer >= 1.0) {
        currentUps = upsCounter;
        upsCounter = 0;
        upsTimer = 0;
      }

      // scale by simSpeed into the simulation accumulator
      accumulator += realDt * simSpeed;

      // prevent spiral of death - but allow more steps in headless mode
      const maxSteps = headlessMode ? 100 : 12;
      let steps = 0;
      while (accumulator >= FIXED_DT && steps < maxSteps) {
        world.update(FIXED_DT);
        accumulator -= FIXED_DT;
        steps++;
        upsCounter++;
      }
      // if we hit max steps, drop the rest to keep UI responsive
      if (steps === maxSteps) accumulator = 0;

      // Only render if not headless
      if (!headlessMode) {
        renderer.updateFollow();
        renderer.render();
      }
      drawUI(realDt);

      requestAnimationFrame(gameLoop);
    }

    // Initialize UI values
    ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    ui.speedValue.textContent = simSpeed + 'x';
    ui.populationValue.textContent = String(population);
    ui.roundTimeValue.textContent = String(parseInt(ui.roundTime.value, 10));
    ui.killLimitValue.textContent = String(world.killLimit);

    // ========== MODULAR DRAGGABLE PANELS ==========
    (function initDraggablePanels() {
      const STORAGE_KEY = 'panelOrder';

      // Get saved panel order from localStorage
      function getSavedOrder() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          return saved ? JSON.parse(saved) : null;
        } catch { return null; }
      }

      // Save panel order to localStorage
      function saveOrder() {
        const order = {
          left: Array.from(document.querySelectorAll('#left-sidebar .panel[data-panel-id]'))
            .map(p => p.dataset.panelId)
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(order));
      }

      // Restore saved panel order
      function restoreOrder() {
        const order = getSavedOrder();
        if (!order) return;

        const sidebar = document.getElementById('left-sidebar');
        if (!sidebar || !order.left) return;

        const panels = {};
        sidebar.querySelectorAll('.panel[data-panel-id]').forEach(p => {
          panels[p.dataset.panelId] = p;
        });

        order.left.forEach(id => {
          if (panels[id]) sidebar.appendChild(panels[id]);
        });
      }

      // Drag state
      let draggedPanel = null;
      let draggedRect = null;
      let placeholder = null;
      let startY = 0;
      let offsetY = 0;
      let currentSidebar = null;

      // Get all panels in a sidebar, sorted by visual position
      function getPanelsInOrder(sidebar) {
        return Array.from(sidebar.querySelectorAll('.panel[data-panel-id]'))
          .filter(p => p !== draggedPanel && !p.classList.contains('placeholder'));
      }

      // Calculate where the dragged panel should be inserted
      function getInsertIndex(sidebar, y) {
        const panels = getPanelsInOrder(sidebar);
        for (let i = 0; i < panels.length; i++) {
          const rect = panels[i].getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          if (y < midY) return i;
        }
        return panels.length;
      }

      // Handle drag start (mouse/touch)
      function startDrag(e, panel) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;

        e.preventDefault();

        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        draggedPanel = panel;
        currentSidebar = panel.parentElement;
        draggedRect = panel.getBoundingClientRect();
        startY = clientY;
        offsetY = clientY - draggedRect.top;

        // Create placeholder
        placeholder = document.createElement('div');
        placeholder.className = 'panel placeholder';
        placeholder.style.height = draggedRect.height + 'px';
        placeholder.style.marginBottom = getComputedStyle(panel).marginBottom;
        panel.parentElement.insertBefore(placeholder, panel);

        // Style dragged panel
        panel.classList.add('dragging');
        panel.style.position = 'fixed';
        panel.style.width = draggedRect.width + 'px';
        panel.style.left = draggedRect.left + 'px';
        panel.style.top = draggedRect.top + 'px';
        panel.style.margin = '0';

        document.body.style.cursor = 'grabbing';
      }

      // Handle drag move
      function moveDrag(e) {
        if (!draggedPanel) return;

        e.preventDefault();

        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const newTop = clientY - offsetY;

        draggedPanel.style.top = newTop + 'px';

        // Find which sidebar we're over (only left sidebar has draggable panels now)
        const sidebars = [
          document.getElementById('left-sidebar')
        ].filter(Boolean);

        let targetSidebar = currentSidebar;
        for (const sidebar of sidebars) {
          const rect = sidebar.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          if (clientX >= rect.left && clientX <= rect.right) {
            targetSidebar = sidebar;
            break;
          }
        }

        // Move placeholder to new position
        if (targetSidebar) {
          const insertIdx = getInsertIndex(targetSidebar, clientY);
          const panels = getPanelsInOrder(targetSidebar);

          // Remove placeholder from current position
          if (placeholder.parentElement) {
            placeholder.parentElement.removeChild(placeholder);
          }

          // Insert at new position
          if (insertIdx >= panels.length) {
            targetSidebar.appendChild(placeholder);
          } else {
            targetSidebar.insertBefore(placeholder, panels[insertIdx]);
          }

          currentSidebar = targetSidebar;
        }
      }

      // Handle drag end
      function endDrag() {
        if (!draggedPanel) return;

        // Animate panel to placeholder position
        const placeholderRect = placeholder.getBoundingClientRect();

        draggedPanel.style.transition = 'top 0.2s ease, left 0.2s ease';
        draggedPanel.style.top = placeholderRect.top + 'px';
        draggedPanel.style.left = placeholderRect.left + 'px';

        setTimeout(() => {
          // Reset panel styles
          draggedPanel.classList.remove('dragging');
          draggedPanel.style.position = '';
          draggedPanel.style.width = '';
          draggedPanel.style.left = '';
          draggedPanel.style.top = '';
          draggedPanel.style.margin = '';
          draggedPanel.style.transition = '';

          // Insert panel where placeholder was
          placeholder.parentElement.insertBefore(draggedPanel, placeholder);
          placeholder.remove();

          // Save new order
          saveOrder();

          draggedPanel = null;
          placeholder = null;
          currentSidebar = null;
        }, 200);

        document.body.style.cursor = '';
      }

      // Attach event listeners to all panels
      document.querySelectorAll('.panel[data-panel-id] h2').forEach(header => {
        const panel = header.parentElement;

        // Mouse events
        header.addEventListener('mousedown', e => startDrag(e, panel));

        // Touch events
        header.addEventListener('touchstart', e => startDrag(e, panel), { passive: false });
      });

      // Global move/end handlers
      document.addEventListener('mousemove', moveDrag);
      document.addEventListener('mouseup', endDrag);
      document.addEventListener('touchmove', moveDrag, { passive: false });
      document.addEventListener('touchend', endDrag);

      // Restore saved order on load
      restoreOrder();
    })();

    requestAnimationFrame(gameLoop);
  })();
  </script>

</body>
</html>
