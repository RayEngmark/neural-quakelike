<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NEURAL QUAKE ARENA // V3.0</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #050510;
      --panel-bg: rgba(13, 13, 25, 0.95);
      --neon-blue: #00f3ff;
      --neon-pink: #ff0055;
      --neon-green: #00ff9d;
      --neon-yellow: #ffd700;
      --laser-blue: #00aaff;
      --text-main: #e0e6ed;
      --border-color: rgba(255, 255, 255, 0.1);
    }

```
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: var(--bg-dark);
  color: var(--text-main);
  font-family: 'Rajdhani', sans-serif;
  overflow: hidden;
  height: 100vh;
}

/* === NEW LAYOUT: Top bar + Game + Right sidebar === */
#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* TOP BAR - Scores */
#top-bar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
  padding: 8px 15px;
  background: var(--panel-bg);
  border-bottom: 2px solid var(--border-color);
  flex-shrink: 0;
}

.team-block {
  display: flex;
  align-items: center;
  gap: 15px;
}
.team-block.red { flex-direction: row; }
.team-block.blue { flex-direction: row; }

.team-score {
  text-align: center;
}
.team-score .score {
  font-family: 'JetBrains Mono', monospace;
  font-size: 2.5rem;
  font-weight: bold;
  text-shadow: 0 0 20px currentColor;
  line-height: 1;
}
.team-score .label {
  font-size: 0.7rem;
  opacity: 0.7;
  text-transform: uppercase;
}
.team-block.red .team-score { color: #ff4444; }
.team-block.blue .team-score { color: #4488ff; }

.team-wins {
  text-align: center;
  padding: 5px 12px;
  background: rgba(255,255,255,0.05);
  border-radius: 4px;
}
.team-wins .wins {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.4rem;
  font-weight: bold;
}
.team-wins .label {
  font-size: 0.6rem;
  opacity: 0.5;
  text-transform: uppercase;
}
.team-block.red .team-wins { color: #ff6666; }
.team-block.blue .team-wins { color: #6699ff; }

#center-info {
  text-align: center;
  padding: 0 30px;
  border-left: 1px solid var(--border-color);
  border-right: 1px solid var(--border-color);
}
#center-info .big {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.8rem;
  color: var(--neon-green);
  font-weight: bold;
}
#center-info .sub {
  font-size: 0.65rem;
  color: #666;
  text-transform: uppercase;
}

/* MAIN AREA - Canvas + Sidebars */
#main-area {
  display: flex;
  flex: 1;
  overflow: hidden;
  justify-content: center;
}

/* LEFT SIDEBAR - Stats & Controls */
#left-sidebar {
  width: 250px;
  background: var(--panel-bg);
  border-right: 1px solid var(--border-color);
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  overflow-y: auto;
  flex-shrink: 0;
}

/* CANVAS */
#canvas-container {
  flex: 1;
  position: relative;
  background: radial-gradient(circle at center, #1a1a2e 0%, #050510 100%);
  overflow: hidden;
  margin: 5px 0;
}
canvas { display: block; width: 100%; height: 100%; }

/* RIGHT SIDEBAR - Game Modifiers */
#right-sidebar {
  width: 200px;
  background: var(--panel-bg);
  border-left: 1px solid var(--border-color);
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  overflow-y: auto;
  flex-shrink: 0;
}

/* PANELS */
.panel {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 10px;
  position: relative;
}
.panel::before {
  content: '';
  position: absolute;
  top: -1px; left: -1px;
  width: 8px; height: 8px;
  border-top: 2px solid var(--neon-blue);
  border-left: 2px solid var(--neon-blue);
}
.panel::after {
  content: '';
  position: absolute;
  bottom: -1px; right: -1px;
  width: 8px; height: 8px;
  border-bottom: 2px solid var(--neon-blue);
  border-right: 2px solid var(--neon-blue);
}
.panel h2 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  color: #667;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 8px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  font-size: 0.85rem;
  border-bottom: 1px dashed rgba(255,255,255,0.05);
}
.stat-value {
  font-family: 'JetBrains Mono', monospace;
  color: var(--neon-green);
  font-weight: bold;
}

/* TOGGLES */
.toggle-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 0;
}
.toggle-row label {
  font-size: 0.8rem;
  color: #adb5bd;
}
.toggle {
  width: 38px;
  height: 20px;
  background: rgba(255,255,255,0.15);
  border-radius: 10px;
  cursor: pointer;
  position: relative;
  transition: background 0.3s;
}
.toggle::after {
  content: '';
  position: absolute;
  top: 2px; left: 2px;
  width: 16px; height: 16px;
  background: #888;
  border-radius: 50%;
  transition: all 0.3s;
}
.toggle.active { background: var(--neon-green); }
.toggle.active::after { 
  transform: translateX(18px); 
  background: #fff;
}
.toggle.disabled { opacity: 0.3; cursor: not-allowed; }

/* SLIDERS */
.control-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
}
.control-row label {
  width: 40px;
  flex-shrink: 0;
  font-size: 0.75rem;
  color: #adb5bd;
}
input[type="range"] {
  -webkit-appearance: none;
  flex: 1;
  min-width: 60px;
  height: 4px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 14px;
  width: 14px;
  border-radius: 50%;
  background: var(--neon-blue);
  cursor: pointer;
  box-shadow: 0 0 8px var(--neon-blue);
}
.control-row .value {
  min-width: 35px;
  width: 35px;
  flex-shrink: 0;
  text-align: right;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem;
  color: var(--neon-blue);
}

/* BUTTONS */
button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: rgba(0, 243, 255, 0.1);
  border: 1px solid var(--neon-blue);
  color: var(--neon-blue);
  padding: 10px 16px;
  border-radius: 2px;
  cursor: pointer;
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
  font-size: 0.8rem;
  text-transform: uppercase;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}
button:hover {
  background: var(--neon-blue);
  color: #000;
  box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
}
button.secondary {
  border-color: #666;
  color: #aaa;
  background: transparent;
}
button.secondary:hover {
  border-color: #fff;
  color: #fff;
  background: rgba(255,255,255,0.1);
  box-shadow: none;
}
.btn-row {
  display: flex;
  gap: 10px;
}
.btn-row button { flex: 1; }

/* SCROLLBARS */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb {
  background: var(--neon-blue);
  border-radius: 4px;
  border: 2px solid transparent;
  background-clip: padding-box;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--neon-green);
  border: 2px solid transparent;
  background-clip: padding-box;
}

/* LEADERBOARD */
#leaderboard, #alltime-leaderboard {
  max-height: 140px;
  overflow-y: auto;
}
.leader-entry {
  display: flex;
  justify-content: space-between;
  padding: 4px 6px;
  font-size: 0.75rem;
  margin-bottom: 2px;
  background: rgba(255,255,255,0.02);
  border-radius: 2px;
}
.leader-entry .name {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.leader-entry .score {
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
}
.leader-entry.dead { opacity: 0.3; }

/* EVENT LOG */
#event-log {
  max-height: 100px;
  overflow-y: auto;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
}
.event { padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.03); }
.event .kill { color: var(--neon-pink); }
.event .damage { color: var(--neon-yellow); }
.event .pickup { color: var(--neon-green); }
.event .laser { color: var(--laser-blue); }

#load-file { display: none; }

/* HEADLESS OVERLAY */
#headless-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(5, 5, 16, 0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}
#headless-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}
#headless-overlay .icon {
  font-size: 4rem;
  margin-bottom: 20px;
}
#headless-overlay h2 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.5rem;
  color: var(--neon-green);
  text-transform: uppercase;
  letter-spacing: 3px;
  margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
}
#headless-overlay p {
  color: #888;
  font-size: 0.9rem;
  margin-bottom: 25px;
}
#headless-overlay .hint {
  background: rgba(0, 255, 157, 0.1);
  border: 1px solid rgba(0, 255, 157, 0.3);
  border-radius: 6px;
  padding: 15px 25px;
  color: #aaa;
  font-size: 0.85rem;
}
#headless-overlay .hint strong {
  color: var(--neon-green);
}
```

  </style>
</head>
<body>
  <div id="app">
    <!-- TOP BAR: Scores & Match Info -->
    <div id="top-bar">
      <div class="team-block red">
        <div class="team-wins">
          <div class="wins" id="red-wins">0</div>
          <div class="label">wins</div>
        </div>
        <div class="team-score">
          <div class="score" id="red-score">0</div>
          <div class="label">üî¥ RED</div>
        </div>
      </div>

```
  <div id="center-info">
    <div class="big" id="kill-limit-display">50</div>
    <div class="sub">first to</div>
  </div>

  <div class="team-block blue">
    <div class="team-score">
      <div class="score" id="blue-score">0</div>
      <div class="label">BLUE üîµ</div>
    </div>
    <div class="team-wins">
      <div class="wins" id="blue-wins">0</div>
      <div class="label">wins</div>
    </div>
  </div>
</div>

<!-- MAIN AREA -->
<div id="main-area">
  <!-- LEFT SIDEBAR: Stats & Controls -->
  <div id="left-sidebar">
    <div class="panel">
      <h2>// Status</h2>
      <div class="stat-row">
        <span>Generation</span>
        <span class="stat-value" id="generation">1</span>
      </div>
      <div class="stat-row">
        <span>Alive</span>
        <span class="stat-value" id="alive">100</span>
      </div>
      <div class="stat-row">
        <span>Time</span>
        <span class="stat-value" id="time-left">60s</span>
      </div>
      <div class="stat-row">
        <span>UPS</span>
        <span class="stat-value" id="ups">60</span>
      </div>
    </div>

    <div class="panel">
      <h2>// Parameters</h2>
      <div class="control-row">
        <label>Zoom</label>
        <input type="range" id="zoom" min="25" max="300" value="100" />
        <span class="value" id="zoom-value">1.0x</span>
      </div>
      <div class="control-row">
        <label>Speed</label>
        <input type="range" id="speed" min="1" max="20" value="1" />
        <span class="value" id="speed-value">1x</span>
      </div>
      <div class="control-row">
        <label>Pop</label>
        <input type="range" id="population" min="20" max="200" value="100" step="10" />
        <span class="value" id="population-value">100</span>
      </div>
      <div class="control-row">
        <label>Time</label>
        <input type="range" id="round-time" min="1" max="10" value="1" step="1" />
        <span class="value" id="round-time-value">1m</span>
      </div>
      <div class="control-row">
        <label>Kills</label>
        <input type="range" id="kill-limit" min="10" max="100" value="50" step="5" />
        <span class="value" id="kill-limit-value">50</span>
      </div>
      <div class="control-row">
        <label>Respawn</label>
        <input type="range" id="respawn-time" min="1" max="10" value="3" step="1" />
        <span class="value" id="respawn-time-value">3s</span>
      </div>
    </div>

    <div class="panel">
      <h2>// Controls</h2>
      <div class="btn-row">
        <button id="pause-btn">PAUSE</button>
        <button id="restart-btn" class="secondary">RESET</button>
      </div>
      <div class="btn-row" style="margin-top:10px;">
        <button id="save-btn" style="background: rgba(0, 200, 255, 0.1); border-color: #00c8ff; color: #00c8ff;">üíæ SAVE</button>
        <button id="load-btn" style="background: rgba(200, 0, 255, 0.1); border-color: #c800ff; color: #c800ff;">üìÇ LOAD</button>
      </div>
      <div class="btn-row" style="margin-top:10px;">
        <button id="headless-btn" style="background: rgba(0, 255, 0, 0.3); border-color: #0f0; color: #0f0; width: 100%;">üñ•Ô∏è HEADLESS MODE (ON)</button>
      </div>
      <input type="file" id="load-file" accept=".json" />
    </div>

    <div class="panel">
      <h2>// Legends üèÜ</h2>
      <div id="alltime-leaderboard"></div>
    </div>

    <div class="panel">
      <h2>// Leaderboard</h2>
      <div id="leaderboard"></div>
    </div>

    <div class="panel">
      <h2>// Combat Log</h2>
      <div id="event-log"></div>
    </div>
  </div>

  <!-- CANVAS -->
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="headless-overlay">
      <div class="icon">üñ•Ô∏è</div>
      <h2>Simulation Running in Headless Mode</h2>
      <p>Rendering is disabled for faster simulation speed.</p>
      <div class="hint">Toggle <strong>üñ•Ô∏è HEADLESS</strong> in Controls to view the battle.</div>
    </div>
  </div>

  <!-- RIGHT SIDEBAR: Game Modifiers -->
  <div id="right-sidebar">
    <div class="panel">
      <h2>// Game Modifiers</h2>
      <div class="toggle-row" title="Spawns health packs every 10s. Instant 50HP + 50HP regen over 5s.">
        <label>ü©π Health Spawns</label>
        <div class="toggle active" id="toggle-health"></div>
      </div>
      <div class="toggle-row" title="Spawns armor pickups every 10s. +50 armor per pickup, max 100.">
        <label>üõ°Ô∏è Armor Spawns</label>
        <div class="toggle active" id="toggle-armor"></div>
      </div>
      <div class="toggle-row" title="Laser weapons spawn at map center when half kills/time reached. 3s charge, instant kill beam.">
        <label>‚ö° Laser Drops</label>
        <div class="toggle active" id="toggle-laser"></div>
      </div>
      <div class="toggle-row" title="Energy swords spawn at map center. Hold to charge, release to lunge. Instant kill.">
        <label>üó°Ô∏è Sword Drops</label>
        <div class="toggle active" id="toggle-sword"></div>
      </div>
      <div class="toggle-row" title="Agents can dash/dodge in any direction. 6 second cooldown.">
        <label>üí® Dodging</label>
        <div class="toggle active" id="toggle-dodge"></div>
      </div>
      <div class="toggle-row" style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;" title="Rockets damage teammates directly.">
        <label>üí• Friendly Fire</label>
        <div class="toggle" id="toggle-ff"></div>
      </div>
      <div class="toggle-row" title="Teammate damage reflects back to shooter.">
        <label>üîÑ FF Ricochet</label>
        <div class="toggle" id="toggle-ricochet"></div>
      </div>
    </div>

    <div class="panel">
      <h2>// Field Items</h2>
      <div id="field-items-list">
        <div class="stat-row" style="opacity: 0.5; font-size: 0.75rem;">No active spawns</div>
      </div>
    </div>

    <div class="panel">
      <h2>// Weapons</h2>
      <div class="stat-row" title="4s cooldown, 90 damage, 120 radius splash">
        <span>üöÄ Rocket</span>
        <span class="stat-value">90 dmg</span>
      </div>
      <div class="stat-row" title="3s charge time, infinite range beam, instant kill">
        <span style="color: var(--neon-blue);">‚ö° Laser</span>
        <span class="stat-value" style="color: var(--neon-blue);">‚àû dmg</span>
      </div>
      <div class="stat-row" title="Hold to charge (0.3-2s), release to lunge. Team colored.">
        <span style="color: #ff00ff;">üó°Ô∏è Sword</span>
        <span class="stat-value" style="color: #ff00ff;">‚àû dmg</span>
      </div>
    </div>
  </div>
</div>
```

  </div>

  <script>
  (() => {
    'use strict';

    // --------------------
    // Utility
    // --------------------
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    // --------------------
    // Names
    // --------------------
    const FIRST_NAMES = ['Ole', 'Lars', 'Erik', 'Anders', 'Magnus', 'Henrik', 'Jonas', 'Marius', 'Kristian', 'Thomas', 'Astrid', 'Ingrid', 'Solveig', 'Freya', 'Sigrid', 'Nora', 'Emma', 'Maja', 'Thea', 'Ella', 'Bj√∏rn', 'Torstein', 'Gunnar', 'H√•kon', 'Leif', 'Ragnar', 'Sven', 'Olav', 'Knut', 'Arne', 'Liv', 'Grete', 'Kari', 'Anne', 'James', 'John', 'William', 'David', 'Richard', 'Mary', 'Patricia', 'Jennifer', 'Linda', 'Elizabeth', 'Michael', 'Christopher', 'Joshua', 'Andrew', 'Brandon', 'Emily', 'Hannah', 'Madison', 'Ashley', 'Olivia', 'Jack', 'Harry', 'Oliver', 'George', 'Charlie', 'Grace', 'Chloe', 'Lily', 'Mia', 'Ruby', 'Viktor', 'Felix', 'Oscar', 'Sebastian', 'Adrian', 'Aurora', 'Emilie', 'Hedda', 'Sara', 'Julie'];
    const LAST_NAMES = ['Hansen', 'Johansen', 'Olsen', 'Larsen', 'Andersen', 'Pedersen', 'Nilsen', 'Kristiansen', 'Jensen', 'Karlsen', 'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Miller', 'Davis', 'Garcia', 'Rodriguez', 'Wilson', 'Martinez', 'Anderson', 'Taylor', 'Thomas', 'Moore', 'Martin', 'Jackson', 'Thompson', 'White', 'Lopez'];

    // --------------------
    // Neural net
    // --------------------
    class NeuralNetwork {
      constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize, hiddenSize);
        this.biasH = new Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
        this.biasO = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
      }
      randomMatrix(rows, cols, fanIn) {
        const scale = Math.sqrt(2 / fanIn);
        const m = new Array(rows);
        for (let r = 0; r < rows; r++) {
          const row = new Array(cols);
          for (let c = 0; c < cols; c++) row[c] = (Math.random() - 0.5) * 2 * scale;
          m[r] = row;
        }
        return m;
      }
      activate(x) { return Math.tanh(x); }
      forward(inputs) {
        // Safe pad/truncate so we always use the full weight matrix.
        const x = (inputs.length === this.inputSize)
          ? inputs
          : inputs.length > this.inputSize
            ? inputs.slice(0, this.inputSize)
            : inputs.concat(new Array(this.inputSize - inputs.length).fill(0));

        const hidden = new Array(this.hiddenSize);
        for (let i = 0; i < this.hiddenSize; i++) {
          let sum = this.biasH[i];
          const w = this.weightsIH[i];
          for (let j = 0; j < this.inputSize; j++) sum += w[j] * x[j];
          hidden[i] = this.activate(sum);
        }

        const out = new Array(this.outputSize);
        for (let i = 0; i < this.outputSize; i++) {
          let sum = this.biasO[i];
          const w = this.weightsHO[i];
          for (let j = 0; j < this.hiddenSize; j++) sum += w[j] * hidden[j];
          out[i] = this.activate(sum);
        }
        return out;
      }
      clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(row => row.slice());
        nn.weightsHO = this.weightsHO.map(row => row.slice());
        nn.biasH = this.biasH.slice();
        nn.biasO = this.biasO.slice();
        return nn;
      }
      mutate(rate = 0.1, strength = 0.3) {
        const mutateVal = (v) => (Math.random() < rate ? v + (Math.random() - 0.5) * 2 * strength : v);
        const mutateArr = (arr) => { for (let i = 0; i < arr.length; i++) arr[i] = mutateVal(arr[i]); };
        const mutateMat = (mat) => { for (let r = 0; r < mat.length; r++) mutateArr(mat[r]); };
        mutateMat(this.weightsIH);
        mutateMat(this.weightsHO);
        mutateArr(this.biasH);
        mutateArr(this.biasO);
      }
    }

    // --------------------
    // Pickups
    // --------------------
    class BowPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class KnifePickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }
    class SniperPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class ShotgunPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class BazookaPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 22; this.pickedUp = false; this.spawnTime = Date.now(); } }
    class HealingPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; this.healAmount = 50; } }
    class ArmorPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }

    // --------------------
    // Projectiles
    // --------------------
    class Arrow {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 350; this.damage = 50; this.maxRange = 1200;
        this.distanceTraveled = 0; this.alive = true; this.radius = 5;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class Bullet {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 800; this.damage = 100; this.maxRange = 2000;
        this.distanceTraveled = 0; this.alive = true; this.radius = 3;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class ShotgunBlast {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.nearRange = 80; this.farRange = 150; this.spreadAngle = Math.PI / 4;
        this.maxTime = 0.2; this.timer = 0; this.active = true;
        this.hasDealtNearDamage = false; this.hasDealtFarDamage = false;
        this.currentRadius = 0; this.speed = 800;
      }
      update(dt, agents, world) {
        if (!this.active) return;
        this.timer += dt;
        this.currentRadius = this.timer * this.speed;
        if (!this.hasDealtNearDamage && this.currentRadius >= this.nearRange) {
          this.hasDealtNearDamage = true;
          this.dealDamageInRange(agents, world, 0, this.nearRange, 100);
        }
        if (!this.hasDealtFarDamage && this.currentRadius >= this.farRange) {
          this.hasDealtFarDamage = true;
          this.dealDamageInRange(agents, world, this.nearRange, this.farRange, 50);
        }
        if (this.timer >= this.maxTime) this.active = false;
      }
      dealDamageInRange(agents, world, minDist, maxDist, damage) {
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = agent.x - this.x, dy = agent.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist || dist > maxDist) continue;

          let angleToAgent = Math.atan2(dy, dx);
          let angleDiff = angleToAgent - this.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          if (Math.abs(angleDiff) > this.spreadAngle) continue;

          const killed = agent.takeDamage(damage, this.owner, world);
          this.owner.damageDealt += damage;
          world.addEvent(this.owner.name + ' blasted ' + agent.name, 'damage');
          if (killed) {
            this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
            world.teamKills[this.owner.team]++;
            this.owner.killScore += 50;
            world.addEvent(this.owner.name + ' killed ' + agent.name + '!', 'kill');
          }
        }
      }
    }

    class Rocket {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 280; // Slower than arrows (350)
        this.maxRange = 1500;
        this.distanceTraveled = 0;
        this.alive = true;
        this.radius = 8;
        this.explosionRadius = 120;
        this.damage = 200; // Instakill in center
        // Trail particles
        this.trail = [];
        this.trailTimer = 0;
      }
      update(dt, agents, obstacles, world) {
        if (!this.alive) return null;
        
        // Wobbly flight path for visual fun
        const wobble = Math.sin(this.distanceTraveled * 0.05) * 0.02;
        const moveAngle = this.angle + wobble;
        
        const moveX = Math.cos(moveAngle) * this.speed * dt;
        const moveY = Math.sin(moveAngle) * this.speed * dt;
        this.x += moveX;
        this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        
        // Add smoke trail particles
        this.trailTimer += dt;
        if (this.trailTimer > 0.02) {
          this.trailTimer = 0;
          this.trail.push({
            x: this.x - Math.cos(this.angle) * 15,
            y: this.y - Math.sin(this.angle) * 15,
            life: 1,
            size: 8 + Math.random() * 6,
            vx: (Math.random() - 0.5) * 30,
            vy: (Math.random() - 0.5) * 30
          });
        }
        
        // Update trail
        for (const p of this.trail) {
          p.life -= dt * 2;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.size *= 0.98;
        }
        this.trail = this.trail.filter(p => p.life > 0);
        
        // Max range - explode
        if (this.distanceTraveled >= this.maxRange) {
          this.alive = false;
          return { type: 'explode', x: this.x, y: this.y };
        }
        
        // Hit obstacle - explode
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        // Hit agent - explode
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        return null;
      }
    }

    class Explosion {
      constructor(x, y, owner, radius, damage) {
        this.x = x;
        this.y = y;
        this.owner = owner;
        this.radius = radius;
        this.damage = damage;
        this.maxTime = 0.6;
        this.timer = 0;
        this.hasDealtDamage = false;
        this.currentRadius = 0;
        // Shockwave rings
        this.rings = [];
        // Debris particles
        this.particles = [];
        for (let i = 0; i < 40; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 150 + Math.random() * 350;
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.4 + Math.random() * 0.4,
            size: 3 + Math.random() * 8,
            color: Math.random() > 0.5 ? '#ff6600' : (Math.random() > 0.5 ? '#ffcc00' : '#ff0000')
          });
        }
        // Initial flash
        this.flashIntensity = 1;
      }
      update(dt, agents, world) {
        this.timer += dt;
        this.currentRadius = Math.min(this.radius, (this.timer / 0.15) * this.radius);
        this.flashIntensity = Math.max(0, 1 - this.timer * 4);
        
        // Add expanding rings
        if (this.timer < 0.3 && Math.random() < 0.3) {
          this.rings.push({ radius: this.currentRadius * 0.3, alpha: 1 });
        }
        
        // Update rings
        for (const ring of this.rings) {
          ring.radius += 400 * dt;
          ring.alpha -= dt * 3;
        }
        this.rings = this.rings.filter(r => r.alpha > 0);
        
        // Update particles
        for (const p of this.particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += 200 * dt; // Gravity
          p.life -= dt;
          p.size *= 0.97;
        }
        this.particles = this.particles.filter(p => p.life > 0);
        
        // Deal damage once at peak
        if (!this.hasDealtDamage && this.timer >= 0.05) {
          this.hasDealtDamage = true;
          for (const agent of agents) {
            if (!agent.alive || (this.owner && agent.team === this.owner.team)) continue;
            const dx = agent.x - this.x, dy = agent.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > this.radius) continue;
            
            // Damage falloff: 100% at center, 50% at edge
            const falloff = 1 - (dist / this.radius) * 0.5;
            const finalDamage = Math.floor(this.damage * falloff);
            
            const killed = agent.takeDamage(finalDamage, this.owner, world);
            if (this.owner) {
              this.owner.damageDealt += finalDamage;
              if (killed) {
                this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
                world.teamKills[this.owner.team]++;
                this.owner.killScore += 50;
                world.addEvent('üí• ' + this.owner.name + ' OBLITERATED ' + agent.name + '!', 'kill');
              } else {
                world.addEvent(this.owner.name + ' rocket hit ' + agent.name, 'damage');
              }
            }
          }
        }
        
        return this.timer >= this.maxTime;
      }
    }

    // --------------------
    // Control Point
    // --------------------
    class ControlPoint {
      constructor(x, y, size) {
        this.x = x; this.y = y; this.size = size;
        this.owner = null; this.capturer = null;
        this.captureProgress = 0; this.captureTime = 10;
        this.contested = false;
        this.color = 'hsl(' + (Math.random() * 360) + ', 100%, 50%)';
      }
      containsAgent(agent) {
        return agent.x >= this.x && agent.x <= this.x + this.size && agent.y >= this.y && agent.y <= this.y + this.size;
      }
      getAgentsInside(agents) { return agents.filter(a => a.alive && this.containsAgent(a)); }
      update(dt, agents, world) {
        const inside = this.getAgentsInside(agents);

        if (this.owner && !this.owner.alive) {
          world.addEvent(this.owner.name + ' lost point', 'damage');
          this.owner = null;
        }

        this.contested = inside.length > 1;
        if (this.contested) {
          this.capturer = null;
          this.captureProgress = 0;
          return;
        }

        if (inside.length === 1) {
          const agent = inside[0];

          if (this.owner === agent) {
            agent.controlPointSeconds += dt;
            return;
          }

          // Capturing
          if (this.capturer !== agent) {
            this.capturer = agent;
            this.captureProgress = 0;
          }
          this.captureProgress += dt;

          if (this.captureProgress >= this.captureTime) {
            if (this.owner && this.owner !== agent) world.addEvent(agent.name + ' took point from ' + this.owner.name + '!', 'kill');
            this.owner = agent;
            this.capturer = null;
            this.captureProgress = 0;
            agent.controlPointCaptures++;
            world.addEvent(agent.name + ' captured point!', 'kill');
          }
          return;
        }

        // Nobody inside
        this.capturer = null;
        this.captureProgress = 0;
        if (this.owner && this.owner.alive) this.owner.controlPointSeconds += dt;
      }
    }

    // --------------------
    // Spatial hash (cheap nearest-neighbor acceleration)
    // --------------------
    class SpatialHash {
      constructor(cellSize) {
        this.cellSize = cellSize;
        this.map = new Map();
      }
      key(cx, cy) { return (cx << 16) ^ (cy & 0xffff); }
      cell(v) { return Math.floor(v / this.cellSize); }
      clear() { this.map.clear(); }
      insert(obj, x, y) {
        const cx = this.cell(x), cy = this.cell(y);
        const k = this.key(cx, cy);
        let arr = this.map.get(k);
        if (!arr) { arr = []; this.map.set(k, arr); }
        arr.push(obj);
      }
      query(x, y, radius) {
        const r = radius;
        const cs = this.cellSize;
        const minX = this.cell(x - r), maxX = this.cell(x + r);
        const minY = this.cell(y - r), maxY = this.cell(y + r);
        const out = [];
        for (let cx = minX; cx <= maxX; cx++) {
          for (let cy = minY; cy <= maxY; cy++) {
            const arr = this.map.get(this.key(cx, cy));
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    }

    // --------------------
    // Agent
    // --------------------
    // QUAKE MODE - Everyone gets a rocket launcher!
    const ROCKET = {
      damage: 90,          // Direct hit = almost one-shot
      splashRadius: 120,   // Big splash
      splashFalloff: 0.4,  // 40% damage at edge
      speed: 450,          // Fast enough to hit, slow enough to dodge
      fireRate: 4.0,        // 4 seconds between shots - makes each rocket count!
      selfDamage: true,    // Watch your feet!
      maxRange: 2000
    };

    class Agent {
      constructor(x, y, name, brain = null, team = 0) {
        this.x = x; this.y = y; this.name = name;
        this.team = team; // 0 = red, 1 = blue
        this.rotation = Math.random() * Math.PI * 2;
        this.vx = 0; this.vy = 0;

        this.health = 100; this.maxHealth = 100;
        this.armor = 0; this.maxArmor = 100; // 2 armor packs = 100
        this.stamina = 100; this.maxStamina = 100;

        this.alive = true;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        
        // Respawn system
        this.respawnTimer = 0;
        this.deaths = 0;

        // Weapon system
        this.weaponCooldown = 0;
        this.weapon = 'rocket'; // 'rocket', 'laser', or 'sword'
        this.laserCharge = 0; // 0-3 seconds
        this.laserCharging = false;
        
        // Sword mechanics
        this.swordCharge = 0; // 0-2 seconds max
        this.swordCharging = false;
        this.swordLunging = false;
        this.lungeStartX = 0;
        this.lungeStartY = 0;
        this.lungeEndX = 0;
        this.lungeEndY = 0;
        this.lungeProgress = 0;

        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.assists = 0;
        this.lastHitBy = null; // For assist tracking
        
        // Lifetime stats (persist across rounds)
        this.totalKills = 0;
        this.totalDeaths = 0;
        this.roundsPlayed = 0;

        // Network: 26 inputs ‚Üí 16 hidden ‚Üí 5 outputs
        // Inputs: 16 raycast + 10 state (health, cooldown, velocity, weapon type, etc)
        // Outputs: turn, move speed, shoot, strafe, dash
        this.brain = brain || new NeuralNetwork(26, 16, 5);

        // Track if agent has picked up a special weapon this round (can only pick up once)
        this.hasPickedUpWeapon = false;

        // Dodge ability
        this.dodgeCooldown = 0;
        this.isDodging = false;
        this.dodgeProgress = 0;
        this.dodgeStartX = 0;
        this.dodgeStartY = 0;
        this.dodgeEndX = 0;
        this.dodgeEndY = 0;

        this.radius = 16;
        this.color = team === 0 ? '#ff4444' : '#4488ff';
      }
      
      // Reset for new round but keep identity
      resetForRound() {
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        this.weapon = 'rocket';
        this.hasPickedUpWeapon = false; // Can pick up one special weapon per round
        this.dodgeCooldown = 0;
        this.isDodging = false;
        this.dodgeProgress = 0;
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;
        
        // Reset round stats but not lifetime stats
        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.deaths = 0;
        this.assists = 0;
        this.roundsPlayed++;
        
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
      }
      
      // Respawn after death
      respawn(world) {
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        this.weapon = 'rocket'; // Lose special weapons on death
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;
        
        // Spawn at back of team's side
        const clusterX = this.team === 0 ? 80 : world.width - 80;
        this.x = clusterX + (Math.random() - 0.5) * 100;
        this.y = world.height / 2 + (Math.random() - 0.5) * (world.height - 200);
        this.x = clamp(this.x, 40, world.width - 40);
        this.y = clamp(this.y, 40, world.height - 40);
        this.rotation = this.team === 0 ? 0 : Math.PI;
      }

      get score() {
        const killPoints = this.kills * 50;
        const assistPoints = this.assists * 25;
        const damagePoints = this.damageDealt;
        return killPoints + assistPoints + damagePoints - this.damageTaken;
      }

      castRays(world, numRays = 8, fov = Math.PI * 0.8) {
        const { agents, obstacles, width: worldWidth, height: worldHeight } = world;
        const rayData = [];

        const startAngle = this.rotation - fov / 2;
        const angleStep = fov / (numRays - 1);
        const maxDist = Math.hypot(worldWidth, worldHeight);

        // Check all alive agents for raycasts (full map visibility)
        const nearCandidates = agents.filter(a => a.alive && a !== this);

        for (let i = 0; i < numRays; i++) {
          const angle = startAngle + angleStep * i;
          let closestDist = maxDist;
          let closestType = 0;

          const edgeDist = this.raycastMapEdge(angle, worldWidth, worldHeight);
          if (edgeDist < closestDist) { closestDist = edgeDist; closestType = 0; }

          for (const obs of obstacles) {
            const dist = this.raycastRect(angle, closestDist, obs);
            if (dist < closestDist) { closestDist = dist; closestType = 0.5; }
          }

          for (const other of nearCandidates) {
            if (other === this || !other.alive) continue;
            const dist = this.raycastCircle(angle, closestDist, other.x, other.y, other.radius);
            if (dist < closestDist) { closestDist = dist; closestType = 1; }
          }

          rayData.push(closestDist / maxDist);
          rayData.push(closestType);
        }
        return rayData;
      }

      raycastMapEdge(angle, w, h) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = Infinity;
        if (dx < 0) { const t = -this.x / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dx > 0) { const t = (w - this.x) / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dy < 0) { const t = -this.y / dy; if (t > 0 && t < tMin) tMin = t; }
        if (dy > 0) { const t = (h - this.y) / dy; if (t > 0 && t < tMin) tMin = t; }
        return tMin;
      }

      raycastRect(angle, max, rect) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = 0, tMax = max;

        if (dx !== 0) {
          const t1 = (rect.x - this.x) / dx;
          const t2 = (rect.x + rect.w - this.x) / dx;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.x < rect.x || this.x > rect.x + rect.w) {
          return max;
        }

        if (dy !== 0) {
          const t1 = (rect.y - this.y) / dy;
          const t2 = (rect.y + rect.h - this.y) / dy;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.y < rect.y || this.y > rect.y + rect.h) {
          return max;
        }

        if (tMin <= tMax && tMin > 0) return tMin;
        return max;
      }

      raycastCircle(angle, max, cx, cy, r) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        const fx = this.x - cx, fy = this.y - cy;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - r * r;
        const d = b * b - 4 * a * c;
        if (d < 0) return max;
        const t = (-b - Math.sqrt(d)) / (2 * a);
        if (t > 0 && t < max) return t;
        return max;
      }

      think(world) {
        if (!this.alive) return null;

        const rayData = this.castRays(world);

        // Find nearest enemy
        let nearestEnemyDist = 1;
        let nearestEnemyAngle = 0;
        const enemies = world.agents.filter(a => a.alive && a.team !== this.team);
        for (const enemy of enemies) {
          const dx = enemy.x - this.x, dy = enemy.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 1000);
          if (nDist < nearestEnemyDist) {
            nearestEnemyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestEnemyAngle = a / Math.PI;
          }
        }

        // Find nearest ally (to avoid friendly fire)
        let nearestAllyDist = 1;
        let nearestAllyAngle = 0;
        const allies = world.agents.filter(a => a.alive && a.team === this.team && a !== this);
        for (const ally of allies) {
          const dx = ally.x - this.x, dy = ally.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 500);
          if (nDist < nearestAllyDist) {
            nearestAllyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestAllyAngle = a / Math.PI;
          }
        }

        const speedNorm = clamp(Math.hypot(this.vx, this.vy) / 200, 0, 1);
        const weaponReady = this.weaponCooldown <= 0 ? 1 : 0;
        const hasLaser = this.weapon === 'laser' ? 1 : 0;
        const hasSword = this.weapon === 'sword' ? 1 : 0;
        const dodgeReady = this.dodgeCooldown <= 0 ? 1 : 0;

        // Inputs: 26 total (16 rays + 10 internal)
        const internal = [
          this.health / this.maxHealth,
          speedNorm,
          weaponReady,
          nearestEnemyAngle,
          nearestEnemyDist,
          nearestAllyAngle,
          nearestAllyDist,
          this.team,
          hasLaser,
          hasSword
        ];

        const outputs = this.brain.forward(rayData.concat(internal));

        return {
          turnAmount: outputs[0],
          speedAmount: (outputs[1] + 1) / 2,
          wantsShoot: outputs[2] > 0,
          strafe: outputs[3],
          wantsDash: outputs[4] > 0
        };
      }

      update(decision, dt, world, obstacles) {
        if (!this.alive) return;

        this.attackCooldown = Math.max(0, this.attackCooldown - dt);
        this.attackRecovery = Math.max(0, this.attackRecovery - dt);
        this.weaponCooldown = Math.max(0, this.weaponCooldown - dt);
        this.dodgeCooldown = Math.max(0, this.dodgeCooldown - dt);

        // Handle sword lunge movement
        if (this.swordLunging) {
          // Scale lunge speed with distance (500 units/sec for consistent visual speed)
          const lungeSpeed = 500 / Math.max(50, this.lungeDist);
          this.lungeProgress += dt * lungeSpeed;
          if (this.lungeProgress >= 1) {
            this.swordLunging = false;
            this.x = this.lungeEndX;
            this.y = this.lungeEndY;
            this.weaponCooldown = 1.0; // 1 second cooldown after lunge
          } else {
            // Interpolate position
            this.x = this.lungeStartX + (this.lungeEndX - this.lungeStartX) * this.lungeProgress;
            this.y = this.lungeStartY + (this.lungeEndY - this.lungeStartY) * this.lungeProgress;
          }
          return; // Skip normal movement during lunge
        }

        // Handle dodge movement animation
        if (this.isDodging) {
          const dodgeSpeed = 8; // Complete dodge in ~0.125 seconds
          this.dodgeProgress += dt * dodgeSpeed;

          // Ease out for smooth deceleration
          const easedProgress = 1 - Math.pow(1 - Math.min(1, this.dodgeProgress), 2);

          if (this.dodgeProgress >= 1) {
            this.isDodging = false;
            this.x = this.dodgeEndX;
            this.y = this.dodgeEndY;
          } else {
            // Interpolate position with easing
            this.x = this.dodgeStartX + (this.dodgeEndX - this.dodgeStartX) * easedProgress;
            this.y = this.dodgeStartY + (this.dodgeEndY - this.dodgeStartY) * easedProgress;
          }
          return; // Skip normal movement during dodge
        }

        if (!decision) return;

        // Trigger dodge/dash (if enabled in world)
        if (decision.wantsDash && this.dodgeCooldown <= 0 && world.dodgingEnabled && !this.isDodging) {
          const dashDistance = 70; // Short dash distance

          // Dash in movement direction, or facing direction if not moving
          let dashAngle;
          const moveX = Math.cos(this.rotation) * decision.speedAmount + Math.cos(this.rotation + Math.PI/2) * (decision.strafe || 0);
          const moveY = Math.sin(this.rotation) * decision.speedAmount + Math.sin(this.rotation + Math.PI/2) * (decision.strafe || 0);
          const moveMag = Math.hypot(moveX, moveY);

          if (moveMag > 0.1) {
            dashAngle = Math.atan2(moveY, moveX);
          } else {
            dashAngle = this.rotation; // Dash forward if not moving
          }

          // Calculate new position
          let newX = this.x + Math.cos(dashAngle) * dashDistance;
          let newY = this.y + Math.sin(dashAngle) * dashDistance;

          // Clamp to world bounds
          newX = clamp(newX, this.radius, world.width - this.radius);
          newY = clamp(newY, this.radius, world.height - this.radius);

          // Check obstacle collision and adjust
          for (const obs of obstacles) {
            const col = this.checkRectCollision(newX, newY, obs);
            if (col) { newX = col.x; newY = col.y; }
          }

          // Set up dodge animation
          this.dodgeStartX = this.x;
          this.dodgeStartY = this.y;
          this.dodgeEndX = newX;
          this.dodgeEndY = newY;
          this.dodgeProgress = 0;
          this.isDodging = true;
          this.dodgeCooldown = 6.0; // 6 second cooldown

          // Add dodge trail effect
          world.dodgeTrails.push({
            startX: this.x,
            startY: this.y,
            endX: newX,
            endY: newY,
            team: this.team,
            timer: 0,
            maxTime: 0.3
          });
        }

        this.rotation += decision.turnAmount * 4 * dt; // Faster turning for dodging

        // Forward/backward movement
        let targetSpeed = decision.speedAmount * 150; // Faster base speed

        // 2x movement speed while holding sword (not charging)
        if (this.weapon === 'sword' && !this.swordCharging) {
          targetSpeed *= 2;
        }

        // 50% movement speed while charging laser
        if (this.laserCharging) {
          targetSpeed *= 0.5;
        }

        // 80% movement slow while charging sword (20% speed)
        if (this.swordCharging) {
          targetSpeed *= 0.2;
        }

        // Strafing (perpendicular movement)
        let strafeSpeed = (decision.strafe || 0) * 100;

        // 2x strafe speed while holding sword (not charging)
        if (this.weapon === 'sword' && !this.swordCharging) {
          strafeSpeed *= 2;
        }

        if (this.laserCharging) {
          strafeSpeed *= 0.5;
        }
        if (this.swordCharging) {
          strafeSpeed *= 0.2;
        }

        const tvx = Math.cos(this.rotation) * targetSpeed + Math.cos(this.rotation + Math.PI/2) * strafeSpeed;
        const tvy = Math.sin(this.rotation) * targetSpeed + Math.sin(this.rotation + Math.PI/2) * strafeSpeed;
        
        const lerp = Math.min(1, 8 * dt); // Snappier movement
        this.vx += (tvx - this.vx) * lerp;
        this.vy += (tvy - this.vy) * lerp;

        let nx = this.x + this.vx * dt;
        let ny = this.y + this.vy * dt;

        for (const obs of obstacles) {
          const col = this.checkRectCollision(nx, ny, obs);
          if (col) { nx = col.x; ny = col.y; }
        }

        this.x = clamp(nx, this.radius, world.width - this.radius);
        this.y = clamp(ny, this.radius, world.height - this.radius);
      }

      // Shoot rocket!
      tryShoot(world) {
        if (!this.alive || this.weaponCooldown > 0) return null;

        this.weaponCooldown = ROCKET.fireRate;

        // Rocket spawns from right shoulder position
        const shoulderOffset = this.radius * 0.7;
        const perpX = Math.cos(this.rotation - Math.PI / 2) * shoulderOffset; // right side
        const perpY = Math.sin(this.rotation - Math.PI / 2) * shoulderOffset;
        const forwardX = Math.cos(this.rotation) * (this.radius * 1.7);
        const forwardY = Math.sin(this.rotation) * (this.radius * 1.7);

        return {
          type: 'rocket',
          x: this.x + perpX + forwardX,
          y: this.y + perpY + forwardY,
          angle: this.rotation,
          owner: this,
          damage: ROCKET.damage,
          splashRadius: ROCKET.splashRadius,
          splashFalloff: ROCKET.splashFalloff,
          speed: ROCKET.speed,
          range: ROCKET.maxRange,
          traveled: 0,
          alive: true
        };
      }

      checkRectCollision(newX, newY, rect) {
        const cx = Math.max(rect.x, Math.min(newX, rect.x + rect.w));
        const cy = Math.max(rect.y, Math.min(newY, rect.y + rect.h));
        const dx = newX - cx, dy = newY - cy;
        const dist = Math.hypot(dx, dy);
        if (dist < this.radius) {
          const ov = this.radius - dist;
          if (dist > 0) return { x: newX + (dx / dist) * ov, y: newY + (dy / dist) * ov };
          return { x: newX + this.radius, y: newY };
        }
        return null;
      }

      tryAttack(agents, world) {
        // No melee in Quake mode - rockets only!
        return null;
      }

      takeDamage(amount, attacker, world) {
        // Armor absorbs damage first
        if (this.armor > 0) {
          const armorDamage = Math.min(this.armor, amount);
          this.armor -= armorDamage;
          amount -= armorDamage;
        }
        
        this.health -= amount;
        this.damageTaken += amount;

        // Track who hit us for assists
        if (attacker && attacker !== this.lastHitBy) {
          if (this.lastHitBy && this.health <= 0 && this.lastHitBy !== attacker) {
            this.lastHitBy.assists++;
          }
          this.lastHitBy = attacker;
        }

        if (this.health > 0) return false;

        // Death
        this.alive = false;
        this.deaths++;
        this.totalDeaths++;
        this.respawnTimer = world ? world.respawnTime : 3; // Use world's respawn time

        // Drop special weapon on death
        if (world && (this.weapon === 'laser' || this.weapon === 'sword')) {
          world.dropWeapon(this.x, this.y, this.weapon);
        }

        return true;
      }

      clone(newName, team) {
        const child = new Agent(this.x, this.y, newName, this.brain.clone(), team);
        return child;
      }
    }

    // --------------------
    // World
    // --------------------
    class World {
      constructor(width, height) {
        this.width = width;
        this.height = height;

        this.agents = [];
        this.obstacles = [];
        this.buildings = [];

        // Projectiles - ROCKETS ONLY in Quake mode
        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = []; // Smoke trail particles

        // Pickups
        this.pickups = [];
        this.pickupTimer = 0;
        this.pickupInterval = 20; // Spawn every 20 seconds
        this.nextPickupType = 'health'; // Alternates between health and armor
        this.healthSpawnsEnabled = true;
        this.armorSpawnsEnabled = true;

        // Pit spawn locations (enclosed areas for health/armor)
        this.pickupPits = [];
        
        // Laser spawns
        this.laserSpawnsEnabled = true;
        this.laserSpawned = false; // Only spawn once per round
        this.laserBeams = []; // Active laser beam animations
        
        // Sword spawns
        this.swordSpawnsEnabled = true;
        this.swordSpawned = false;
        this.swordSlashes = []; // Active sword slash animations

        // Dropped weapons (laser/sword dropped on death or weapon swap)
        this.droppedWeapons = [];

        // Dodge trail animations
        this.dodgeTrails = [];

        this.roundTime = 180; // 3 minutes
        this.timeLeft = this.roundTime;

        this.usedNames = new Set();
        this.generation = 1;
        this.events = [];
        this.paused = false;

        this.population = 100; // 50 per team
        this.aliveCount = 0;
        
        // Team Deathmatch specific
        this.teamKills = [0, 0]; // [red kills, blue kills] - NET score (kills - ricochets)
        this.teamRawKills = [0, 0]; // Actual enemy kills
        this.teamRicochets = [0, 0]; // Friendly fire incidents
        this.killLimit = 20;
        this.winningTeam = null;
        this.teamWins = [0, 0]; // Track total wins per team
        
        // Game modifiers
        this.friendlyFire = false;
        this.friendlyFireRicochet = false;
        this.dodgingEnabled = true; // Agents can dash/dodge
        this.respawnTime = 3; // seconds
        
        // Team brains (evolved separately)
        this.teamBrains = [null, null];

        this.spatialAgents = new SpatialHash(120);

        this.generateObstacles();
      }

      spawnLaserPickups() {
        if (this.laserSpawned || !this.laserSpawnsEnabled) return;

        // Spawn 10 lasers in a circle at map center (risk/reward)
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = 200; // Circle radius

        for (let i = 0; i < 10; i++) {
          // Offset angle so lasers alternate with swords
          const angle = (i / 10) * Math.PI * 2 + Math.PI / 20;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          this.pickups.push({
            x: x,
            y: y,
            type: 'laser',
            radius: 18
          });
        }

        this.laserSpawned = true;
        this.addEvent('‚ö° LASER WEAPONS SPAWNED AT CENTER!', 'laser');
      }

      spawnSwordPickups() {
        if (this.swordSpawned || !this.swordSpawnsEnabled) return;

        // Spawn 10 swords in a circle at map center (risk/reward)
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = 200; // Circle radius

        for (let i = 0; i < 10; i++) {
          // Offset angle so swords alternate with lasers
          const angle = (i / 10) * Math.PI * 2 - Math.PI / 20;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          this.pickups.push({
            x: x,
            y: y,
            type: 'sword',
            radius: 18
          });
        }

        this.swordSpawned = true;
        this.addEvent('üó°Ô∏è ENERGY SWORDS SPAWNED AT CENTER!', 'sword');
      }

      spawnPickupInPit(pit) {
        // Check if this type is enabled
        if (pit.type === 'health' && !this.healthSpawnsEnabled) return false;
        if (pit.type === 'armor' && !this.armorSpawnsEnabled) return false;

        // Spawn pickup at pit center
        this.pickups.push({
          x: pit.x,
          y: pit.y,
          type: pit.type,
          radius: 18,
          pitRef: pit
        });

        pit.hasPickup = true;
        pit.respawnTimer = 0;
        pit.respawnTime = 0;

        const icon = pit.type === 'health' ? 'ü©π' : 'üõ°Ô∏è';
        this.addEvent(icon + ' ' + pit.type.toUpperCase() + ' spawned in pit!', 'pickup');
        return true;
      }

      spawnPickups() {
        // Spawn pickups in all empty pits (used at round start)
        for (const pit of this.pickupPits) {
          if (!pit.hasPickup) {
            this.spawnPickupInPit(pit);
          }
        }
      }

      updatePitTimers(dt) {
        // Update per-pit respawn timers (Roshan-style random respawn)
        for (const pit of this.pickupPits) {
          if (pit.hasPickup) continue; // Pit has a pickup, no timer needed
          if (pit.respawnTime <= 0) continue; // No respawn scheduled

          pit.respawnTimer += dt;
          if (pit.respawnTimer >= pit.respawnTime) {
            this.spawnPickupInPit(pit);
          }
        }
      }

      // Set random respawn time when pickup is collected (15-25 seconds window)
      schedulePitRespawn(pit) {
        const baseTime = 20; // Base respawn time
        const variance = 5;  // +/- 5 seconds
        pit.respawnTime = baseTime + (Math.random() * 2 - 1) * variance; // 15-25 seconds
        pit.respawnTimer = 0;
      }

      fireLaser(agent) {
        // Calculate beam endpoint (extends to world edge)
        const angle = agent.rotation;
        const startX = agent.x + Math.cos(angle) * agent.radius;
        const startY = agent.y + Math.sin(angle) * agent.radius;
        
        // Find where beam exits world
        let endX, endY;
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        
        // Calculate intersection with world boundaries
        const tRight = cosA > 0 ? (this.width - startX) / cosA : Infinity;
        const tLeft = cosA < 0 ? -startX / cosA : Infinity;
        const tBottom = sinA > 0 ? (this.height - startY) / sinA : Infinity;
        const tTop = sinA < 0 ? -startY / sinA : Infinity;
        
        const t = Math.min(tRight, tLeft, tBottom, tTop);
        endX = startX + cosA * t;
        endY = startY + sinA * t;
        
        // Check for hits on all agents in beam path
        let killCount = 0;
        for (const target of this.agents) {
          if (target === agent || !target.alive) continue;
          
          // Skip teammates unless FF is on
          if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;
          
          // Point-to-line distance check
          const dx = endX - startX;
          const dy = endY - startY;
          const len = Math.hypot(dx, dy);
          const nx = -dy / len;
          const ny = dx / len;
          
          const px = target.x - startX;
          const py = target.y - startY;
          const dist = Math.abs(px * nx + py * ny);
          
          // Also check if target is in front of shooter
          const dot = px * (dx / len) + py * (dy / len);
          
          if (dist < target.radius + 10 && dot > 0) {
            // Hit!
            if (target.team === agent.team) {
              // Friendly fire
              if (this.friendlyFireRicochet) {
                // Ricochet damage to self
                const killed = agent.takeDamage(999, agent, this);
                this.teamRicochets[agent.team]++;
                if (killed) {
                  this.addEvent('üîÑ ' + agent.name + ' LASER RICOCHET!', 'laser');
                }
              } else if (this.friendlyFire) {
                const killed = target.takeDamage(999, agent, this);
                if (killed) {
                  this.teamRicochets[agent.team]++;
                  this.addEvent('‚ö° ' + agent.name + ' TEAMKILLED ' + target.name + '!', 'laser');
                }
              }
            } else {
              // Enemy kill
              const killed = target.takeDamage(999, agent, this);
              if (killed) {
                agent.kills++;
                agent.totalKills++;
                this.teamKills[agent.team]++;
                this.teamRawKills[agent.team]++;
                killCount++;
              }
            }
          }
        }
        
        if (killCount > 0) {
          const msg = killCount > 1 
            ? '‚ö° ' + agent.name + ' LASER MULTI-KILL x' + killCount + '!'
            : '‚ö° ' + agent.name + ' LASER KILL!';
          this.addEvent(msg, 'laser');
        }
        
        // Add beam animation
        this.laserBeams.push({
          startX, startY, endX, endY,
          team: agent.team,
          timer: 0,
          maxTime: 1.5
        });
      }

      executeSwordLunge(agent, chargeTime) {
        // Calculate lunge distance based on charge time (0.5s min charge, 2s max)
        const minDist = 50;
        const maxDist = 500; // Doubled range for longer lunges
        const chargeRatio = Math.min(1, Math.max(0, (chargeTime - 0.3) / 1.7)); // 0.3s to 2s
        const lungeDist = minDist + chargeRatio * (maxDist - minDist);
        
        const startX = agent.x;
        const startY = agent.y;
        const endX = agent.x + Math.cos(agent.rotation) * lungeDist;
        const endY = agent.y + Math.sin(agent.rotation) * lungeDist;
        
        // Clamp to world bounds
        const clampedEndX = clamp(endX, agent.radius, this.width - agent.radius);
        const clampedEndY = clamp(endY, agent.radius, this.height - agent.radius);
        
        // Set up lunge
        agent.lungeStartX = startX;
        agent.lungeStartY = startY;
        agent.lungeEndX = clampedEndX;
        agent.lungeEndY = clampedEndY;
        agent.lungeProgress = 0;
        agent.lungeDist = Math.hypot(clampedEndX - startX, clampedEndY - startY);
        agent.swordLunging = true;
        
        // Check for hits along the lunge path
        let killCount = 0;
        for (const target of this.agents) {
          if (target === agent || !target.alive) continue;
          
          // Skip teammates unless FF is on
          if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;
          
          // Point-to-line distance check
          const dx = clampedEndX - startX;
          const dy = clampedEndY - startY;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;
          
          const nx = -dy / len;
          const ny = dx / len;
          
          const px = target.x - startX;
          const py = target.y - startY;
          const dist = Math.abs(px * nx + py * ny);
          
          // Check if target is along the path
          const dot = px * (dx / len) + py * (dy / len);
          
          if (dist < target.radius + 20 && dot > 0 && dot < len) {
            // Hit!
            if (target.team === agent.team) {
              if (this.friendlyFireRicochet) {
                const killed = agent.takeDamage(999, agent, this);
                this.teamRicochets[agent.team]++;
                if (killed) {
                  this.addEvent('üîÑ ' + agent.name + ' SWORD RICOCHET!', 'sword');
                }
              } else if (this.friendlyFire) {
                const killed = target.takeDamage(999, agent, this);
                if (killed) {
                  this.teamRicochets[agent.team]++;
                  this.addEvent('üó°Ô∏è ' + agent.name + ' TEAMKILLED ' + target.name + '!', 'sword');
                }
              }
            } else {
              const killed = target.takeDamage(999, agent, this);
              if (killed) {
                agent.kills++;
                agent.totalKills++;
                this.teamKills[agent.team]++;
                this.teamRawKills[agent.team]++;
                killCount++;
              }
            }
          }
        }
        
        if (killCount > 0) {
          const msg = killCount > 1 
            ? 'üó°Ô∏è ' + agent.name + ' SWORD MULTI-KILL x' + killCount + '!'
            : 'üó°Ô∏è ' + agent.name + ' SWORD KILL!';
          this.addEvent(msg, 'sword');
        }
        
        // Add slash animation (scale duration with distance)
        // Sword is held to the right side - calculate perpendicular offset
        const perpX = Math.cos(agent.rotation + Math.PI / 2); // perpendicular right
        const perpY = Math.sin(agent.rotation + Math.PI / 2);
        const bladeLength = agent.radius * 1.7; // blade from r*0.5 to r*2.2
        const swordOffset = agent.radius * 1.35; // center of blade (avg of 0.5 and 2.2)

        const actualDist = Math.hypot(clampedEndX - startX, clampedEndY - startY);
        const slashDuration = 0.3 + (actualDist / 500) * 0.7; // 0.3s base + up to 0.7s for max range (500 units)
        this.swordSlashes.push({
          // Trail follows the sword position (offset to the right of agent path)
          startX: startX + perpX * swordOffset,
          startY: startY + perpY * swordOffset,
          endX: clampedEndX + perpX * swordOffset,
          endY: clampedEndY + perpY * swordOffset,
          bladeLength: bladeLength, // trail width = blade length
          team: agent.team,
          timer: 0,
          maxTime: slashDuration
        });
      }

      setRoundTimeSeconds(sec) {
        this.roundTime = Math.max(10, sec);
        this.timeLeft = Math.min(this.timeLeft, this.roundTime);
      }

      generateObstacles() {
        this.obstacles = [];
        this.buildings = [];

        const bTypes = [
          { w: 100, h: 100 },
          { w: 150, h: 100 },
          { w: 80, h: 80 },
          { w: 120, h: 60 },
          { w: 60, h: 120 },
        ];

        // =====================
        // RESERVE PIT AREAS FIRST - prevent other obstacles from spawning here
        // =====================
        const pitSize = 100;
        const pitMargin = 60; // Extra space around pits
        const pitOffsetX = this.width * 0.2;
        const pitOffsetY = 300;

        // Store pit center locations for later
        this.pitLocations = [
          { x: pitOffsetX, y: pitOffsetY },
          { x: pitOffsetX, y: this.height - pitOffsetY },
          { x: this.width - pitOffsetX, y: pitOffsetY },
          { x: this.width - pitOffsetX, y: this.height - pitOffsetY }
        ];

        // Add temporary reservations (will be replaced by actual pit walls)
        const pitReservations = [];
        for (const loc of this.pitLocations) {
          const reservation = {
            x: loc.x - pitSize/2 - pitMargin,
            y: loc.y - pitSize/2 - pitMargin,
            w: pitSize + pitMargin * 2,
            h: pitSize + pitMargin * 2,
            isReservation: true
          };
          pitReservations.push(reservation);
          this.obstacles.push(reservation);
        }

        const overlaps = (x, y, w, h, margin = 30) => {
          for (const o of this.obstacles) {
            if (x < o.x + o.w + margin && x + w > o.x - margin &&
                y < o.y + o.h + margin && y + h > o.y - margin) return true;
          }
          return false;
        };

        const addBuilding = (x, y, w, h) => {
          if (!overlaps(x, y, w, h)) {
            this.buildings.push({ x, y, w, h });
            this.obstacles.push({ x, y, w, h });
            return true;
          }
          return false;
        };

        // =====================
        // SPAWN AREA COVER - Heavy protection near spawns
        // =====================
        
        // Red spawn cover (left side, x: 100-500)
        for (let i = 0; i < 8; i++) {
          const x = 120 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue spawn cover (right side, x: width-500 to width-100)
        for (let i = 0; i < 8; i++) {
          const x = this.width - 470 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // MID TRANSITION - Some cover between spawn and open middle
        // =====================
        
        // Red side transition (x: 500-800)
        for (let i = 0; i < 4; i++) {
          const x = 500 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue side transition (x: width-800 to width-500)
        for (let i = 0; i < 4; i++) {
          const x = this.width - 750 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // OPEN MIDDLE - Very sparse, just a few small covers
        // =====================
        
        // Only 2-3 small obstacles in the center zone (x: 900-1500)
        for (let i = 0; i < 3; i++) {
          const x = 950 + Math.random() * 500;
          const y = 300 + Math.random() * (this.height - 600);
          addBuilding(x, y, 60, 60); // Small cover only
        }

        // =====================
        // EDGE LANES - Cover along top and bottom for flanking
        // =====================
        
        // Top lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, 80 + Math.random() * 60, 80, 80);
        }
        
        // Bottom lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, this.height - 160 + Math.random() * 60, 80, 80);
        }

        // =====================
        // PICKUP PITS - Enclosed areas for health/armor (like Roshan pit)
        // =====================
        // Remove temporary reservations (keep only non-reservation obstacles)
        this.obstacles = this.obstacles.filter(o => !o.isReservation);

        this.pickupPits = [];
        const wallThick = 20;

        // Helper to create a pit with 3 walls (U-shape), opening facing outward (toward walls)
        const createPit = (cx, cy, openingDir, type) => {
          // openingDir: 'up', 'down' (which way the entrance faces - toward the wall)
          const walls = [];

          if (openingDir === 'down') {
            // Opening faces down (toward bottom wall)
            // Back wall (top)
            walls.push({ x: cx - pitSize/2, y: cy - pitSize/2 - wallThick, w: pitSize, h: wallThick });
            // Left wall
            walls.push({ x: cx - pitSize/2 - wallThick, y: cy - pitSize/2 - wallThick, w: wallThick, h: pitSize + wallThick });
            // Right wall
            walls.push({ x: cx + pitSize/2, y: cy - pitSize/2 - wallThick, w: wallThick, h: pitSize + wallThick });
          } else if (openingDir === 'up') {
            // Opening faces up (toward top wall)
            // Back wall (bottom)
            walls.push({ x: cx - pitSize/2, y: cy + pitSize/2, w: pitSize, h: wallThick });
            // Left wall
            walls.push({ x: cx - pitSize/2 - wallThick, y: cy - pitSize/2, w: wallThick, h: pitSize + wallThick });
            // Right wall
            walls.push({ x: cx + pitSize/2, y: cy - pitSize/2, w: wallThick, h: pitSize + wallThick });
          }

          // Add walls to obstacles
          for (const w of walls) {
            this.obstacles.push(w);
            this.buildings.push(w);
          }

          // Store pit info for spawning with random respawn timer
          this.pickupPits.push({
            x: cx, y: cy,
            type: type, // 'health' or 'armor'
            hasPickup: false,
            respawnTimer: 0,
            respawnTime: 0 // Will be set when pickup is taken
          });
        };

        // 4 pits - using stored locations from reservation phase
        // Top-left area: health pit (opening faces UP toward wall)
        createPit(pitOffsetX, pitOffsetY, 'up', 'health');

        // Bottom-left area: armor pit (opening faces DOWN toward wall)
        createPit(pitOffsetX, this.height - pitOffsetY, 'down', 'armor');

        // Top-right area: armor pit (opening faces UP toward wall)
        createPit(this.width - pitOffsetX, pitOffsetY, 'up', 'armor');

        // Bottom-right area: health pit (opening faces DOWN toward wall)
        createPit(this.width - pitOffsetX, this.height - pitOffsetY, 'down', 'health');
      }

      generateUniqueName() {
        let n;
        let att = 0;
        do {
          n = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)] + ' ' + LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
          if (this.usedNames.has(n)) {
            let s = 2;
            while (this.usedNames.has(n + ' (' + s + ')')) s++;
            n = n + ' (' + s + ')';
          }
          att++;
        } while (this.usedNames.has(n) && att < 100);
        this.usedNames.add(n);
        return n;
      }

      spawnAgents(count) {
        this.population = count;
        this.agents = [];
        this.usedNames.clear();

        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = [];

        // Reset pickups and weapon state
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        this.droppedWeapons = [];
        this.dodgeTrails = [];

        // Reset pit spawn flags and timers, then spawn initial pickups
        for (const pit of this.pickupPits) {
          pit.hasPickup = false;
          pit.respawnTimer = 0;
          pit.respawnTime = 0;
        }
        this.spawnPickups(); // Spawn initial pickups in all pits

        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.winningTeam = null;

        const perTeam = Math.floor(count / 2);

        // Create persistent soldiers for each team
        for (let team = 0; team < 2; team++) {
          const clusterX = team === 0 ? 80 : this.width - 80;
          const clusterY = this.height / 2;

          for (let i = 0; i < perTeam; i++) {
            let x = clusterX + (Math.random() - 0.5) * 150;
            let y = clusterY + (Math.random() - 0.5) * (this.height - 200);
            x = clamp(x, 40, this.width - 40);
            y = clamp(y, 40, this.height - 40);

            const brain = this.teamBrains[team]?.clone() || null;
            const agent = new Agent(x, y, this.generateUniqueName(), brain, team);
            agent.rotation = team === 0 ? 0 : Math.PI;

            if (this.teamBrains[team] && i > 0) {
              agent.brain.mutate(0.1, 0.3);
            }

            this.agents.push(agent);
          }
        }

        this.timeLeft = this.roundTime;

        // Spawn weapons at round start
        this.spawnLaserPickups();
        this.spawnSwordPickups();
      }

      spawnNextRound() {
        // Sort each team by score
        const redAgents = this.agents.filter(a => a.team === 0);
        const blueAgents = this.agents.filter(a => a.team === 1);
        
        redAgents.sort((a, b) => b.score - a.score);
        blueAgents.sort((a, b) => b.score - a.score);
        
        // Brain transfer: EVERYONE below top 10% gets a clone of a top performer
        const transferBrains = (agents) => {
          if (agents.length === 0) return;
          
          const top10pct = Math.max(1, Math.floor(agents.length * 0.1)); // Top 5 agents
          const top10Brains = agents.slice(0, top10pct).map(a => a.brain.clone());
          
          // Top 10% - keep their brains, tiny mutation to explore
          for (let i = 0; i < top10pct; i++) {
            agents[i].brain.mutate(0.02, 0.1);
          }
          
          // Everyone else gets a random top performer's brain with mutation
          for (let i = top10pct; i < agents.length; i++) {
            const parentBrain = top10Brains[Math.floor(Math.random() * top10Brains.length)];
            agents[i].brain = parentBrain.clone();
            
            // More mutation the worse they performed
            const performanceRatio = i / agents.length; // 0.1 to 1.0
            const mutationRate = 0.1 + performanceRatio * 0.2; // 0.1 to 0.3
            const mutationStrength = 0.2 + performanceRatio * 0.4; // 0.2 to 0.6
            agents[i].brain.mutate(mutationRate, mutationStrength);
          }
        };
        
        transferBrains(redAgents);
        transferBrains(blueAgents);
        
        // Update team brains to best performer
        if (redAgents[0]) this.teamBrains[0] = redAgents[0].brain.clone();
        if (blueAgents[0]) this.teamBrains[1] = blueAgents[0].brain.clone();
        
        // Reset round state
        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.winningTeam = null;
        this.timeLeft = this.roundTime;
        this.generateObstacles();

        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = [];
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        this.droppedWeapons = []; // Weapons dropped by dead players or weapon swaps
        this.dodgeTrails = [];

        // Reset pit spawn flags and timers, then spawn initial pickups
        for (const pit of this.pickupPits) {
          pit.hasPickup = false;
          pit.respawnTimer = 0;
          pit.respawnTime = 0;
        }
        this.spawnPickups(); // Spawn initial pickups in all pits

        // Reset all agents for new round (but keep names and lifetime stats)
        for (const agent of this.agents) {
          const clusterX = agent.team === 0 ? 80 : this.width - 80;
          agent.x = clusterX + (Math.random() - 0.5) * 150;
          agent.y = this.height / 2 + (Math.random() - 0.5) * (this.height - 200);
          agent.x = clamp(agent.x, 40, this.width - 40);
          agent.y = clamp(agent.y, 40, this.height - 40);
          agent.rotation = agent.team === 0 ? 0 : Math.PI;
          agent.resetForRound();
        }

        // Spawn weapons at round start (near team spawns)
        this.spawnLaserPickups();
        this.spawnSwordPickups();
      }

      // Keep for compatibility
      spawnFromParents(parents, total) {
        this.spawnNextRound();
      }

      rebuildSpatial() {
        this.spatialAgents.clear();
        for (const a of this.agents) if (a.alive) this.spatialAgents.insert(a, a.x, a.y);
      }

      update(dt) {
        if (this.paused) return;

        this.timeLeft -= dt;

        // Pickup spawning (health/armor only - weapons spawn at round start)
        // Update per-pit respawn timers (Roshan-style random respawn)
        this.updatePitTimers(dt);

        // Pickup collection
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            const dist = Math.hypot(agent.x - p.x, agent.y - p.y);
            
            if (dist < agent.radius + p.radius) {
              // Collect pickup
              if (p.type === 'health') {
                const healed = Math.min(50, agent.maxHealth - agent.health);
                agent.health = Math.min(agent.maxHealth, agent.health + 50);
                if (healed > 0) {
                  this.addEvent('ü©π ' + agent.name + ' +' + healed + 'hp', 'pickup');
                }
                // Schedule random respawn for this pit
                if (p.pitRef) {
                  p.pitRef.hasPickup = false;
                  this.schedulePitRespawn(p.pitRef);
                }
                this.pickups.splice(i, 1);
              } else if (p.type === 'armor') {
                if (agent.armor < agent.maxArmor) {
                  const gained = Math.min(50, agent.maxArmor - agent.armor);
                  agent.armor = Math.min(agent.maxArmor, agent.armor + 50);
                  this.addEvent('üõ°Ô∏è ' + agent.name + ' +' + gained + ' armor', 'pickup');
                  // Schedule random respawn for this pit
                  if (p.pitRef) {
                    p.pitRef.hasPickup = false;
                    this.schedulePitRespawn(p.pitRef);
                  }
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'laser') {
                // Auto pickup on walk-over, but only once per round
                if (!agent.hasPickedUpWeapon) {
                  agent.weapon = 'laser';
                  agent.laserCharge = 0;
                  agent.weaponCooldown = 0;
                  agent.hasPickedUpWeapon = true;
                  this.addEvent('‚ö° ' + agent.name + ' GOT THE LASER!', 'laser');
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'sword') {
                // Auto pickup on walk-over, but only once per round
                if (!agent.hasPickedUpWeapon) {
                  agent.weapon = 'sword';
                  agent.swordCharge = 0;
                  agent.swordCharging = false;
                  agent.weaponCooldown = 0;
                  agent.hasPickedUpWeapon = true;
                  this.addEvent('üó°Ô∏è ' + agent.name + ' GOT THE ENERGY SWORD!', 'sword');
                  this.pickups.splice(i, 1);
                }
              }
            }
          }
        }

        // Check for dropped weapon pickups (auto pickup, but only once per round)
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          // Only pick up if agent hasn't picked up a weapon this round
          if (agent.hasPickedUpWeapon) continue;

          for (let i = this.droppedWeapons.length - 1; i >= 0; i--) {
            const w = this.droppedWeapons[i];
            const dx = agent.x - w.x;
            const dy = agent.y - w.y;
            if (dx * dx + dy * dy < (agent.radius + w.radius) * (agent.radius + w.radius)) {
              if (w.type === 'laser') {
                agent.weapon = 'laser';
                agent.laserCharge = 0;
                agent.weaponCooldown = 0;
                agent.hasPickedUpWeapon = true;
                this.addEvent('‚ö° ' + agent.name + ' PICKED UP DROPPED LASER!', 'laser');
                this.droppedWeapons.splice(i, 1);
              } else if (w.type === 'sword') {
                agent.weapon = 'sword';
                agent.swordCharge = 0;
                agent.swordCharging = false;
                agent.weaponCooldown = 0;
                agent.hasPickedUpWeapon = true;
                this.addEvent('üó°Ô∏è ' + agent.name + ' PICKED UP DROPPED SWORD!', 'sword');
                this.droppedWeapons.splice(i, 1);
              }
            }
          }
        }

        // Update alive count + spatial hash
        let alive = 0;
        for (const a of this.agents) if (a.alive) alive++;
        this.aliveCount = alive;
        this.rebuildSpatial();
        
        // Handle respawns
        for (const agent of this.agents) {
          if (!agent.alive && agent.respawnTimer > 0) {
            agent.respawnTimer -= dt;
            if (agent.respawnTimer <= 0) {
              agent.respawn(this);
              this.addEvent('üîÑ ' + agent.name + ' respawned', 'damage');
            }
          }
        }

        // Update rockets
        for (const r of this.rockets) {
          if (!r.alive) continue;
          
          // Move rocket
          r.x += Math.cos(r.angle) * r.speed * dt;
          r.y += Math.sin(r.angle) * r.speed * dt;
          r.traveled += r.speed * dt;
          
          // Spawn smoke particles behind rocket
          r.smokeTimer = (r.smokeTimer || 0) + dt;
          if (r.smokeTimer > 0.02) { // Every 20ms
            r.smokeTimer = 0;
            this.smokeParticles.push({
              x: r.x - Math.cos(r.angle) * 15,
              y: r.y - Math.sin(r.angle) * 15,
              vx: (Math.random() - 0.5) * 30,
              vy: (Math.random() - 0.5) * 30,
              life: 0.4, // 400ms lifetime
              maxLife: 0.4,
              size: 8 + Math.random() * 6
            });
          }
          
          let explode = false;
          let explodeX = r.x;
          let explodeY = r.y;
          
          // Check range
          if (r.traveled >= r.range) {
            explode = true;
          }
          
          // Check wall collision
          if (r.x < 0 || r.x > this.width || r.y < 0 || r.y > this.height) {
            explode = true;
            explodeX = clamp(r.x, 0, this.width);
            explodeY = clamp(r.y, 0, this.height);
          }
          
          // Check obstacle collision
          if (!explode) {
            for (const obs of this.obstacles) {
              if (r.x >= obs.x && r.x <= obs.x + obs.w && r.y >= obs.y && r.y <= obs.y + obs.h) {
                explode = true;
                break;
              }
            }
          }
          
          // Check agent collision (direct hit)
          if (!explode) {
            for (const agent of this.agents) {
              if (agent === r.owner || !agent.alive) continue;
              if (Math.hypot(r.x - agent.x, r.y - agent.y) < agent.radius + 8) {
                explode = true;
                explodeX = agent.x;
                explodeY = agent.y;
                break;
              }
            }
          }
          
          // Create explosion
          if (explode) {
            r.alive = false;
            this.explosions.push({
              x: explodeX, y: explodeY, 
              owner: r.owner, 
              damage: r.damage,
              splashRadius: r.splashRadius,
              splashFalloff: r.splashFalloff,
              timer: 0, 
              maxTime: 0.4, 
              dealtDamage: false
            });
          }
        }
        this.rockets = this.rockets.filter(r => r.alive);

        // Update smoke particles
        for (const p of this.smokeParticles) {
          p.life -= dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.95; // Slow down
          p.vy *= 0.95;
          p.size += dt * 10; // Expand
        }
        this.smokeParticles = this.smokeParticles.filter(p => p.life > 0);

        // Update explosions - SPLASH DAMAGE
        for (const e of this.explosions) {
          e.timer += dt;
          
          if (!e.dealtDamage && e.timer >= 0.05) {
            e.dealtDamage = true;
            
            for (const agent of this.agents) {
              if (!agent.alive) continue;
              
              const dist = Math.hypot(agent.x - e.x, agent.y - e.y);
              if (dist > e.splashRadius) continue;
              
              // Damage falloff based on distance
              const falloff = 1 - (dist / e.splashRadius) * e.splashFalloff;
              const dmg = Math.floor(e.damage * falloff);
              
              if (agent === e.owner) {
                // Direct self-damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (killed) {
                  this.addEvent('üíÄ ' + e.owner.name + ' ROCKET JUMPED TOO HARD!', 'kill');
                }
              } else if (e.owner && agent.team === e.owner.team) {
                // Teammate hit
                if (this.friendlyFire) {
                  // Direct friendly fire - damage teammate
                  const killed = agent.takeDamage(dmg, e.owner, this);
                  if (killed) {
                    this.teamRicochets[e.owner.team]++;
                    this.addEvent('üíÄ ' + e.owner.name + ' TEAMKILLED ' + agent.name + '!', 'kill');
                  }
                } else if (this.friendlyFireRicochet) {
                  // Ricochet - damage reflects to shooter
                  const killed = e.owner.takeDamage(dmg, e.owner, this);
                  this.teamRicochets[e.owner.team]++;
                  if (killed) {
                    this.addEvent('üîÑ ' + e.owner.name + ' DIED FROM RICOCHET!', 'kill');
                  } else {
                    this.addEvent('üîÑ ' + e.owner.name + ' ricochet -' + dmg + 'hp', 'damage');
                  }
                }
                // Else: no friendly fire, skip
              } else {
                // Enemy damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (e.owner) {
                  e.owner.damageDealt += dmg;
                  if (killed) {
                    e.owner.kills++; 
                    e.owner.totalKills = (e.owner.totalKills || 0) + 1;
                    this.teamKills[e.owner.team]++;
                    this.teamRawKills[e.owner.team]++;
                    this.addEvent('üöÄ ' + e.owner.name + ' FRAGGED ' + agent.name + '!', 'kill');
                  }
                }
              }
            }
          }
        }
        this.explosions = this.explosions.filter(e => e.timer < e.maxTime);

        // Get decisions
        const decisions = new Array(this.agents.length);
        for (let i = 0; i < this.agents.length; i++) {
          decisions[i] = this.agents[i].think(this);
        }

        // Update agents
        for (let i = 0; i < this.agents.length; i++) {
          const a = this.agents[i];
          const d = decisions[i];
          a.update(d, dt, this, this.obstacles);

          // Handle shooting based on weapon type
          if (d && d.wantsShoot) {
            if (a.weapon === 'rocket') {
              const rocket = a.tryShoot(this);
              if (rocket) {
                this.rockets.push(rocket);
              }
            } else if (a.weapon === 'laser') {
              // Laser charging
              if (a.weaponCooldown <= 0) {
                a.laserCharging = true;
                a.laserCharge += dt;
                
                // Fire when fully charged
                if (a.laserCharge >= 3.0) {
                  this.fireLaser(a);
                  a.laserCharge = 0;
                  a.laserCharging = false;
                  a.weaponCooldown = 1.0; // 1 second cooldown
                }
              }
            } else if (a.weapon === 'sword') {
              // Sword charging (ready stance)
              if (a.weaponCooldown <= 0 && !a.swordLunging) {
                a.swordCharging = true;
                a.swordCharge = Math.min(2.0, a.swordCharge + dt); // Max 2 seconds charge
              }
            }
          } else {
            // Reset laser charge if not holding shoot
            if (a.weapon === 'laser' && a.laserCharging) {
              a.laserCharge = 0;
              a.laserCharging = false;
            }
            // Execute sword lunge when releasing
            if (a.weapon === 'sword' && a.swordCharging && a.swordCharge >= 0.3) {
              this.executeSwordLunge(a, a.swordCharge);
              a.swordCharge = 0;
              a.swordCharging = false;
            } else if (a.weapon === 'sword' && a.swordCharging) {
              // Not enough charge, just reset
              a.swordCharge = 0;
              a.swordCharging = false;
            }
          }
        }
        
        // Update laser beams animation
        for (const beam of this.laserBeams) {
          beam.timer += dt;
        }
        this.laserBeams = this.laserBeams.filter(b => b.timer < b.maxTime);
        
        // Update sword slash animations
        for (const slash of this.swordSlashes) {
          slash.timer += dt;
        }
        this.swordSlashes = this.swordSlashes.filter(s => s.timer < s.maxTime);

        // Update dodge trail animations
        for (const trail of this.dodgeTrails) {
          trail.timer += dt;
        }
        this.dodgeTrails = this.dodgeTrails.filter(t => t.timer < t.maxTime);

        // Agent-agent collision (push apart)
        const aliveAgents = this.agents.filter(a => a.alive);
        for (let i = 0; i < aliveAgents.length; i++) {
          for (let j = i + 1; j < aliveAgents.length; j++) {
            const a = aliveAgents[i];
            const b = aliveAgents[j];
            
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = a.radius + b.radius;
            
            if (dist < minDist && dist > 0) {
              // Push apart
              const overlap = minDist - dist;
              const pushX = (dx / dist) * overlap * 0.5;
              const pushY = (dy / dist) * overlap * 0.5;
              
              a.x -= pushX;
              a.y -= pushY;
              b.x += pushX;
              b.y += pushY;
              
              // Clamp to world bounds
              a.x = clamp(a.x, a.radius, this.width - a.radius);
              a.y = clamp(a.y, a.radius, this.height - a.radius);
              b.x = clamp(b.x, b.radius, this.width - b.radius);
              b.y = clamp(b.y, b.radius, this.height - b.radius);
            }
          }
        }

        // Check win condition
        if (this.teamKills[0] >= this.killLimit || this.teamKills[1] >= this.killLimit || this.timeLeft <= 0) {
          this.endRound();
        }
      }
      endRound() {
        // Determine winner
        if (this.teamKills[0] >= this.killLimit) {
          this.winningTeam = 0;
          this.teamWins[0]++;
          this.addEvent('üî¥ RED TEAM WINS! ' + this.teamKills[0] + ' kills!', 'kill');
        } else if (this.teamKills[1] >= this.killLimit) {
          this.winningTeam = 1;
          this.teamWins[1]++;
          this.addEvent('üîµ BLUE TEAM WINS! ' + this.teamKills[1] + ' kills!', 'kill');
        } else {
          // Time out - team with most kills wins
          this.winningTeam = this.teamKills[0] > this.teamKills[1] ? 0 : 1;
          this.teamWins[this.winningTeam]++;
          const winnerName = this.winningTeam === 0 ? 'RED' : 'BLUE';
          this.addEvent('‚è±Ô∏è TIME! ' + winnerName + ' WINS ' + this.teamKills[this.winningTeam] + '-' + this.teamKills[1-this.winningTeam], 'kill');
        }
        
        // Get best brain from winning team
        const winningAgents = this.agents.filter(a => a.team === this.winningTeam);
        const bestAgent = winningAgents.sort((a, b) => b.score - a.score)[0];
        
        // Update the winning team's brain
        this.teamBrains[this.winningTeam] = bestAgent.brain.clone();
        
        // Losing team gets a mutated version of their best, or copy winner if they had none
        const losingTeam = 1 - this.winningTeam;
        const losingAgents = this.agents.filter(a => a.team === losingTeam);
        const bestLoser = losingAgents.sort((a, b) => b.score - a.score)[0];
        if (bestLoser) {
          this.teamBrains[losingTeam] = bestLoser.brain.clone();
          this.teamBrains[losingTeam].mutate(0.2, 0.5);
        }
        
        this.addEvent('GENERATION ' + this.generation + ' COMPLETE', 'kill');
        this.generation++;
        this.spawnNextRound();
      }

      // Drop a weapon on the ground (when player dies)
      dropWeapon(x, y, weaponType) {
        if (weaponType !== 'laser' && weaponType !== 'sword') return;

        this.droppedWeapons.push({
          x: x,
          y: y,
          type: weaponType,
          radius: 15
        });

        this.addEvent('üí´ ' + weaponType.toUpperCase() + ' DROPPED!', weaponType);
      }

      addEvent(text, type) {
        this.events.unshift({ text, type, time: Date.now() });
        if (this.events.length > 80) this.events.pop();
      }

      getLeaderboard() {
        return [...this.agents].sort((a, b) => b.score - a.score).slice(0, 10);
      }
    }

    // --------------------
    // Renderer
    // --------------------
    class Renderer {
      constructor(canvas, world) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.world = world;

        this.cameraX = 0;
        this.cameraY = 0;
        this.zoom = 1;
        this.minZoom = 0.25;
        this.maxZoom = 3;

        this.isDragging = false;
        this.baseScale = 1;
        this.cssW = 0;
        this.cssH = 0;
        this.dpr = 1;

        this.setupControls();
        this.resize();
      }

      // Helper to get centering offset
      getCenterOffset() {
        const s = this.baseScale * this.zoom;
        const worldW = this.world.width * s;
        const worldH = this.world.height * s;
        return {
          x: Math.max(0, (this.cssW - worldW) / 2),
          y: Math.max(0, (this.cssH - worldH) / 2)
        };
      }

      setupControls() {
        const onWheel = (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          // Account for centering offset
          const offset = this.getCenterOffset();
          const adjustedMouseX = mouseX - offset.x;
          const adjustedMouseY = mouseY - offset.y;

          const worldX = this.cameraX + adjustedMouseX / (this.baseScale * this.zoom);
          const worldY = this.cameraY + adjustedMouseY / (this.baseScale * this.zoom);

          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          this.zoom = clamp(this.zoom * zoomFactor, this.minZoom, this.maxZoom);

          // Recalculate offset after zoom change
          const newOffset = this.getCenterOffset();
          const newAdjustedMouseX = mouseX - newOffset.x;
          const newAdjustedMouseY = mouseY - newOffset.y;

          this.cameraX = worldX - newAdjustedMouseX / (this.baseScale * this.zoom);
          this.cameraY = worldY - newAdjustedMouseY / (this.baseScale * this.zoom);

          this.clampCamera();
        };

        this.canvas.addEventListener('wheel', onWheel, { passive: false });

        const startDrag = (x, y) => {
          this.isDragging = true;
          this.dragStartX = x;
          this.dragStartY = y;
          this.dragCamX = this.cameraX;
          this.dragCamY = this.cameraY;
          this.canvas.style.cursor = 'grabbing';
        };

        const moveDrag = (x, y) => {
          if (!this.isDragging) return;
          const dx = x - this.dragStartX;
          const dy = y - this.dragStartY;
          this.cameraX = this.dragCamX - dx / (this.baseScale * this.zoom);
          this.cameraY = this.dragCamY - dy / (this.baseScale * this.zoom);
          this.clampCamera();
        };

        const endDrag = () => {
          this.isDragging = false;
          this.canvas.style.cursor = 'grab';
        };

        this.canvas.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
        window.addEventListener('mouseup', endDrag);

        // Touch (single finger pan)
        this.canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) startDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: true });

        this.canvas.addEventListener('touchmove', (e) => {
          if (!this.isDragging || e.touches.length !== 1) return;
          e.preventDefault();
          moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        this.canvas.addEventListener('touchend', endDrag);

        this.canvas.style.cursor = 'grab';
      }

      clampCamera() {
        const vw = this.cssW / (this.baseScale * this.zoom);
        const vh = this.cssH / (this.baseScale * this.zoom);
        this.cameraX = clamp(this.cameraX, -100, this.world.width - vw + 100);
        this.cameraY = clamp(this.cameraY, -100, this.world.height - vh + 100);
      }

      resize() {
        const container = this.canvas.parentElement;
        this.cssW = container.clientWidth;
        this.cssH = container.clientHeight;
        this.dpr = window.devicePixelRatio || 1;

        this.canvas.width = Math.floor(this.cssW * this.dpr);
        this.canvas.height = Math.floor(this.cssH * this.dpr);

        // Auto-fit: baseScale makes the world fit perfectly in the canvas at zoom=1
        const scaleX = this.cssW / this.world.width;
        const scaleY = this.cssH / this.world.height;
        this.baseScale = Math.min(scaleX, scaleY);
        
        // Center camera on world
        this.cameraX = 0;
        this.cameraY = 0;
        
        this.clampCamera();
      }

      render() {
        const ctx = this.ctx;
        const s = this.baseScale * this.zoom;

        // Draw in CSS pixels, with DPR scaling handled by transform.
        ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, this.cssW, this.cssH);

        // Calculate centering offset (center world in canvas when zoomed out)
        const worldW = this.world.width * s;
        const worldH = this.world.height * s;
        const offsetX = Math.max(0, (this.cssW - worldW) / 2);
        const offsetY = Math.max(0, (this.cssH - worldH) / 2);

        ctx.save();
        ctx.translate(offsetX - this.cameraX * s, offsetY - this.cameraY * s);

        const maxX = this.world.width * s;
        const maxY = this.world.height * s;

        // Arena floor - gradient base
        const floorGrad = ctx.createRadialGradient(maxX / 2, maxY / 2, 0, maxX / 2, maxY / 2, maxX * 0.7);
        floorGrad.addColorStop(0, '#0a0a18');
        floorGrad.addColorStop(0.5, '#080812');
        floorGrad.addColorStop(1, '#040408');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, 0, maxX, maxY);

        // Animated hex grid pattern
        const hexSize = 60 * s;
        const time = Date.now() / 3000;
        ctx.strokeStyle = '#151528';
        ctx.lineWidth = 1;
        for (let row = 0; row < maxY / (hexSize * 0.866) + 1; row++) {
          for (let col = 0; col < maxX / hexSize + 1; col++) {
            const cx = col * hexSize * 1.5 + (row % 2) * hexSize * 0.75;
            const cy = row * hexSize * 0.866;
            if (cx > maxX + hexSize || cy > maxY + hexSize) continue;

            // Subtle pulse based on position
            const pulse = Math.sin(time + col * 0.3 + row * 0.2) * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(20, 25, 50, ${pulse * 0.6})`;

            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = i * Math.PI / 3 - Math.PI / 6;
              const hx = cx + Math.cos(angle) * hexSize * 0.4;
              const hy = cy + Math.sin(angle) * hexSize * 0.4;
              if (i === 0) ctx.moveTo(hx, hy);
              else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }

        // Center danger zone glow (where weapons spawn)
        const centerGlow = ctx.createRadialGradient(maxX / 2, maxY / 2, 50 * s, maxX / 2, maxY / 2, 300 * s);
        centerGlow.addColorStop(0, 'rgba(255, 50, 100, 0.08)');
        centerGlow.addColorStop(0.5, 'rgba(255, 50, 100, 0.03)');
        centerGlow.addColorStop(1, 'rgba(255, 50, 100, 0)');
        ctx.fillStyle = centerGlow;
        ctx.fillRect(0, 0, maxX, maxY);

        // Team spawn zone hints
        const redZone = ctx.createRadialGradient(80 * s, maxY / 2, 20 * s, 80 * s, maxY / 2, 200 * s);
        redZone.addColorStop(0, 'rgba(255, 50, 50, 0.1)');
        redZone.addColorStop(1, 'rgba(255, 50, 50, 0)');
        ctx.fillStyle = redZone;
        ctx.fillRect(0, 0, maxX, maxY);

        const blueZone = ctx.createRadialGradient(maxX - 80 * s, maxY / 2, 20 * s, maxX - 80 * s, maxY / 2, 200 * s);
        blueZone.addColorStop(0, 'rgba(50, 100, 255, 0.1)');
        blueZone.addColorStop(1, 'rgba(50, 100, 255, 0)');
        ctx.fillStyle = blueZone;
        ctx.fillRect(0, 0, maxX, maxY);

        // Border - glowing tech frame
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0055';
        ctx.strokeStyle = '#ff0055';
        ctx.lineWidth = 3;
        ctx.strokeRect(2, 2, maxX - 4, maxY - 4);
        ctx.shadowBlur = 0;

        // Corner accents
        const cornerSize = 40 * s;
        ctx.strokeStyle = '#ff0055';
        ctx.lineWidth = 2;
        // Top-left
        ctx.beginPath(); ctx.moveTo(0, cornerSize); ctx.lineTo(0, 0); ctx.lineTo(cornerSize, 0); ctx.stroke();
        // Top-right
        ctx.beginPath(); ctx.moveTo(maxX - cornerSize, 0); ctx.lineTo(maxX, 0); ctx.lineTo(maxX, cornerSize); ctx.stroke();
        // Bottom-left
        ctx.beginPath(); ctx.moveTo(0, maxY - cornerSize); ctx.lineTo(0, maxY); ctx.lineTo(cornerSize, maxY); ctx.stroke();
        // Bottom-right
        ctx.beginPath(); ctx.moveTo(maxX - cornerSize, maxY); ctx.lineTo(maxX, maxY); ctx.lineTo(maxX, maxY - cornerSize); ctx.stroke();

        // Buildings/Obstacles - sci-fi crates
        for (const b of this.world.buildings) {
          const x = b.x * s, y = b.y * s, w = b.w * s, h = b.h * s;

          // Shadow
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fillRect(x + 6, y + 6, w, h);

          // Main body gradient
          const obstacleGrad = ctx.createLinearGradient(x, y, x + w, y + h);
          obstacleGrad.addColorStop(0, '#1a1a2e');
          obstacleGrad.addColorStop(0.5, '#12121f');
          obstacleGrad.addColorStop(1, '#0a0a15');
          ctx.fillStyle = obstacleGrad;
          ctx.fillRect(x, y, w, h);

          // Top highlight
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          ctx.fillRect(x, y, w, 3);
          ctx.fillRect(x, y, 3, h);

          // Bottom shadow edge
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(x, y + h - 3, w, 3);
          ctx.fillRect(x + w - 3, y, 3, h);

          // Tech lines
          ctx.strokeStyle = 'rgba(0, 255, 200, 0.15)';
          ctx.lineWidth = 1;
          // Horizontal line
          ctx.beginPath();
          ctx.moveTo(x + 5, y + h / 2);
          ctx.lineTo(x + w - 5, y + h / 2);
          ctx.stroke();
          // Vertical line
          ctx.beginPath();
          ctx.moveTo(x + w / 2, y + 5);
          ctx.lineTo(x + w / 2, y + h - 5);
          ctx.stroke();

          // Corner brackets
          const bracketSize = Math.min(w, h) * 0.2;
          ctx.strokeStyle = 'rgba(0, 255, 200, 0.3)';
          ctx.lineWidth = 2;
          // Top-left bracket
          ctx.beginPath();
          ctx.moveTo(x + bracketSize, y + 4);
          ctx.lineTo(x + 4, y + 4);
          ctx.lineTo(x + 4, y + bracketSize);
          ctx.stroke();
          // Top-right bracket
          ctx.beginPath();
          ctx.moveTo(x + w - bracketSize, y + 4);
          ctx.lineTo(x + w - 4, y + 4);
          ctx.lineTo(x + w - 4, y + bracketSize);
          ctx.stroke();
          // Bottom-left bracket
          ctx.beginPath();
          ctx.moveTo(x + bracketSize, y + h - 4);
          ctx.lineTo(x + 4, y + h - 4);
          ctx.lineTo(x + 4, y + h - bracketSize);
          ctx.stroke();
          // Bottom-right bracket
          ctx.beginPath();
          ctx.moveTo(x + w - bracketSize, y + h - 4);
          ctx.lineTo(x + w - 4, y + h - 4);
          ctx.lineTo(x + w - 4, y + h - bracketSize);
          ctx.stroke();

          // Outer glow
          ctx.strokeStyle = 'rgba(0, 200, 255, 0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x - 1, y - 1, w + 2, h + 2);
        }

        // Pickups
        for (const p of this.world.pickups) {
          const px = p.x * s, py = p.y * s, pr = p.radius * s;
          
          // Glow effect
          const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
          
          if (p.type === 'health') {
            // Health pack - green cross shape
            ctx.shadowBlur = 15 * pulse;
            ctx.shadowColor = '#00ff9d';
            ctx.fillStyle = '#00ff9d';
            
            // Horizontal bar of cross
            ctx.fillRect(px - pr, py - pr * 0.3, pr * 2, pr * 0.6);
            // Vertical bar of cross
            ctx.fillRect(px - pr * 0.3, py - pr, pr * 0.6, pr * 2);
            
          } else if (p.type === 'armor') {
            // Armor pack - blue kite shield
            ctx.shadowBlur = 15 * pulse;
            ctx.shadowColor = '#00aaff';
            ctx.fillStyle = '#00aaff';
            
            // Kite shield shape (wider at top, pointed at bottom)
            ctx.beginPath();
            ctx.moveTo(px, py - pr * 1.1);           // Top center
            ctx.lineTo(px + pr * 0.8, py - pr * 0.3); // Top right
            ctx.lineTo(px + pr * 0.6, py + pr * 0.4); // Mid right
            ctx.lineTo(px, py + pr * 1.1);            // Bottom point
            ctx.lineTo(px - pr * 0.6, py + pr * 0.4); // Mid left
            ctx.lineTo(px - pr * 0.8, py - pr * 0.3); // Top left
            ctx.closePath();
            ctx.fill();
            
            // Inner highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else if (p.type === 'laser') {
            // Laser pickup - electric bolt shape
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            
            // Lightning bolt shape
            ctx.beginPath();
            ctx.moveTo(px + pr * 0.3, py - pr * 1.2);
            ctx.lineTo(px - pr * 0.1, py - pr * 0.2);
            ctx.lineTo(px + pr * 0.3, py - pr * 0.2);
            ctx.lineTo(px - pr * 0.3, py + pr * 1.2);
            ctx.lineTo(px + pr * 0.1, py + pr * 0.2);
            ctx.lineTo(px - pr * 0.3, py + pr * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Inner glow
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else if (p.type === 'sword') {
            // Sword pickup - energy sword shape (neutral purple until picked up)
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff00ff';
            
            // Sword blade shape
            ctx.beginPath();
            ctx.moveTo(px, py - pr * 1.5);           // Tip
            ctx.lineTo(px + pr * 0.3, py - pr * 0.5); // Right edge upper
            ctx.lineTo(px + pr * 0.2, py + pr * 0.8); // Right edge lower
            ctx.lineTo(px, py + pr * 1.2);            // Handle
            ctx.lineTo(px - pr * 0.2, py + pr * 0.8); // Left edge lower
            ctx.lineTo(px - pr * 0.3, py - pr * 0.5); // Left edge upper
            ctx.closePath();
            ctx.fill();
            
            // Inner glow line
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
        }

        // Dropped weapons (flashing to indicate they're dropped loot)
        for (const w of this.world.droppedWeapons) {
          const wx = w.x * s, wy = w.y * s, wr = w.radius * s;

          // Faster pulse for dropped weapons + slight bounce effect
          const pulse = Math.sin(Date.now() / 100) * 0.4 + 0.6;
          const bounce = Math.abs(Math.sin(Date.now() / 300)) * 3 * s;

          if (w.type === 'laser') {
            // Dropped laser - cyan lightning bolt with flash effect
            ctx.shadowBlur = 25 * pulse;
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = `rgba(0, 255, 255, ${0.7 + pulse * 0.3})`;

            // Lightning bolt shape (slightly larger than pickup)
            ctx.beginPath();
            ctx.moveTo(wx + wr * 0.35, wy - bounce - wr * 1.4);
            ctx.lineTo(wx - wr * 0.1, wy - bounce - wr * 0.25);
            ctx.lineTo(wx + wr * 0.35, wy - bounce - wr * 0.25);
            ctx.lineTo(wx - wr * 0.35, wy - bounce + wr * 1.4);
            ctx.lineTo(wx + wr * 0.1, wy - bounce + wr * 0.25);
            ctx.lineTo(wx - wr * 0.35, wy - bounce + wr * 0.25);
            ctx.closePath();
            ctx.fill();

            // Bright core
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // "DROPPED" indicator ring
            ctx.strokeStyle = `rgba(0, 255, 255, ${pulse * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(wx, wy - bounce, wr * 1.8, 0, Math.PI * 2);
            ctx.stroke();

          } else if (w.type === 'sword') {
            // Dropped sword - magenta sword shape with flash effect
            ctx.shadowBlur = 25 * pulse;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = `rgba(255, 0, 255, ${0.7 + pulse * 0.3})`;

            // Sword blade shape (slightly larger than pickup)
            ctx.beginPath();
            ctx.moveTo(wx, wy - bounce - wr * 1.7);           // Tip
            ctx.lineTo(wx + wr * 0.35, wy - bounce - wr * 0.6); // Right edge upper
            ctx.lineTo(wx + wr * 0.25, wy - bounce + wr * 0.9); // Right edge lower
            ctx.lineTo(wx, wy - bounce + wr * 1.4);             // Handle
            ctx.lineTo(wx - wr * 0.25, wy - bounce + wr * 0.9); // Left edge lower
            ctx.lineTo(wx - wr * 0.35, wy - bounce - wr * 0.6); // Left edge upper
            ctx.closePath();
            ctx.fill();

            // Bright core
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // "DROPPED" indicator ring
            ctx.strokeStyle = `rgba(255, 0, 255, ${pulse * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(wx, wy - bounce, wr * 1.8, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
        }

        // Agents with class-based rendering
        for (const agent of this.world.agents) {
          if (!agent.alive) continue;
          const x = agent.x * s, y = agent.y * s, r = agent.radius * s;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(agent.rotation);

          // Vision cone
          const fov = Math.PI * 0.4;
          const viewDist = 200 * s;
          const grad = ctx.createRadialGradient(0, 0, r, 0, 0, viewDist);
          grad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
          grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, viewDist, -fov / 2, fov / 2);
          ctx.fill();

          // Body
          ctx.shadowBlur = 15;
          const swordColor = agent.team === 0 ? '#ff4444' : '#4488ff';
          const laserColor = agent.team === 0 ? '#ff00aa' : '#00aaff'; // Magenta for red team, electric blue for blue team
          ctx.shadowColor = agent.weapon === 'laser' ? laserColor : (agent.weapon === 'sword' ? swordColor : agent.color);
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = agent.weapon === 'laser' ? laserColor : (agent.weapon === 'sword' ? swordColor : agent.color);
          ctx.lineWidth = 2;
          ctx.stroke();

          if (agent.weapon === 'rocket') {
            // Rocket launcher on right shoulder
            ctx.save();
            const shoulderOffset = r * 0.7; // offset to right shoulder
            ctx.translate(0, -shoulderOffset);

            // Launcher body - military style tube
            const gradient = ctx.createLinearGradient(r * 0.2, -5 * s, r * 0.2, 5 * s);
            gradient.addColorStop(0, '#666');
            gradient.addColorStop(0.3, '#444');
            gradient.addColorStop(0.7, '#333');
            gradient.addColorStop(1, '#222');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(r * 0.2, -5 * s, r * 1.5, 10 * s, 3 * s);
            ctx.fill();

            // Launcher tube opening
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(r * 1.7, 0, 5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Orange warning stripes
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(r * 0.4, -4 * s);
            ctx.lineTo(r * 0.4, 4 * s);
            ctx.moveTo(r * 0.6, -4 * s);
            ctx.lineTo(r * 0.6, 4 * s);
            ctx.stroke();

            // Scope/sight on top
            ctx.fillStyle = '#555';
            ctx.fillRect(r * 0.8, -8 * s, r * 0.4, 3 * s);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(r * 0.9, -7 * s, r * 0.2, 1.5 * s);

            // Exhaust vents at back
            ctx.fillStyle = '#333';
            ctx.fillRect(r * 0.1, -4 * s, r * 0.15, 8 * s);

            ctx.restore();

            // Small rocket icon on body
            ctx.fillStyle = '#ff6600';
            ctx.font = 'bold ' + (r * 0.5) + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üöÄ', 0, 0);
          } else if (agent.weapon === 'laser') {
            // Legendary Plasma Cannon - Team colored
            const chargeProgress = agent.laserCharging ? agent.laserCharge / 3.0 : 0;

            // Team-specific colors
            const isRed = agent.team === 0;
            const primaryColor = isRed ? '#ff00aa' : '#00aaff';
            const primaryRGB = isRed ? '255, 0, 170' : '0, 170, 255';
            const secondaryRGB = isRed ? '255, 100, 200' : '100, 200, 255';
            const darkTint = isRed ? '#2a1a2a' : '#1a2a3a';
            const midTint = isRed ? '#3a1a3a' : '#0a1a2a';

            // Main body - sleek futuristic design
            const bodyGradient = ctx.createLinearGradient(r * 0.2, -6 * s, r * 0.2, 6 * s);
            bodyGradient.addColorStop(0, darkTint);
            bodyGradient.addColorStop(0.3, midTint);
            bodyGradient.addColorStop(0.7, '#0a0a1a');
            bodyGradient.addColorStop(1, midTint);
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.moveTo(r * 0.2, -5 * s);
            ctx.lineTo(r * 1.4, -4 * s);
            ctx.lineTo(r * 1.6, -3 * s);
            ctx.lineTo(r * 1.6, 3 * s);
            ctx.lineTo(r * 1.4, 4 * s);
            ctx.lineTo(r * 0.2, 5 * s);
            ctx.closePath();
            ctx.fill();

            // Energy coils around barrel
            ctx.shadowBlur = 8;
            ctx.shadowColor = primaryColor;
            ctx.strokeStyle = primaryColor;
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 3; i++) {
              const cx = r * 0.6 + i * r * 0.35;
              const coilAlpha = 0.4 + chargeProgress * 0.6;
              ctx.strokeStyle = `rgba(${primaryRGB}, ${coilAlpha})`;
              ctx.beginPath();
              ctx.arc(cx, 0, 5 * s, -Math.PI * 0.7, Math.PI * 0.7);
              ctx.stroke();
            }

            // Central energy conduit
            const conduitGradient = ctx.createLinearGradient(r * 0.3, 0, r * 1.5, 0);
            conduitGradient.addColorStop(0, `rgba(${primaryRGB}, 0.4)`);
            conduitGradient.addColorStop(0.5, `rgba(${primaryRGB}, ${0.3 + chargeProgress * 0.7})`);
            conduitGradient.addColorStop(1, `rgba(${secondaryRGB}, 0.9)`);
            ctx.fillStyle = conduitGradient;
            ctx.fillRect(r * 0.3, -2 * s, r * 1.2, 4 * s);

            // Barrel tip - focusing lens
            ctx.shadowBlur = 10 + chargeProgress * 15;
            ctx.fillStyle = '#0a0a1a';
            ctx.beginPath();
            ctx.arc(r * 1.7, 0, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = `rgba(${primaryRGB}, ${0.6 + chargeProgress * 0.4})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Inner focusing ring
            ctx.fillStyle = `rgba(${primaryRGB}, ${0.3 + chargeProgress * 0.7})`;
            ctx.beginPath();
            ctx.arc(r * 1.7, 0, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Charging effect - energy spiral
            if (agent.laserCharging && agent.laserCharge > 0) {
              ctx.shadowBlur = 20 * chargeProgress;
              ctx.shadowColor = primaryColor;

              // Rotating energy particles converging to barrel tip
              for (let i = 0; i < 8; i++) {
                const angle = (Date.now() / 120 + i * Math.PI / 4) % (Math.PI * 2);
                const dist = (1 - chargeProgress * 0.7) * r * 0.9;
                const px = r * 1.7 + Math.cos(angle) * dist;
                const py = Math.sin(angle) * dist;
                const pSize = (2 + chargeProgress * 4) * s;

                ctx.fillStyle = `rgba(${primaryRGB}, ${chargeProgress * 0.9})`;
                ctx.beginPath();
                ctx.arc(px, py, pSize, 0, Math.PI * 2);
                ctx.fill();
              }

              // Secondary particle ring
              for (let i = 0; i < 4; i++) {
                const angle = (Date.now() / 200 + i * Math.PI / 2 + Math.PI / 4) % (Math.PI * 2);
                const dist = (1 - chargeProgress * 0.5) * r * 1.2;
                const px = r * 1.7 + Math.cos(angle) * dist;
                const py = Math.sin(angle) * dist;

                ctx.fillStyle = `rgba(255, 255, 255, ${chargeProgress * 0.5})`;
                ctx.beginPath();
                ctx.arc(px, py, 2 * s, 0, Math.PI * 2);
                ctx.fill();
              }

              // Energy buildup at tip
              ctx.fillStyle = `rgba(255, 255, 255, ${chargeProgress * 0.8})`;
              ctx.beginPath();
              ctx.arc(r * 1.7, 0, (2 + chargeProgress * 6) * s, 0, Math.PI * 2);
              ctx.fill();

              // Warning indicator - pulsing ring
              if (chargeProgress > 0.7) {
                const pulse = (Math.sin(Date.now() / 50) + 1) * 0.5;
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(r * 1.7, 0, (8 + chargeProgress * 4) * s, 0, Math.PI * 2);
                ctx.stroke();

                // Additional warning particles
                for (let i = 0; i < 3; i++) {
                  const sparkAngle = Date.now() / 30 + i * Math.PI * 2 / 3;
                  const sparkDist = (10 + chargeProgress * 5) * s;
                  ctx.fillStyle = `rgba(${primaryRGB}, ${pulse})`;
                  ctx.beginPath();
                  ctx.arc(r * 1.7 + Math.cos(sparkAngle) * sparkDist, Math.sin(sparkAngle) * sparkDist, 2 * s, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
            }

            ctx.shadowBlur = 0;
          } else if (agent.weapon === 'sword') {
            // Legendary Energy Katana
            // Define sword color locally to ensure correct team color
            const localSwordColor = agent.team === 0 ? '#ff4444' : '#4488ff';

            ctx.save();
            if (agent.swordCharging) {
              // Ready stance - sword held to right side with backward angle (samurai style)
              ctx.rotate(Math.PI / 2 + Math.PI / 6);
            }

            const bladeLength = r * 2.0;
            const bladeWidth = 4 * s;
            const hiltLength = r * 0.5;

            // Hilt/handle - wrapped grip style
            const hiltGradient = ctx.createLinearGradient(0, -3 * s, 0, 3 * s);
            hiltGradient.addColorStop(0, '#2a2a2a');
            hiltGradient.addColorStop(0.5, '#1a1a1a');
            hiltGradient.addColorStop(1, '#2a2a2a');
            ctx.fillStyle = hiltGradient;
            ctx.fillRect(r * 0.1, -3 * s, hiltLength, 6 * s);

            // Hilt wrapping lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
              const wx = r * 0.15 + i * (hiltLength / 4);
              ctx.beginPath();
              ctx.moveTo(wx, -3 * s);
              ctx.lineTo(wx + 3 * s, 3 * s);
              ctx.stroke();
            }

            // Guard (tsuba) - circular with team color accent
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(r * 0.6, 0, 6 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = localSwordColor;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Blade outer glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = localSwordColor;

            // Blade shape - katana style with curved edge
            ctx.beginPath();
            ctx.moveTo(r * 0.65, -bladeWidth);           // blade start top
            ctx.lineTo(r * 0.65 + bladeLength * 0.9, -bladeWidth * 0.7);  // taper to tip
            ctx.quadraticCurveTo(r * 0.65 + bladeLength * 1.05, 0, r * 0.65 + bladeLength * 0.9, bladeWidth * 0.3); // curved tip
            ctx.lineTo(r * 0.65, bladeWidth * 0.3);      // blade start bottom (thinner back edge)
            ctx.closePath();

            // Blade gradient - energy core effect
            const bladeGradient = ctx.createLinearGradient(r * 0.65, -bladeWidth, r * 0.65, bladeWidth);
            const baseColor = agent.team === 0 ? [255, 68, 68] : [68, 136, 255];
            bladeGradient.addColorStop(0, `rgba(${baseColor.join(',')}, 0.9)`);
            bladeGradient.addColorStop(0.3, '#fff');
            bladeGradient.addColorStop(0.5, `rgba(${baseColor.join(',')}, 0.95)`);
            bladeGradient.addColorStop(1, `rgba(${baseColor.join(',')}, 0.7)`);
            ctx.fillStyle = bladeGradient;
            ctx.fill();

            // Blade edge highlight (sharp edge)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(r * 0.65, -bladeWidth);
            ctx.lineTo(r * 0.65 + bladeLength * 0.9, -bladeWidth * 0.7);
            ctx.quadraticCurveTo(r * 0.65 + bladeLength * 1.05, 0, r * 0.65 + bladeLength * 0.9, bladeWidth * 0.3);
            ctx.stroke();

            // Energy core line along blade
            ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(r * 0.7, -bladeWidth * 0.3);
            ctx.lineTo(r * 0.65 + bladeLength * 0.85, -bladeWidth * 0.4);
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.restore();

            // Charging effect - energy gathering at blade
            if (agent.swordCharging && agent.swordCharge > 0) {
              const chargeProgress = agent.swordCharge / 2.0;
              ctx.save();
              ctx.rotate(Math.PI / 2 + Math.PI / 6);

              // Energy particles gathering along blade
              ctx.shadowBlur = 15 * chargeProgress;
              ctx.shadowColor = localSwordColor;
              for (let i = 0; i < 5; i++) {
                const t = (Date.now() / 200 + i * 0.7) % 1;
                const px = r * 0.7 + t * bladeLength * 0.8;
                const py = (Math.sin(t * Math.PI * 4 + i) * 8 - 4) * s * chargeProgress;
                const pSize = (2 + chargeProgress * 3) * s * (1 - t * 0.5);
                ctx.fillStyle = `rgba(255, 255, 255, ${(0.3 + chargeProgress * 0.7) * (1 - t)})`;
                ctx.beginPath();
                ctx.arc(px, py, pSize, 0, Math.PI * 2);
                ctx.fill();
              }

              // Blade intensifying glow
              ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + chargeProgress * 0.5})`;
              ctx.lineWidth = 2 + chargeProgress * 2;
              ctx.beginPath();
              ctx.moveTo(r * 0.65, 0);
              ctx.lineTo(r * 0.65 + bladeLength * 0.9, 0);
              ctx.stroke();

              ctx.shadowBlur = 0;
              ctx.restore();
            }
          }

          ctx.restore();
          ctx.shadowBlur = 0;

          // Health bar
          const barW = 30 * s;
          const barH = 4 * s;
          ctx.fillStyle = '#333';
          ctx.fillRect(x - barW / 2, y - r - 12 * s, barW, barH);
          ctx.fillStyle = agent.health > 50 ? '#00ff9d' : '#ff0055';
          ctx.fillRect(x - barW / 2, y - r - 12 * s, barW * (agent.health / agent.maxHealth), barH);
          
          // Armor bar (blue, below health bar)
          if (agent.armor > 0) {
            ctx.fillStyle = '#333';
            ctx.fillRect(x - barW / 2, y - r - 7 * s, barW, barH);
            ctx.fillStyle = '#00aaff';
            ctx.fillRect(x - barW / 2, y - r - 7 * s, barW * (agent.armor / agent.maxArmor), barH);
          }
          
          // Weapon cooldown indicator
          if (agent.weaponCooldown > 0) {
            const cooldownPct = agent.weaponCooldown / ROCKET.fireRate;
            const cooldownY = agent.armor > 0 ? y - r - 2 * s : y - r - 6 * s;
            ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
            ctx.fillRect(x - barW / 2, cooldownY, barW * cooldownPct, 2 * s);
          }
        }

        // Projectiles
        ctx.shadowBlur = 0;
        
        // Smoke particles (draw first, behind rockets)
        for (const p of this.world.smokeParticles) {
          const px = p.x * s, py = p.y * s;
          const alpha = (p.life / p.maxLife) * 0.6;
          const size = p.size * s;
          
          ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
          ctx.beginPath();
          ctx.arc(px, py, size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Rockets
        for (const r of this.world.rockets) {
          if (!r.alive) continue;
          const rx = r.x * s, ry = r.y * s;
          
          ctx.save();
          ctx.translate(rx, ry);
          ctx.rotate(r.angle);
          
          // Flame trail (behind rocket)
          const flameGrad = ctx.createLinearGradient(-35 * s, 0, 0, 0);
          flameGrad.addColorStop(0, 'rgba(255, 100, 0, 0)');
          flameGrad.addColorStop(0.3, 'rgba(255, 150, 0, 0.8)');
          flameGrad.addColorStop(0.6, 'rgba(255, 200, 50, 1)');
          flameGrad.addColorStop(1, 'rgba(255, 255, 200, 1)');
          
          ctx.fillStyle = flameGrad;
          ctx.beginPath();
          ctx.moveTo(-35 * s, 0);
          ctx.lineTo(-8 * s, -6 * s);
          ctx.lineTo(-8 * s, 6 * s);
          ctx.closePath();
          ctx.fill();
          
          // Rocket body
          ctx.fillStyle = '#444';
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(0, 0, 12 * s, 5 * s, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Rocket nose (red tip)
          ctx.fillStyle = '#ff3300';
          ctx.beginPath();
          ctx.moveTo(12 * s, 0);
          ctx.lineTo(6 * s, -4 * s);
          ctx.lineTo(6 * s, 4 * s);
          ctx.closePath();
          ctx.fill();
          
          // Fins
          ctx.fillStyle = '#ff3300';
          ctx.beginPath();
          ctx.moveTo(-8 * s, -5 * s);
          ctx.lineTo(-12 * s, -10 * s);
          ctx.lineTo(-6 * s, -5 * s);
          ctx.closePath();
          ctx.fill();
          
          ctx.beginPath();
          ctx.moveTo(-8 * s, 5 * s);
          ctx.lineTo(-12 * s, 10 * s);
          ctx.lineTo(-6 * s, 5 * s);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }

        // Explosions
        ctx.globalCompositeOperation = 'lighter';
        for (const e of this.world.explosions) {
          const ex = e.x * s, ey = e.y * s;
          const progress = e.timer / e.maxTime;
          const currentRadius = e.splashRadius * s * (0.3 + progress * 0.7);
          
          // Outer shockwave ring
          ctx.strokeStyle = `rgba(255, 100, 0, ${1 - progress})`;
          ctx.lineWidth = 8 * (1 - progress);
          ctx.beginPath();
          ctx.arc(ex, ey, currentRadius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Inner flash
          const innerGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, currentRadius * 0.8);
          innerGrad.addColorStop(0, `rgba(255, 255, 200, ${0.9 - progress * 0.9})`);
          innerGrad.addColorStop(0.3, `rgba(255, 200, 0, ${0.7 - progress * 0.7})`);
          innerGrad.addColorStop(0.6, `rgba(255, 100, 0, ${0.5 - progress * 0.5})`);
          innerGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
          ctx.fillStyle = innerGrad;
          ctx.beginPath();
          ctx.arc(ex, ey, currentRadius * 0.8, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Laser beams (epic team-colored)
        for (const beam of this.world.laserBeams) {
          const progress = beam.timer / beam.maxTime;
          const sx = beam.startX * s, sy = beam.startY * s;
          const ex = beam.endX * s, ey = beam.endY * s;

          // Team colors
          const isRed = beam.team === 0;
          const outerRGB = isRed ? '255, 0, 100' : '0, 150, 255';
          const midRGB = isRed ? '255, 50, 150' : '50, 200, 255';
          const innerRGB = isRed ? '255, 150, 200' : '150, 220, 255';

          // Phase 1: Expansion (0 - 0.1)
          // Phase 2: Peak (0.1 - 0.4)
          // Phase 3: Contraction (0.4 - 1.0)

          let beamWidth, alpha;
          if (progress < 0.1) {
            // Expanding
            beamWidth = (progress / 0.1) * 30;
            alpha = 1;
          } else if (progress < 0.4) {
            // Peak - with slight pulse
            const pulse = 1 + Math.sin(progress * 50) * 0.1;
            beamWidth = 30 * pulse;
            alpha = 1;
          } else {
            // Contracting
            const contractProgress = (progress - 0.4) / 0.6;
            beamWidth = 30 * (1 - contractProgress);
            alpha = 1 - contractProgress;
          }

          // Calculate beam direction for effects
          const dx = ex - sx, dy = ey - sy;
          const len = Math.hypot(dx, dy);
          const dirX = len > 0 ? dx / len : 1;
          const dirY = len > 0 ? dy / len : 0;
          const perpX = -dirY, perpY = dirX;

          // Outer glow (widest)
          ctx.shadowBlur = 30 * alpha;
          ctx.shadowColor = isRed ? '#ff0066' : '#0088ff';
          ctx.strokeStyle = `rgba(${outerRGB}, ${alpha * 0.3})`;
          ctx.lineWidth = beamWidth * s * 4;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // Secondary glow
          ctx.strokeStyle = `rgba(${outerRGB}, ${alpha * 0.5})`;
          ctx.lineWidth = beamWidth * s * 2.5;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // Middle glow
          ctx.strokeStyle = `rgba(${midRGB}, ${alpha * 0.7})`;
          ctx.lineWidth = beamWidth * s * 1.5;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // Inner bright layer
          ctx.strokeStyle = `rgba(${innerRGB}, ${alpha * 0.9})`;
          ctx.lineWidth = beamWidth * s * 0.8;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // Core beam (white hot)
          ctx.shadowBlur = 0;
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.lineWidth = beamWidth * s * 0.3;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // Energy particles along beam
          if (alpha > 0.3) {
            const particleCount = Math.floor(len / (40 * s));
            for (let i = 0; i < particleCount; i++) {
              const t = (i + 0.5) / particleCount;
              const wobble = Math.sin(Date.now() / 50 + i * 2) * beamWidth * s * 0.3;
              const px = sx + dx * t + perpX * wobble;
              const py = sy + dy * t + perpY * wobble;
              const pSize = (2 + Math.random() * 2) * s * alpha;

              ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
              ctx.beginPath();
              ctx.arc(px, py, pSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Impact flash at end point
          if (progress < 0.3) {
            const flashAlpha = (1 - progress / 0.3) * alpha;
            const flashSize = (20 + progress * 30) * s;

            ctx.shadowBlur = 40;
            ctx.shadowColor = isRed ? '#ff0066' : '#0088ff';
            ctx.fillStyle = `rgba(${outerRGB}, ${flashAlpha * 0.5})`;
            ctx.beginPath();
            ctx.arc(ex, ey, flashSize * 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(ex, ey, flashSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }

          // Muzzle flash at start
          if (progress < 0.15) {
            const muzzleAlpha = (1 - progress / 0.15);
            ctx.fillStyle = `rgba(255, 255, 255, ${muzzleAlpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(sx, sy, 15 * s * muzzleAlpha, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Sword slashes - blade sweep arc effect
        for (const slash of this.world.swordSlashes) {
          const progress = slash.timer / slash.maxTime;
          const sx = slash.startX * s, sy = slash.startY * s;
          const ex = slash.endX * s, ey = slash.endY * s;

          const alpha = 1 - progress * progress; // Faster initial fade
          const baseColor = slash.team === 0 ? [255, 68, 68] : [68, 136, 255];
          const glowColor = slash.team === 0 ? '#ff4444' : '#4488ff';

          // Direction and perpendicular vectors
          const dx = ex - sx;
          const dy = ey - sy;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;

          const dirX = dx / len;
          const dirY = dy / len;
          const nx = -dirY; // perpendicular
          const ny = dirX;

          const bladeWidth = (slash.bladeLength || 30) * s;

          // Animate the sweep - blade position moves along the path
          const sweepProgress = Math.min(1, progress * 2.5); // Blade reaches end faster
          const currentX = sx + dx * sweepProgress;
          const currentY = sy + dy * sweepProgress;

          ctx.shadowBlur = 15 * alpha;
          ctx.shadowColor = glowColor;

          // Draw multiple trailing ghost blades for motion blur effect
          const numTrails = 5;
          for (let t = 0; t < numTrails; t++) {
            const trailProgress = Math.max(0, sweepProgress - t * 0.15);
            if (trailProgress <= 0) continue;

            const trailX = sx + dx * trailProgress;
            const trailY = sy + dy * trailProgress;
            const trailAlpha = alpha * (1 - t / numTrails) * 0.6;

            // Draw arc-shaped trail segment
            ctx.fillStyle = `rgba(${baseColor.join(',')}, ${trailAlpha * 0.3})`;
            ctx.beginPath();
            ctx.moveTo(trailX + nx * bladeWidth, trailY + ny * bladeWidth);
            ctx.quadraticCurveTo(
              trailX + dirX * bladeWidth * 0.3 + nx * bladeWidth * 0.5,
              trailY + dirY * bladeWidth * 0.3 + ny * bladeWidth * 0.5,
              trailX - nx * bladeWidth * 0.2, trailY - ny * bladeWidth * 0.2
            );
            ctx.lineTo(trailX - nx * bladeWidth * 0.1, trailY - ny * bladeWidth * 0.1);
            ctx.quadraticCurveTo(
              trailX + dirX * bladeWidth * 0.2,
              trailY + dirY * bladeWidth * 0.2,
              trailX + nx * bladeWidth * 0.9, trailY + ny * bladeWidth * 0.9
            );
            ctx.closePath();
            ctx.fill();
          }

          // Main sweep arc - curved trail from start to current blade position
          if (sweepProgress > 0.05) {
            const gradient = ctx.createLinearGradient(
              sx + nx * bladeWidth, sy + ny * bladeWidth,
              sx - nx * bladeWidth * 0.2, sy - ny * bladeWidth * 0.2
            );
            gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.9})`);
            gradient.addColorStop(0.2, `rgba(${baseColor.join(',')}, ${alpha * 0.8})`);
            gradient.addColorStop(0.6, `rgba(${baseColor.join(',')}, ${alpha * 0.4})`);
            gradient.addColorStop(1, `rgba(${baseColor.join(',')}, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            // Outer edge (blade tip path) - slight curve
            ctx.moveTo(sx + nx * bladeWidth, sy + ny * bladeWidth);
            ctx.quadraticCurveTo(
              (sx + currentX) / 2 + nx * bladeWidth * 1.1,
              (sy + currentY) / 2 + ny * bladeWidth * 1.1,
              currentX + nx * bladeWidth, currentY + ny * bladeWidth
            );
            // Blade tip at current position
            ctx.lineTo(currentX - nx * bladeWidth * 0.15, currentY - ny * bladeWidth * 0.15);
            // Inner edge (near hilt) - curves back
            ctx.quadraticCurveTo(
              (sx + currentX) / 2 - nx * bladeWidth * 0.1,
              (sy + currentY) / 2 - ny * bladeWidth * 0.1,
              sx - nx * bladeWidth * 0.1, sy - ny * bladeWidth * 0.1
            );
            ctx.closePath();
            ctx.fill();
          }

          // Current blade position - sharp leading edge
          if (sweepProgress < 1) {
            ctx.shadowBlur = 20 * alpha;

            // Blade shape at current position
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.95})`;
            ctx.beginPath();
            ctx.moveTo(currentX + nx * bladeWidth, currentY + ny * bladeWidth); // tip
            ctx.lineTo(currentX + dirX * 3 * s, currentY + dirY * 3 * s); // sharp point forward
            ctx.lineTo(currentX - nx * bladeWidth * 0.15, currentY - ny * bladeWidth * 0.15); // back edge
            ctx.closePath();
            ctx.fill();

            // Blade edge glow
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(currentX + nx * bladeWidth, currentY + ny * bladeWidth);
            ctx.lineTo(currentX + dirX * 3 * s, currentY + dirY * 3 * s);
            ctx.stroke();
          }

          // Energy particles along the sweep
          ctx.shadowBlur = 10 * alpha;
          for (let i = 0; i < 4; i++) {
            const particleT = (sweepProgress - i * 0.12) % 1;
            if (particleT < 0 || particleT > sweepProgress) continue;

            const px = sx + dx * particleT + nx * bladeWidth * (0.7 + Math.sin(i * 2) * 0.3);
            const py = sy + dy * particleT + ny * bladeWidth * (0.7 + Math.sin(i * 2) * 0.3);
            const particleAlpha = alpha * (1 - i * 0.2);
            const particleSize = (3 - i * 0.5) * s;

            ctx.fillStyle = `rgba(255, 255, 255, ${particleAlpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.shadowBlur = 0;
        }

        // Dodge trails - motion blur afterimage effect
        for (const trail of this.world.dodgeTrails) {
          const progress = trail.timer / trail.maxTime;
          const alpha = 1 - progress;

          const sx = trail.startX * s, sy = trail.startY * s;
          const ex = trail.endX * s, ey = trail.endY * s;

          // Direction vector
          const dx = ex - sx;
          const dy = ey - sy;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;

          const dirX = dx / len;
          const dirY = dy / len;
          const nx = -dirY; // perpendicular
          const ny = dirX;

          // Team colors
          const isRed = trail.team === 0;
          const baseColor = isRed ? [255, 100, 100] : [100, 150, 255];
          const glowColor = isRed ? '#ff6666' : '#6699ff';

          ctx.shadowBlur = 20 * alpha;
          ctx.shadowColor = glowColor;

          // Draw multiple afterimage circles along the path
          const numGhosts = 8;
          for (let i = 0; i < numGhosts; i++) {
            const t = i / (numGhosts - 1);
            // Ghosts fade out from start to end
            const ghostAlpha = alpha * (1 - t * 0.7) * 0.5;
            const ghostX = sx + dx * t;
            const ghostY = sy + dy * t;
            const ghostRadius = (15 - i * 0.8) * s * (1 - progress * 0.3);

            // Ghost circle
            const gradient = ctx.createRadialGradient(
              ghostX, ghostY, 0,
              ghostX, ghostY, ghostRadius
            );
            gradient.addColorStop(0, `rgba(${baseColor.join(',')}, ${ghostAlpha})`);
            gradient.addColorStop(0.5, `rgba(${baseColor.join(',')}, ${ghostAlpha * 0.5})`);
            gradient.addColorStop(1, `rgba(${baseColor.join(',')}, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ghostX, ghostY, ghostRadius, 0, Math.PI * 2);
            ctx.fill();
          }

          // Speed lines along the path
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
          ctx.lineWidth = 2 * (1 - progress);

          const lineSpacing = 20 * s;
          const numLines = Math.floor(len / lineSpacing);
          for (let i = 0; i < numLines; i++) {
            const t = (i + 0.5) / numLines;
            const lineX = sx + dx * t;
            const lineY = sy + dy * t;
            const lineLen = 8 * s * (1 - progress);
            const offset = (Math.sin(i * 1.5) * 8) * s;

            ctx.beginPath();
            ctx.moveTo(lineX + nx * offset, lineY + ny * offset);
            ctx.lineTo(lineX + nx * offset - dirX * lineLen, lineY + ny * offset - dirY * lineLen);
            ctx.stroke();
          }

          ctx.shadowBlur = 0;
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // --------------------
    // Init
    // --------------------
    const canvas = document.getElementById('canvas');
    const world = new World(3600, 2400); // 50% wider arena
    const renderer = new Renderer(canvas, world);

    let population = 100;
    let simSpeed = 1;

    world.spawnAgents(population);

    const ui = {
      gen: document.getElementById('generation'),
      alive: document.getElementById('alive'),
      time: document.getElementById('time-left'),
      leaderboard: document.getElementById('leaderboard'),
      log: document.getElementById('event-log'),
      alltimeLeaderboard: document.getElementById('alltime-leaderboard'),

      zoom: document.getElementById('zoom'),
      speed: document.getElementById('speed'),
      population: document.getElementById('population'),
      roundTime: document.getElementById('round-time'),
      killLimit: document.getElementById('kill-limit'),

      zoomValue: document.getElementById('zoom-value'),
      speedValue: document.getElementById('speed-value'),
      populationValue: document.getElementById('population-value'),
      roundTimeValue: document.getElementById('round-time-value'),
      killLimitValue: document.getElementById('kill-limit-value'),
      killLimitDisplay: document.getElementById('kill-limit-display'),

      // Team score elements (new layout)
      redScore: document.getElementById('red-score'),
      blueScore: document.getElementById('blue-score'),
      redWins: document.getElementById('red-wins'),
      blueWins: document.getElementById('blue-wins'),

      // Toggles
      toggleHealth: document.getElementById('toggle-health'),
      toggleArmor: document.getElementById('toggle-armor'),
      toggleLaser: document.getElementById('toggle-laser'),
      toggleSword: document.getElementById('toggle-sword'),
      toggleDodge: document.getElementById('toggle-dodge'),
      toggleFf: document.getElementById('toggle-ff'),
      toggleRicochet: document.getElementById('toggle-ricochet'),

      // Field item counts
      fieldItemsList: document.getElementById('field-items-list'),

      // Respawn time slider
      respawnTime: document.getElementById('respawn-time'),
      respawnTimeValue: document.getElementById('respawn-time-value'),

      pauseBtn: document.getElementById('pause-btn'),
      restartBtn: document.getElementById('restart-btn'),
      saveBtn: document.getElementById('save-btn'),
      loadBtn: document.getElementById('load-btn'),
      loadFile: document.getElementById('load-file'),
      headlessBtn: document.getElementById('headless-btn'),
      headlessOverlay: document.getElementById('headless-overlay'),
      ups: document.getElementById('ups'),
    };

    // Headless mode
    let headlessMode = true;
    ui.headlessOverlay.classList.add('visible');
    
    ui.headlessBtn.addEventListener('click', () => {
      headlessMode = !headlessMode;
      ui.headlessBtn.textContent = headlessMode ? 'üñ•Ô∏è HEADLESS MODE (ON)' : 'üñ•Ô∏è HEADLESS MODE (OFF)';
      ui.headlessBtn.style.background = headlessMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(100, 100, 100, 0.1)';
      ui.headlessBtn.style.borderColor = headlessMode ? '#0f0' : '#888';
      ui.headlessBtn.style.color = headlessMode ? '#0f0' : '#888';
      ui.headlessOverlay.classList.toggle('visible', headlessMode);
    });

    // Toggle handlers - connect to world
    ui.toggleFf.addEventListener('click', () => {
      if (ui.toggleFf.classList.contains('disabled')) return;
      ui.toggleFf.classList.toggle('active');
      world.friendlyFire = ui.toggleFf.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFire) {
        ui.toggleRicochet.classList.add('disabled');
        ui.toggleRicochet.classList.remove('active');
        world.friendlyFireRicochet = false;
      } else {
        ui.toggleRicochet.classList.remove('disabled');
      }
    });

    ui.toggleRicochet.addEventListener('click', () => {
      if (ui.toggleRicochet.classList.contains('disabled')) return;
      ui.toggleRicochet.classList.toggle('active');
      world.friendlyFireRicochet = ui.toggleRicochet.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFireRicochet) {
        ui.toggleFf.classList.add('disabled');
        ui.toggleFf.classList.remove('active');
        world.friendlyFire = false;
      } else {
        ui.toggleFf.classList.remove('disabled');
      }
    });

    // Respawn time slider
    ui.respawnTime.addEventListener('input', (e) => {
      const seconds = parseInt(e.target.value, 10);
      world.respawnTime = seconds;
      ui.respawnTimeValue.textContent = seconds + 's';
    });

    // Health/Armor toggle handlers
    ui.toggleHealth.addEventListener('click', () => {
      ui.toggleHealth.classList.toggle('active');
      world.healthSpawnsEnabled = ui.toggleHealth.classList.contains('active');
    });

    ui.toggleArmor.addEventListener('click', () => {
      ui.toggleArmor.classList.toggle('active');
      world.armorSpawnsEnabled = ui.toggleArmor.classList.contains('active');
    });

    ui.toggleLaser.addEventListener('click', () => {
      ui.toggleLaser.classList.toggle('active');
      world.laserSpawnsEnabled = ui.toggleLaser.classList.contains('active');
    });

    ui.toggleSword.addEventListener('click', () => {
      ui.toggleSword.classList.toggle('active');
      world.swordSpawnsEnabled = ui.toggleSword.classList.contains('active');
    });

    ui.toggleDodge.addEventListener('click', () => {
      ui.toggleDodge.classList.toggle('active');
      world.dodgingEnabled = ui.toggleDodge.classList.contains('active');
    });

    // Sliders
    ui.zoom.addEventListener('input', (e) => {
      renderer.zoom = parseInt(e.target.value, 10) / 100;
      renderer.clampCamera();
      ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    });

    ui.speed.addEventListener('input', (e) => {
      simSpeed = parseInt(e.target.value, 10);
      ui.speedValue.textContent = simSpeed + 'x';
    });

    ui.population.addEventListener('input', (e) => {
      population = parseInt(e.target.value, 10);
      ui.populationValue.textContent = String(population);
      world.spawnAgents(population);
    });

    ui.roundTime.addEventListener('input', (e) => {
      const minutes = parseInt(e.target.value, 10);
      world.setRoundTimeSeconds(minutes * 60);
      ui.roundTimeValue.textContent = String(minutes);
    });
    
    ui.killLimit.addEventListener('input', (e) => {
      world.killLimit = parseInt(e.target.value, 10);
      ui.killLimitValue.textContent = String(world.killLimit);
      ui.killLimitDisplay.textContent = String(world.killLimit);
    });

    // Pause/Reset
    ui.pauseBtn.addEventListener('click', (e) => {
      world.paused = !world.paused;
      e.target.textContent = world.paused ? 'RESUME' : 'PAUSE';
    });

    ui.restartBtn.addEventListener('click', () => {
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      world.spawnAgents(population);
    });

    // Save checkpoint to localStorage
    ui.saveBtn.addEventListener('click', () => {
      const checkpoint = {
        version: '2.8',
        timestamp: Date.now(),
        generation: world.generation,
        teamWins: world.teamWins,
        teamBrains: world.teamBrains.map(b => b ? {
          weightsIH: b.weightsIH.map(row => Array.from(row)),
          weightsHO: b.weightsHO.map(row => Array.from(row)),
          biasH: Array.from(b.biasH),
          biasO: Array.from(b.biasO),
          inputSize: b.inputSize,
          hiddenSize: b.hiddenSize,
          outputSize: b.outputSize
        } : null)
      };
      
      localStorage.setItem('quake-checkpoint', JSON.stringify(checkpoint));
      world.addEvent('üíæ Checkpoint saved! Gen ' + world.generation, 'kill');
      ui.saveBtn.textContent = 'üíæ SAVED!';
      setTimeout(() => ui.saveBtn.textContent = 'üíæ SAVE', 1000);
    });

    // Load checkpoint from localStorage
    ui.loadBtn.addEventListener('click', () => {
      try {
        const data = localStorage.getItem('quake-checkpoint');
        if (!data) {
          alert('No checkpoint found!');
          return;
        }
        
        const checkpoint = JSON.parse(data);
        
        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];
        
        // Restore brains
        world.teamBrains = checkpoint.teamBrains.map(b => {
          if (!b) return null;
          const brain = new NeuralNetwork(b.inputSize, b.hiddenSize, b.outputSize);
          brain.weightsIH = b.weightsIH.map(row => [...row]);
          brain.weightsHO = b.weightsHO.map(row => [...row]);
          brain.biasH = [...b.biasH];
          brain.biasO = [...b.biasO];
          return brain;
        });
        
        // Respawn with loaded brains
        world.spawnAgents(population);
        
        const savedTime = new Date(checkpoint.timestamp).toLocaleTimeString();
        world.addEvent('üìÇ Loaded Gen ' + world.generation + ' (saved ' + savedTime + ')', 'kill');
        ui.loadBtn.textContent = 'üìÇ LOADED!';
        setTimeout(() => ui.loadBtn.textContent = 'üìÇ LOAD', 1000);
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    });

    // Hotkeys: Space pause, R reset, F fullscreen
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        world.paused = !world.paused;
        ui.pauseBtn.textContent = world.paused ? 'RESUME' : 'PAUSE';
      } else if (e.code === 'KeyR') {
        world.generation = 1;
        world.events = [];
        world.teamBrains = [null, null];
        world.spawnAgents(population);
      } else if (e.code === 'KeyF') {
        ui.fullscreenBtn.click();
      }
    });

    // Resize
    window.addEventListener('resize', () => renderer.resize());

    // --------------------
    // Game loop (fixed timestep)
    // --------------------
    const FIXED_DT = 1 / 60;
    let accumulator = 0;
    let lastTime = performance.now();

    // UPS tracking
    let upsCounter = 0;
    let upsTimer = 0;
    let currentUps = 60;

    let uiTimer = 0;
    const UI_INTERVAL = 0.2; // seconds

    function drawUI(dt) {
      uiTimer += dt;
      if (uiTimer < UI_INTERVAL) return;
      uiTimer = 0;

      ui.gen.textContent = world.generation;
      ui.alive.textContent = world.agents.filter(a => a.alive).length;
      ui.time.textContent = Math.ceil(world.timeLeft) + 's';
      
      // UPS display with color coding
      ui.ups.textContent = currentUps;
      if (currentUps >= 55) {
        ui.ups.style.color = '#00ff9d';
      } else if (currentUps >= 30) {
        ui.ups.style.color = '#ffc800';
      } else {
        ui.ups.style.color = '#ff4444';
      }
      
      // Team scores (new layout)
      ui.redScore.textContent = world.teamKills[0];
      ui.blueScore.textContent = world.teamKills[1];
      ui.redWins.textContent = world.teamWins[0];
      ui.blueWins.textContent = world.teamWins[1];

      // Field items (dynamic based on active toggles with actual counts)
      const healthCount = world.pickups.filter(p => p.type === 'health').length;
      const armorCount = world.pickups.filter(p => p.type === 'armor').length;
      const laserCount = world.pickups.filter(p => p.type === 'laser').length;
      const swordCount = world.pickups.filter(p => p.type === 'sword').length;
      
      let fieldItemsHtml = '';
      if (ui.toggleHealth.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="Heals 50HP instantly"><span>ü©π Health</span><span class="stat-value">' + healthCount + '</span></div>';
      }
      if (ui.toggleArmor.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="+50 armor per pickup, max 100"><span>üõ°Ô∏è Armor</span><span class="stat-value">' + armorCount + '</span></div>';
      }
      if (ui.toggleLaser.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="3s charge, instant kill beam"><span>‚ö° Laser</span><span class="stat-value">' + laserCount + '</span></div>';
      }
      if (ui.toggleSword.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="Hold to charge, release to lunge"><span>üó°Ô∏è Sword</span><span class="stat-value">' + swordCount + '</span></div>';
      }
      if (!fieldItemsHtml) {
        fieldItemsHtml = '<div class="stat-row" style="opacity: 0.5; font-size: 0.75rem;">No active spawns</div>';
      }
      ui.fieldItemsList.innerHTML = fieldItemsHtml;

      // This round leaderboard
      ui.leaderboard.innerHTML = world.getLeaderboard().map((a, i) => {
        const status = a.alive ? '' : (a.respawnTimer > 0 ? ' (' + Math.ceil(a.respawnTimer) + 's)' : '');
        const kd = a.kills + '/' + a.deaths;
        return '<div class="leader-entry ' + (a.alive ? '' : 'dead') + '" style="border-left: 2px solid ' + (a.team === 0 ? '#ff4444' : '#4488ff') + '">' +
          '<span class="name" style="color: ' + (a.team === 0 ? '#ff8888' : '#88aaff') + '">' + a.name + status + '</span>' +
          '<span class="score">' + a.score + '</span>' +
        '</div>';
      }).join('');

      // All-time legends leaderboard
      const allTimeSorted = [...world.agents].sort((a, b) => b.totalKills - a.totalKills).slice(0, 5);
      ui.alltimeLeaderboard.innerHTML = allTimeSorted.map((a, i) => {
        const medal = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : ''));
        return '<div class="leader-entry" style="border-left: 2px solid ' + (a.team === 0 ? '#ff4444' : '#4488ff') + '">' +
          '<span class="name" style="color: ' + (a.team === 0 ? '#ff8888' : '#88aaff') + '">' + medal + ' ' + a.name + '</span>' +
          '<span class="score">' + a.totalKills + 'K</span>' +
        '</div>';
      }).join('');

      ui.log.innerHTML = world.events.slice(0, 10).map(e =>
        '<div class="event"><span class="' + e.type + '">' + e.text + '</span></div>'
      ).join('');
    }

    function gameLoop(curr) {
      const realDt = Math.min((curr - lastTime) / 1000, 0.1);
      lastTime = curr;

      // UPS tracking
      upsTimer += realDt;
      if (upsTimer >= 1.0) {
        currentUps = upsCounter;
        upsCounter = 0;
        upsTimer = 0;
      }

      // scale by simSpeed into the simulation accumulator
      accumulator += realDt * simSpeed;

      // prevent spiral of death - but allow more steps in headless mode
      const maxSteps = headlessMode ? 100 : 12;
      let steps = 0;
      while (accumulator >= FIXED_DT && steps < maxSteps) {
        world.update(FIXED_DT);
        accumulator -= FIXED_DT;
        steps++;
        upsCounter++;
      }
      // if we hit max steps, drop the rest to keep UI responsive
      if (steps === maxSteps) accumulator = 0;

      // Only render if not headless
      if (!headlessMode) {
        renderer.render();
      }
      drawUI(realDt);

      requestAnimationFrame(gameLoop);
    }

    // Initialize UI values
    ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    ui.speedValue.textContent = simSpeed + 'x';
    ui.populationValue.textContent = String(population);
    ui.roundTimeValue.textContent = String(parseInt(ui.roundTime.value, 10));
    ui.killLimitValue.textContent = String(world.killLimit);

    requestAnimationFrame(gameLoop);
  })();
  </script>

</body>
</html>
