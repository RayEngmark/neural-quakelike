<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NEURAL QUAKE ARENA // V3.0</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #050508;
      --panel-bg: rgba(10, 15, 30, 0.75);
      --panel-border: rgba(100, 200, 255, 0.15);
      --neon-blue: #00f3ff;
      --neon-pink: #ff0055;
      --neon-green: #00ff9d;
      --neon-yellow: #ffd700;
      --text-main: #e0e6ed;
      --text-muted: #8892b0;
      --font-display: 'Rajdhani', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg-dark);
      color: var(--text-main);
      font-family: var(--font-display);
      overflow: hidden;
      height: 100vh;
      background-image:
        radial-gradient(circle at 50% 50%, #1a1a2e 0%, #050510 100%);
    }

    /* === LAYOUT === */
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* TOP BAR */
    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 30px;
      height: 80px;
      background: rgba(5, 5, 10, 0.9);
      border-bottom: 1px solid var(--panel-border);
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    .team-block {
      display: flex;
      align-items: center;
      gap: 20px;
      min-width: 200px;
    }

    .team-block.red { justify-content: flex-start; color: var(--neon-pink); }
    .team-block.blue { justify-content: flex-end; flex-direction: row-reverse; color: var(--neon-blue); }

    .team-score { text-align: center; }
    .team-score .score {
      font-family: var(--font-mono);
      font-size: 3rem;
      font-weight: 800;
      line-height: 1;
      text-shadow: 0 0 15px currentColor;
    }
    .team-score .label {
      font-size: 0.7rem;
      letter-spacing: 2px;
      opacity: 0.8;
      margin-top: 5px;
    }

    .team-wins {
      background: rgba(255, 255, 255, 0.03);
      padding: 5px 15px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.05);
      text-align: center;
    }
    .team-wins .wins { font-family: var(--font-mono); font-size: 1.2rem; font-weight: bold; }
    .team-wins .label { font-size: 0.5rem; text-transform: uppercase; opacity: 0.5; }

    #center-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      min-width: 250px;
    }

    .mode-selector {
      display: flex;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 20px;
      padding: 2px;
      border: 1px solid var(--panel-border);
    }
    .mode-selector button {
      padding: 4px 12px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-family: var(--font-mono);
      font-size: 0.6rem;
      font-weight: bold;
      cursor: pointer;
      border-radius: 16px;
      transition: all 0.2s;
    }
    .mode-selector button.active {
      background: var(--neon-green);
      color: #000;
      box-shadow: 0 0 10px rgba(0, 255, 157, 0.3);
    }

    #center-info .big {
      font-family: var(--font-mono);
      font-size: 1.5rem;
      color: var(--neon-green);
      text-shadow: 0 0 10px rgba(0, 255, 157, 0.5);
    }
    #center-info .sub { font-size: 0.6rem; letter-spacing: 2px; color: var(--text-muted); text-transform: uppercase; }

    /* MAIN AREA */
    #main-area {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    /* SIDEBARS */
    #left-sidebar, #right-sidebar {
      width: 280px;
      background: var(--panel-bg);
      backdrop-filter: blur(12px);
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      flex-shrink: 0;
      z-index: 5;
      border-right: 1px solid var(--panel-border);
    }
    #right-sidebar { border-right: none; border-left: 1px solid var(--panel-border); }

    /* CANVAS */
    #canvas-container {
      flex: 1;
      position: relative;
      background: #000;
      overflow: hidden;
      box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
    }
    canvas { display: block; width: 100%; height: 100%; }

    /* PANELS */
    .panel {
      background: rgba(20, 25, 40, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 5px;
      position: relative;
      transition: all 0.2s;
    }
    .panel:hover { border-color: rgba(255, 255, 255, 0.15); }

    /* Decorative corners */
    .panel::before, .panel::after {
      content: ''; position: absolute; width: 6px; height: 6px;
      border: 1px solid var(--neon-blue); opacity: 0.5;
      transition: opacity 0.2s;
    }
    .panel:hover::before, .panel:hover::after { opacity: 1; box-shadow: 0 0 5px var(--neon-blue); }
    .panel::before { top: -1px; left: -1px; border-bottom: none; border-right: none; }
    .panel::after { bottom: -1px; right: -1px; border-top: none; border-left: none; }

    .panel h2 {
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--neon-blue);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0.9;
    }

    /* STAT ROWS */
    .stat-row {
      display: flex; justify-content: space-between;
      padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
      font-size: 0.8rem; color: var(--text-muted);
    }
    .stat-value { font-family: var(--font-mono); color: var(--text-main); font-weight: bold; }

    /* CONTROLS (Inputs) */
    .control-row { display: flex; align-items: center; gap: 10px; margin: 8px 0; }
    .control-row label { width: 50px; font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }
    .control-row .value { width: 40px; text-align: right; font-family: var(--font-mono); font-size: 0.7rem; color: var(--neon-blue); }

    input[type="range"] {
      -webkit-appearance: none; flex: 1; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 12px; height: 12px; background: var(--neon-blue); border-radius: 50%;
      box-shadow: 0 0 10px var(--neon-blue); cursor: pointer; transition: transform 0.1s;
    }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.3); }

    /* TOGGLES */
    .toggle-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.03); }
    .toggle-row label { font-size: 0.8rem; color: var(--text-main); }

    .toggle {
      width: 36px; height: 18px; background: rgba(255,255,255,0.1); border-radius: 9px;
      position: relative; cursor: pointer; transition: 0.3s;
    }
    .toggle::after {
      content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px;
      background: #888; border-radius: 50%; transition: 0.3s;
    }
    .toggle.active { background: rgba(0, 255, 157, 0.2); border: 1px solid rgba(0, 255, 157, 0.5); }
    .toggle.active::after { left: 18px; background: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); }

    /* BUTTONS */
    .btn-row { display: flex; gap: 10px; margin-top: 10px; }
    button {
      flex: 1; padding: 10px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05);
      color: var(--text-main); font-family: var(--font-mono); font-size: 0.75rem; font-weight: bold;
      cursor: pointer; transition: all 0.2s; border-radius: 4px; text-transform: uppercase;
    }
    button:hover { background: rgba(255,255,255,0.1); border-color: var(--neon-blue); color: var(--neon-blue); box-shadow: 0 0 15px rgba(0, 243, 255, 0.2); }

    /* CONTROL BAR (Floating) */
    #control-bar {
      position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 10px; padding: 10px 20px;
      background: rgba(10, 15, 30, 0.9); border: 1px solid var(--panel-border);
      border-radius: 40px; backdrop-filter: blur(10px); z-index: 100;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    #control-bar button {
      width: 44px; height: 44px; border-radius: 50%; padding: 0;
      display: flex; align-items: center; justify-content: center;
      background: transparent; border: 1px solid rgba(255,255,255,0.2);
    }
    #control-bar button.play-btn { width: 54px; height: 54px; border-color: var(--neon-green); color: var(--neon-green); box-shadow: 0 0 15px rgba(0,255,157,0.2); }
    #control-bar button:hover { transform: translateY(-2px); }
    #control-bar button svg { width: 20px; height: 20px; }

    /* LEADERBOARD & LOGS */
    #leaderboard, #event-log { font-family: var(--font-mono); font-size: 0.75rem; }
    .leader-entry {
      display: flex; justify-content: space-between; padding: 4px 8px; margin-bottom: 2px;
      background: rgba(255,255,255,0.02); border-radius: 2px;
    }
    .event { padding: 3px 0; opacity: 0.8; }

    /* SCROLLBAR */
    ::-webkit-scrollbar { width: 5px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }

    /* AGENT PROFILE */
    #agent-profile { border-top: 1px solid var(--panel-border); margin-top: 10px; padding-top: 10px; }
    .profile-bars .bar-row { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
    .bar-track { flex: 1; height: 6px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
    .health-fill { background: var(--neon-pink); height: 100%; transition: width 0.2s; }
    .armor-fill { background: var(--neon-blue); height: 100%; transition: width 0.2s; }

    /* UTILS */
    .hidden { display: none !important; }

    /* Pre-Sim Overlay */
    #pre-sim-screen {
      position: absolute; inset: 0; background: rgba(5,5,8,0.95); z-index: 200;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    #pre-sim-screen .start-btn {
      background: var(--neon-green); color: #000; padding: 15px 40px; font-size: 1.2rem;
      border: none; margin-top: 30px;
    }

    /* Headless Overlay */
    #headless-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(5, 5, 10, 0.85); backdrop-filter: blur(5px);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        z-index: 50; opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    #headless-overlay.visible { opacity: 1; pointer-events: auto; }
  </style>
</head>
<body>
  <div id="app">
    <!-- TOP BAR: Scores & Match Info -->
    <div id="top-bar">
      <div class="team-block red">
        <div class="team-wins">
          <div class="wins" id="red-wins">0</div>
          <div class="label">wins</div>
        </div>
        <div class="team-score">
          <div class="score" id="red-score">0</div>
          <div class="label">üî¥ RED</div>
        </div>
      </div>

  <div id="center-info">
    <div class="mode-selector">
      <button id="mode-rounds" class="active">Rounds</button>
      <button id="mode-persistent">Persistent</button>
    </div>
    <div class="big" id="kill-limit-display">50</div>
    <div class="sub" id="mode-sub">first to</div>
  </div>

  <button id="stats-btn" title="Stats & Info">‚ò∞</button>

  <div class="team-block blue">
    <div class="team-score">
      <div class="score" id="blue-score">0</div>
      <div class="label">BLUE üîµ</div>
    </div>
    <div class="team-wins">
      <div class="wins" id="blue-wins">0</div>
      <div class="label">wins</div>
    </div>
  </div>
</div>

<!-- MAIN AREA -->
<div id="main-area">
  <!-- LEFT SIDEBAR: Stats & Controls -->
  <div id="left-sidebar">
    <div class="panel" data-panel-id="status">
      <h2>// Status</h2>
      <div class="stat-row" id="generation-row">
        <span>Generation</span>
        <span class="stat-value" id="generation">1</span>
      </div>
      <div class="stat-row">
        <span>Alive</span>
        <span class="stat-value" id="alive">100</span>
      </div>
      <div class="stat-row">
        <span>Time</span>
        <span class="stat-value" id="time-left">60s</span>
      </div>
    </div>

    <div class="panel" data-panel-id="parameters">
      <h2>// Parameters</h2>
      <div class="control-row">
        <label>Zoom</label>
        <input type="range" id="zoom" min="25" max="300" value="100" />
        <span class="value" id="zoom-value">1.0x</span>
      </div>
      <div class="control-row">
        <label>Speed</label>
        <input type="range" id="speed" min="1" max="20" value="1" />
        <span class="value" id="speed-value">1x</span>
      </div>
      <div class="control-row">
        <label>Pop</label>
        <input type="range" id="population" min="20" max="200" value="100" step="10" />
        <span class="value" id="population-value">100</span>
      </div>
      <div class="control-row">
        <label>Time</label>
        <input type="range" id="round-time" min="1" max="10" value="1" step="1" />
        <span class="value" id="round-time-value">1m</span>
      </div>
      <div class="control-row">
        <label>Kills</label>
        <input type="range" id="kill-limit" min="10" max="100" value="50" step="5" />
        <span class="value" id="kill-limit-value">50</span>
      </div>
      <div class="control-row">
        <label>Respawn</label>
        <input type="range" id="respawn-time" min="1" max="10" value="3" step="1" />
        <span class="value" id="respawn-time-value">3s</span>
      </div>
    </div>

    <div class="panel" data-panel-id="controls">
      <h2>// Advanced</h2>
      <div class="btn-row">
        <button id="copy-btn" style="background: rgba(0, 255, 100, 0.2); border-color: #00ff64; color: #00ff64;">üìã COPY</button>
        <button id="demo-btn" style="background: rgba(255, 200, 0, 0.2); border-color: #ffc800; color: #ffc800;">üéÆ DEMO</button>
      </div>
      <div class="btn-row" style="margin-top:10px;">
        <button id="debug-sword-btn" style="background: rgba(255, 0, 255, 0.1); border-color: #ff00ff; color: #ff00ff;">üó°Ô∏è ALL SWORD</button>
        <button id="debug-laser-btn" style="background: rgba(0, 200, 255, 0.1); border-color: #00aaff; color: #00aaff;">‚ö° ALL LASER</button>
      </div>
      <input type="file" id="load-file" accept=".json" />
      <!-- Hidden elements for compatibility with existing code -->
      <button id="pause-btn" style="display:none;">PAUSE</button>
      <button id="restart-btn" style="display:none;">RESET</button>
      <button id="save-btn" style="display:none;">SAVE</button>
      <button id="load-btn" style="display:none;">LOAD</button>
      <button id="headless-btn" style="display:none;">HEADLESS</button>
      <button id="turbo-btn" style="display:none;">TURBO</button>
    </div>

    <div class="panel" data-panel-id="leaderboard">
      <h2>// Leaderboard</h2>
      <div id="leaderboard"></div>
    </div>
  </div>

  <!-- CANVAS -->
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="headless-overlay">
      <div class="icon">üñ•Ô∏è</div>
      <h2>Simulation Running in Headless Mode</h2>
      <p>Rendering is disabled for faster simulation speed.</p>
      <div class="hint">Toggle <strong>üñ•Ô∏è HEADLESS</strong> in Controls to view the battle.</div>
    </div>
    <!-- Pre-simulation info screen -->
    <div id="pre-sim-screen">
      <div class="mode-title" id="pre-sim-title">ROUNDS MODE</div>
      <div class="mode-subtitle" id="pre-sim-subtitle">Generation-based Evolution</div>
      <div class="mode-description" id="pre-sim-description">
        Teams battle in timed rounds. After each round, the losing team evolves by learning from the winners. Watch neural networks improve over generations.
      </div>
      <div class="mode-features" id="pre-sim-features">
        <div class="feature"><span class="icon">‚è±Ô∏è</span> Timed rounds with kill limit</div>
        <div class="feature"><span class="icon">üß¨</span> Losers evolve after each round</div>
        <div class="feature"><span class="icon">üèÜ</span> Track wins across generations</div>
      </div>
      <button class="start-btn" id="start-sim-btn">START SIMULATION</button>
    </div>
  </div>

  <!-- RIGHT SIDEBAR: Game Modifiers -->
  <div id="right-sidebar">
    <div class="panel" data-panel-id="modifiers">
      <h2>// Game Modifiers</h2>
      <div class="toggle-row" title="Spawns health packs every 10s. Instant 50HP + 50HP regen over 5s.">
        <label>ü©π Health Spawns</label>
        <div class="toggle active" id="toggle-health"></div>
      </div>
      <div class="toggle-row" title="Spawns armor pickups every 10s. +50 armor per pickup, max 100.">
        <label>üõ°Ô∏è Armor Spawns</label>
        <div class="toggle active" id="toggle-armor"></div>
      </div>
      <div class="toggle-row" title="Laser weapons spawn at map center when half kills/time reached. 3s charge, instant kill beam.">
        <label>‚ö° Laser Drops</label>
        <div class="toggle active" id="toggle-laser"></div>
      </div>
      <div class="toggle-row" title="Energy swords spawn at map center. Hold to aim (instant max charge), release to lunge. One-hit kill.">
        <label>üó°Ô∏è Sword Drops</label>
        <div class="toggle active" id="toggle-sword"></div>
      </div>
      <div class="toggle-row" title="Agents can dash/dodge in any direction. 6 second cooldown.">
        <label>üí® Dodging</label>
        <div class="toggle active" id="toggle-dodge"></div>
      </div>
      <div class="toggle-row" title="Teleporters activate randomly during round for 30 seconds. Quick map traversal.">
        <label>üåÄ Teleporters</label>
        <div class="toggle active" id="toggle-teleporter"></div>
      </div>
      <div class="toggle-row" style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;" title="Rockets damage teammates directly.">
        <label>üí• Friendly Fire</label>
        <div class="toggle" id="toggle-ff"></div>
      </div>
      <div class="toggle-row" title="Teammate damage reflects back to shooter.">
        <label>üîÑ FF Ricochet</label>
        <div class="toggle" id="toggle-ricochet"></div>
      </div>
    </div>

    <!-- Agent Profile Card (shown when following) -->
    <div class="panel" id="agent-profile" data-panel-id="agent-profile" style="display: none;">
      <h2>// Agent Profile</h2>

      <div id="profile-header">
        <div class="agent-name" id="profile-name">-</div>
        <div class="agent-team" id="profile-team">-</div>
      </div>

      <div class="profile-section">
        <div class="profile-bars">
          <div class="bar-row">
            <span class="bar-label">HP</span>
            <div class="bar-track health-track">
              <div class="bar-fill health-fill" id="profile-health-bar"></div>
            </div>
            <span class="bar-value" id="profile-health-val">100</span>
          </div>
          <div class="bar-row">
            <span class="bar-label">AR</span>
            <div class="bar-track armor-track">
              <div class="bar-fill armor-fill" id="profile-armor-bar"></div>
            </div>
            <span class="bar-value" id="profile-armor-val">0</span>
          </div>
        </div>
      </div>

      <div class="profile-section">
        <div class="stat-row">
          <span>Weapon</span>
          <span class="stat-value" id="profile-weapon">Rocket</span>
        </div>
        <div class="stat-row">
          <span>K/D</span>
          <span class="stat-value" id="profile-kd">0/0</span>
        </div>
      </div>

      <div class="profile-section">
        <div class="section-label">Neural Activity</div>
        <div class="neural-grid">
          <div class="neural-indicator">
            <div class="indicator-bar" id="neural-turn"></div>
            <span>Turn</span>
          </div>
          <div class="neural-indicator">
            <div class="indicator-bar" id="neural-speed"></div>
            <span>Speed</span>
          </div>
          <div class="neural-indicator">
            <div class="indicator-bar" id="neural-strafe"></div>
            <span>Strafe</span>
          </div>
          <div class="neural-indicator">
            <div class="indicator-light" id="neural-shoot"></div>
            <span>Fire</span>
          </div>
          <div class="neural-indicator">
            <div class="indicator-light" id="neural-dash"></div>
            <span>Dash</span>
          </div>
        </div>
      </div>

      <div class="profile-section">
        <div class="section-label">Awareness</div>
        <div class="awareness-row">
          <span>Enemy</span>
          <span class="awareness-value" id="awareness-enemy">None</span>
        </div>
        <div class="awareness-row">
          <span>Ally</span>
          <span class="awareness-value" id="awareness-ally">None</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Slide-in Stats Panel -->
<div id="stats-panel">
  <button class="close-btn" id="stats-close">&times;</button>

  <h3>üìä Simulation</h3>
  <div class="stat-row">
    <span>Mode</span>
    <span class="stat-value" id="stats-mode">Rounds</span>
  </div>
  <div class="stat-row" id="stats-total-lives-row">
    <span>Total Lives</span>
    <span class="stat-value" id="stats-total-lives">0</span>
  </div>
  <div class="stat-row">
    <span>Sim Speed</span>
    <span class="stat-value" id="stats-ups">60</span>
  </div>

  <h3>‚öîÔ∏è Weapon Kills</h3>
  <div class="stat-row">
    <span>üöÄ Rocket</span>
    <span class="stat-value" id="stats-rocket-kills" style="color: #ff8800;">0 / 0</span>
  </div>
  <div class="stat-row">
    <span>‚ö° Laser</span>
    <span class="stat-value" id="stats-laser-kills" style="color: #00aaff;">0 / 0</span>
  </div>
  <div class="stat-row">
    <span>üó°Ô∏è Sword</span>
    <span class="stat-value" id="stats-sword-kills" style="color: #ff00ff;">0 / 0</span>
  </div>

  <h3>üèÜ Overall Kill Leaderboard</h3>
  <div id="stats-leaderboard" class="team-section">
    <div style="opacity: 0.5; font-size: 0.75rem;">No data yet</div>
  </div>

  <div id="hof-section">
    <h3>üî¥ Red Hall of Fame</h3>
    <div id="stats-red-hof" class="team-section">
      <div style="opacity: 0.5; font-size: 0.75rem;">No entries yet</div>
    </div>

    <h3>üîµ Blue Hall of Fame</h3>
    <div id="stats-blue-hof" class="team-section">
      <div style="opacity: 0.5; font-size: 0.75rem;">No entries yet</div>
    </div>

    <button id="clear-hof-btn" style="width: 100%; margin-top: 5px; background: rgba(255, 50, 50, 0.2); border: 1px solid #ff3333; color: #ff6666; padding: 8px; border-radius: 4px; cursor: pointer;">üóëÔ∏è Clear Hall of Fame</button>
  </div>

  <h3>üìú Combat Log</h3>
  <div id="stats-combat-log" style="max-height: 200px; overflow-y: auto; font-size: 0.75rem;"></div>
</div>

<!-- Floating Control Bar -->
<div id="control-bar">
  <div class="control-group">
    <button id="ctrl-save" title="Save checkpoint">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>
    </button>
    <button id="ctrl-load" title="Load checkpoint">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"/></svg>
    </button>
  </div>

  <div class="control-group main-controls">
    <button id="ctrl-reset" title="Reset simulation">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
    </button>
    <button id="ctrl-play" class="play-btn" title="Play/Pause">
      <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
      <svg class="pause-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </button>
  </div>

  <div class="control-group">
    <button id="ctrl-headless" title="Headless Mode" data-tooltip="Headless Mode">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H3V4h18v12z"/></svg>
    </button>
    <button id="ctrl-performance" title="Performance Mode" data-tooltip="Performance Mode">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 2.05v2.02c3.95.49 7 3.85 7 7.93 0 3.21-1.92 6-4.72 7.28L13 17v5h5l-1.22-1.22C19.91 19.07 22 15.76 22 12c0-5.18-3.95-9.45-9-9.95zM11 2.05C5.95 2.55 2 6.81 2 12c0 3.76 2.09 7.07 5.16 8.78L6 22h5v-5l-2.28 2.28C6.08 18 4.5 15.21 4.5 12c0-4.08 3.05-7.44 7-7.93V2.05z"/></svg>
    </button>
  </div>
</div>

  <script>
  (() => {
    'use strict';

    // --------------------
    // Utility
    // --------------------
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    // Format time in MM:SS format
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    // --------------------
    // Demo Checkpoint (pre-trained AI for visitors)
    // To update: Save a checkpoint, then run in console:
    // copy(localStorage.getItem('quake-checkpoint'))
    // and paste the result below (replacing null)
    // --------------------
    const DEMO_CHECKPOINT = null;

    // --------------------
    // Turbo Mode (ultra performance for training)
    // --------------------
    let turboMode = false;
    let forceWeapon = null; // 'sword', 'laser', or null - persists weapons after death
    let persistentMode = false; // Persistent per-life evolution mode

    // --------------------
    // Hall of Fame (for persistent mode)
    // --------------------
    const HOF_MAX_SIZE = 100; // Max entries per team
    const hallOfFame = [[], []]; // [redTeamHoF, blueTeamHoF]
    let totalLivesEvaluated = 0;

    // Hall of Fame entry structure:
    // { score, brain (cloned weights), kills, deaths, damageDealt, survivalTime, timestamp }

    function addToHallOfFame(team, entry) {
      hallOfFame[team].push(entry);
      hallOfFame[team].sort((a, b) => b.score - a.score);
      if (hallOfFame[team].length > HOF_MAX_SIZE) {
        hallOfFame[team].length = HOF_MAX_SIZE;
      }
    }

    // Tournament selection - pick best of k random candidates
    function selectParentFromHoF(team, tournamentSize = 5) {
      const hof = hallOfFame[team];
      if (hof.length === 0) return null;
      if (hof.length === 1) return hof[0];

      let best = null;
      for (let i = 0; i < Math.min(tournamentSize, hof.length); i++) {
        const idx = Math.floor(Math.random() * hof.length);
        const candidate = hof[idx];
        if (!best || candidate.score > best.score) {
          best = candidate;
        }
      }
      return best;
    }

    // Get mutation rate based on parent's rank in HoF
    function getMutationRateForRank(team, parentEntry) {
      const hof = hallOfFame[team];
      const rank = hof.indexOf(parentEntry);
      if (rank === -1 || hof.length <= 1) return { rate: 0.15, strength: 0.3 };

      // Top 10% get low mutation, bottom gets higher
      const percentile = rank / hof.length;
      const rate = 0.05 + percentile * 0.2; // 0.05 to 0.25
      const strength = 0.1 + percentile * 0.4; // 0.1 to 0.5
      return { rate, strength };
    }

    function clearHallOfFame() {
      hallOfFame[0] = [];
      hallOfFame[1] = [];
      totalLivesEvaluated = 0;
    }

    // --------------------
    // Names
    // --------------------
    const FIRST_NAMES = ['Ole', 'Lars', 'Erik', 'Anders', 'Magnus', 'Henrik', 'Jonas', 'Marius', 'Kristian', 'Thomas', 'Astrid', 'Ingrid', 'Solveig', 'Freya', 'Sigrid', 'Nora', 'Emma', 'Maja', 'Thea', 'Ella', 'Bj√∏rn', 'Torstein', 'Gunnar', 'H√•kon', 'Leif', 'Ragnar', 'Sven', 'Olav', 'Knut', 'Arne', 'Liv', 'Grete', 'Kari', 'Anne', 'James', 'John', 'William', 'David', 'Richard', 'Mary', 'Patricia', 'Jennifer', 'Linda', 'Elizabeth', 'Michael', 'Christopher', 'Joshua', 'Andrew', 'Brandon', 'Emily', 'Hannah', 'Madison', 'Ashley', 'Olivia', 'Jack', 'Harry', 'Oliver', 'George', 'Charlie', 'Grace', 'Chloe', 'Lily', 'Mia', 'Ruby', 'Viktor', 'Felix', 'Oscar', 'Sebastian', 'Adrian', 'Aurora', 'Emilie', 'Hedda', 'Sara', 'Julie'];
    const LAST_NAMES = ['Hansen', 'Johansen', 'Olsen', 'Larsen', 'Andersen', 'Pedersen', 'Nilsen', 'Kristiansen', 'Jensen', 'Karlsen', 'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Miller', 'Davis', 'Garcia', 'Rodriguez', 'Wilson', 'Martinez', 'Anderson', 'Taylor', 'Thomas', 'Moore', 'Martin', 'Jackson', 'Thompson', 'White', 'Lopez'];

    // --------------------
    // Neural net
    // --------------------
    class NeuralNetwork {
      constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize, hiddenSize);
        this.biasH = new Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
        this.biasO = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
      }
      randomMatrix(rows, cols, fanIn) {
        const scale = Math.sqrt(2 / fanIn);
        const m = new Array(rows);
        for (let r = 0; r < rows; r++) {
          const row = new Array(cols);
          for (let c = 0; c < cols; c++) row[c] = (Math.random() - 0.5) * 2 * scale;
          m[r] = row;
        }
        return m;
      }
      activate(x) { return Math.tanh(x); }
      forward(inputs) {
        // Safe pad/truncate so we always use the full weight matrix.
        const x = (inputs.length === this.inputSize)
          ? inputs
          : inputs.length > this.inputSize
            ? inputs.slice(0, this.inputSize)
            : inputs.concat(new Array(this.inputSize - inputs.length).fill(0));

        const hidden = new Array(this.hiddenSize);
        for (let i = 0; i < this.hiddenSize; i++) {
          let sum = this.biasH[i];
          const w = this.weightsIH[i];
          for (let j = 0; j < this.inputSize; j++) sum += w[j] * x[j];
          hidden[i] = this.activate(sum);
        }

        const out = new Array(this.outputSize);
        for (let i = 0; i < this.outputSize; i++) {
          let sum = this.biasO[i];
          const w = this.weightsHO[i];
          for (let j = 0; j < this.hiddenSize; j++) sum += w[j] * hidden[j];
          out[i] = this.activate(sum);
        }
        return out;
      }
      clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(row => row.slice());
        nn.weightsHO = this.weightsHO.map(row => row.slice());
        nn.biasH = this.biasH.slice();
        nn.biasO = this.biasO.slice();
        return nn;
      }
      mutate(rate = 0.1, strength = 0.3) {
        const mutateVal = (v) => (Math.random() < rate ? v + (Math.random() - 0.5) * 2 * strength : v);
        const mutateArr = (arr) => { for (let i = 0; i < arr.length; i++) arr[i] = mutateVal(arr[i]); };
        const mutateMat = (mat) => { for (let r = 0; r < mat.length; r++) mutateArr(mat[r]); };
        mutateMat(this.weightsIH);
        mutateMat(this.weightsHO);
        mutateArr(this.biasH);
        mutateArr(this.biasO);
      }
    }

    // --------------------
    // Pickups
    // --------------------
    class BowPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class KnifePickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }
    class SniperPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class ShotgunPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class BazookaPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 22; this.pickedUp = false; this.spawnTime = Date.now(); } }
    class HealingPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; this.healAmount = 50; } }
    class ArmorPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }

    // --------------------
    // Projectiles
    // --------------------
    class Arrow {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 350; this.damage = 50; this.maxRange = 1200;
        this.distanceTraveled = 0; this.alive = true; this.radius = 5;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class Bullet {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 800; this.damage = 100; this.maxRange = 2000;
        this.distanceTraveled = 0; this.alive = true; this.radius = 3;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class ShotgunBlast {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.nearRange = 80; this.farRange = 150; this.spreadAngle = Math.PI / 4;
        this.maxTime = 0.2; this.timer = 0; this.active = true;
        this.hasDealtNearDamage = false; this.hasDealtFarDamage = false;
        this.currentRadius = 0; this.speed = 800;
      }
      update(dt, agents, world) {
        if (!this.active) return;
        this.timer += dt;
        this.currentRadius = this.timer * this.speed;
        if (!this.hasDealtNearDamage && this.currentRadius >= this.nearRange) {
          this.hasDealtNearDamage = true;
          this.dealDamageInRange(agents, world, 0, this.nearRange, 100);
        }
        if (!this.hasDealtFarDamage && this.currentRadius >= this.farRange) {
          this.hasDealtFarDamage = true;
          this.dealDamageInRange(agents, world, this.nearRange, this.farRange, 50);
        }
        if (this.timer >= this.maxTime) this.active = false;
      }
      dealDamageInRange(agents, world, minDist, maxDist, damage) {
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = agent.x - this.x, dy = agent.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist || dist > maxDist) continue;

          let angleToAgent = Math.atan2(dy, dx);
          let angleDiff = angleToAgent - this.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          if (Math.abs(angleDiff) > this.spreadAngle) continue;

          const killed = agent.takeDamage(damage, this.owner, world);
          this.owner.damageDealt += damage;
          this.owner.lifeDamageDealt += damage;
          world.addEvent(this.owner.name + ' blasted ' + agent.name, 'damage');
          if (killed) {
            this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
            this.owner.lifeKills++;
            world.teamKills[this.owner.team]++;
            this.owner.killScore += 50;
            world.addEvent(this.owner.name + ' killed ' + agent.name + '!', 'kill');
          }
        }
      }
    }

    class Rocket {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 280; // Slower than arrows (350)
        this.maxRange = 1500;
        this.distanceTraveled = 0;
        this.alive = true;
        this.radius = 8;
        this.explosionRadius = 120;
        this.damage = 200; // Instakill in center
        // Trail particles
        this.trail = [];
        this.trailTimer = 0;
      }
      update(dt, agents, obstacles, world) {
        if (!this.alive) return null;
        
        // Wobbly flight path for visual fun
        const wobble = Math.sin(this.distanceTraveled * 0.05) * 0.02;
        const moveAngle = this.angle + wobble;
        
        const moveX = Math.cos(moveAngle) * this.speed * dt;
        const moveY = Math.sin(moveAngle) * this.speed * dt;
        this.x += moveX;
        this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        
        // Add smoke trail particles
        this.trailTimer += dt;
        if (this.trailTimer > 0.02) {
          this.trailTimer = 0;
          this.trail.push({
            x: this.x - Math.cos(this.angle) * 15,
            y: this.y - Math.sin(this.angle) * 15,
            life: 1,
            size: 8 + Math.random() * 6,
            vx: (Math.random() - 0.5) * 30,
            vy: (Math.random() - 0.5) * 30
          });
        }
        
        // Update trail
        for (const p of this.trail) {
          p.life -= dt * 2;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.size *= 0.98;
        }
        this.trail = this.trail.filter(p => p.life > 0);
        
        // Max range - explode
        if (this.distanceTraveled >= this.maxRange) {
          this.alive = false;
          return { type: 'explode', x: this.x, y: this.y };
        }
        
        // Hit obstacle - explode
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        // Hit agent - explode
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        return null;
      }
    }

    class Explosion {
      constructor(x, y, owner, radius, damage) {
        this.x = x;
        this.y = y;
        this.owner = owner;
        this.radius = radius;
        this.damage = damage;
        this.maxTime = 0.6;
        this.timer = 0;
        this.hasDealtDamage = false;
        this.currentRadius = 0;
        // Shockwave rings
        this.rings = [];
        // Debris particles
        this.particles = [];
        for (let i = 0; i < 40; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 150 + Math.random() * 350;
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.4 + Math.random() * 0.4,
            size: 3 + Math.random() * 8,
            color: Math.random() > 0.5 ? '#ff6600' : (Math.random() > 0.5 ? '#ffcc00' : '#ff0000')
          });
        }
        // Initial flash
        this.flashIntensity = 1;
      }
      update(dt, agents, world) {
        this.timer += dt;
        this.currentRadius = Math.min(this.radius, (this.timer / 0.15) * this.radius);
        this.flashIntensity = Math.max(0, 1 - this.timer * 4);
        
        // Add expanding rings
        if (this.timer < 0.3 && Math.random() < 0.3) {
          this.rings.push({ radius: this.currentRadius * 0.3, alpha: 1 });
        }
        
        // Update rings
        for (const ring of this.rings) {
          ring.radius += 400 * dt;
          ring.alpha -= dt * 3;
        }
        this.rings = this.rings.filter(r => r.alpha > 0);
        
        // Update particles
        for (const p of this.particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += 200 * dt; // Gravity
          p.life -= dt;
          p.size *= 0.97;
        }
        this.particles = this.particles.filter(p => p.life > 0);
        
        // Deal damage once at peak
        if (!this.hasDealtDamage && this.timer >= 0.05) {
          this.hasDealtDamage = true;
          for (const agent of agents) {
            if (!agent.alive || (this.owner && agent.team === this.owner.team)) continue;
            const dx = agent.x - this.x, dy = agent.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > this.radius) continue;
            
            // Damage falloff: 100% at center, 50% at edge
            const falloff = 1 - (dist / this.radius) * 0.5;
            const finalDamage = Math.floor(this.damage * falloff);
            
            const killed = agent.takeDamage(finalDamage, this.owner, world);
            if (this.owner) {
              this.owner.damageDealt += finalDamage;
              this.owner.lifeDamageDealt += finalDamage;
              if (killed) {
                this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
                this.owner.lifeKills++;
                this.owner.weaponKills.rocket++;
                this.owner.totalWeaponKills.rocket++;
                world.weaponKills.rocket++;
                world.totalWeaponKills.rocket++;
                world.teamKills[this.owner.team]++;
                this.owner.killScore += 50;
                world.addEvent('üí• ' + this.owner.name + ' OBLITERATED ' + agent.name + '!', 'kill');
              } else {
                world.addEvent(this.owner.name + ' rocket hit ' + agent.name, 'damage');
              }
            }
          }
        }
        
        return this.timer >= this.maxTime;
      }
    }

    // --------------------
    // Control Point
    // --------------------
    class ControlPoint {
      constructor(x, y, size) {
        this.x = x; this.y = y; this.size = size;
        this.owner = null; this.capturer = null;
        this.captureProgress = 0; this.captureTime = 10;
        this.contested = false;
        this.color = 'hsl(' + (Math.random() * 360) + ', 100%, 50%)';
      }
      containsAgent(agent) {
        return agent.x >= this.x && agent.x <= this.x + this.size && agent.y >= this.y && agent.y <= this.y + this.size;
      }
      getAgentsInside(agents) { return agents.filter(a => a.alive && this.containsAgent(a)); }
      update(dt, agents, world) {
        const inside = this.getAgentsInside(agents);

        if (this.owner && !this.owner.alive) {
          world.addEvent(this.owner.name + ' lost point', 'damage');
          this.owner = null;
        }

        this.contested = inside.length > 1;
        if (this.contested) {
          this.capturer = null;
          this.captureProgress = 0;
          return;
        }

        if (inside.length === 1) {
          const agent = inside[0];

          if (this.owner === agent) {
            agent.controlPointSeconds += dt;
            return;
          }

          // Capturing
          if (this.capturer !== agent) {
            this.capturer = agent;
            this.captureProgress = 0;
          }
          this.captureProgress += dt;

          if (this.captureProgress >= this.captureTime) {
            if (this.owner && this.owner !== agent) world.addEvent(agent.name + ' took point from ' + this.owner.name + '!', 'kill');
            this.owner = agent;
            this.capturer = null;
            this.captureProgress = 0;
            agent.controlPointCaptures++;
            world.addEvent(agent.name + ' captured point!', 'kill');
          }
          return;
        }

        // Nobody inside
        this.capturer = null;
        this.captureProgress = 0;
        if (this.owner && this.owner.alive) this.owner.controlPointSeconds += dt;
      }
    }

    // --------------------
    // Spatial hash (cheap nearest-neighbor acceleration)
    // --------------------
    class SpatialHash {
      constructor(cellSize) {
        this.cellSize = cellSize;
        this.map = new Map();
      }
      key(cx, cy) { return (cx << 16) ^ (cy & 0xffff); }
      cell(v) { return Math.floor(v / this.cellSize); }
      clear() { this.map.clear(); }
      insert(obj, x, y) {
        const cx = this.cell(x), cy = this.cell(y);
        const k = this.key(cx, cy);
        let arr = this.map.get(k);
        if (!arr) { arr = []; this.map.set(k, arr); }
        arr.push(obj);
      }
      query(x, y, radius) {
        const r = radius;
        const cs = this.cellSize;
        const minX = this.cell(x - r), maxX = this.cell(x + r);
        const minY = this.cell(y - r), maxY = this.cell(y + r);
        const out = [];
        for (let cx = minX; cx <= maxX; cx++) {
          for (let cy = minY; cy <= maxY; cy++) {
            const arr = this.map.get(this.key(cx, cy));
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    }

    // --------------------
    // Agent
    // --------------------
    // QUAKE MODE - Everyone gets a rocket launcher!
    const ROCKET = {
      damage: 90,          // Direct hit = almost one-shot
      splashRadius: 120,   // Big splash
      splashFalloff: 0.4,  // 40% damage at edge
      speed: 450,          // Fast enough to hit, slow enough to dodge
      fireRate: 4.0,        // 4 seconds between shots - makes each rocket count!
      selfDamage: true,    // Watch your feet!
      maxRange: 2000
    };

    class Agent {
      constructor(x, y, name, brain = null, team = 0) {
        this.x = x; this.y = y; this.name = name;
        this.team = team; // 0 = red, 1 = blue
        this.rotation = Math.random() * Math.PI * 2;
        this.vx = 0; this.vy = 0;

        this.health = 100; this.maxHealth = 100;
        this.armor = 0; this.maxArmor = 100; // 2 armor packs = 100
        this.stamina = 100; this.maxStamina = 100;

        this.alive = true;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        
        // Respawn system
        this.respawnTimer = 0;
        this.deaths = 0;

        // Weapon system
        this.weaponCooldown = 0;
        this.weapon = 'rocket'; // 'rocket', 'laser', or 'sword'
        this.laserCharge = 0; // 0-3 seconds
        this.laserCharging = false;
        
        // Sword mechanics
        this.swordCharge = 0; // 0-2 seconds max
        this.swordCharging = false;
        this.swordLunging = false;
        this.lungeStartX = 0;
        this.lungeStartY = 0;
        this.lungeEndX = 0;
        this.lungeEndY = 0;
        this.lungeProgress = 0;

        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.assists = 0;
        this.lastHitBy = null; // For assist tracking
        
        // Lifetime stats (persist across rounds)
        this.totalKills = 0;
        this.totalDeaths = 0;
        this.roundsPlayed = 0;

        // Weapon kill stats (per round)
        this.weaponKills = { rocket: 0, laser: 0, sword: 0 };
        // Weapon kill stats (lifetime)
        this.totalWeaponKills = { rocket: 0, laser: 0, sword: 0 };

        // Network: 54 inputs ‚Üí 16 hidden ‚Üí 5 outputs
        // Inputs: 42 raycast (21 rays √ó 2) + 12 state (health, cooldown, velocity, weapon type, rocket awareness, etc)
        // Outputs: turn, move speed, shoot, strafe, dash
        this.brain = brain || new NeuralNetwork(54, 16, 5);

        // Track if agent has picked up a special weapon this round (can only pick up once)
        this.hasPickedUpWeapon = false;

        // Persistent mode tracking
        this.lifeStartTime = 0; // Set when agent spawns/respawns
        this.lifeKills = 0; // Kills this life only
        this.lifeDamageDealt = 0; // Damage this life only

        // Dodge ability
        this.dodgeCooldown = 0;
        this.isDodging = false;
        this.dodgeProgress = 0;
        this.dodgeStartX = 0;
        this.dodgeStartY = 0;
        this.dodgeEndX = 0;
        this.dodgeEndY = 0;

        this.radius = 16;
        this.color = team === 0 ? '#ff4444' : '#4488ff';
      }
      
      // Reset for new round but keep identity
      resetForRound() {
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        // Check if forceWeapon is active (debug mode)
        if (forceWeapon) {
          this.weapon = forceWeapon;
          this.hasPickedUpWeapon = true;
        } else {
          this.weapon = 'rocket';
          this.hasPickedUpWeapon = false; // Can pick up one special weapon per round
        }
        this.dodgeCooldown = 0;
        this.isDodging = false;
        this.dodgeProgress = 0;
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;
        
        // Reset round stats but not lifetime stats
        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.deaths = 0;
        this.assists = 0;
        this.weaponKills = { rocket: 0, laser: 0, sword: 0 };
        this.roundsPlayed++;
        
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
      }
      
      // Respawn after death
      respawn(world) {
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        // Check if forceWeapon is active (debug mode)
        if (forceWeapon) {
          this.weapon = forceWeapon;
          this.hasPickedUpWeapon = true;
        } else {
          this.weapon = 'rocket'; // Lose special weapons on death
          this.hasPickedUpWeapon = false;
        }
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;

        // Reset life stats for persistent mode
        this.lifeStartTime = world ? world.totalTime : 0;
        this.lifeKills = 0;
        this.lifeDamageDealt = 0;

        // Spawn at back of team's side
        const clusterX = this.team === 0 ? 80 : world.width - 80;
        this.x = clusterX + (Math.random() - 0.5) * 100;
        this.y = world.height / 2 + (Math.random() - 0.5) * (world.height - 200);
        this.x = clamp(this.x, 40, world.width - 40);
        this.y = clamp(this.y, 40, world.height - 40);
        this.rotation = this.team === 0 ? 0 : Math.PI;
      }

      get score() {
        const killPoints = this.kills * 50;
        const assistPoints = this.assists * 25;
        const damagePoints = this.damageDealt;
        return killPoints + assistPoints + damagePoints - this.damageTaken;
      }

      castRays(world, numRays = 21, fov = Math.PI * 0.8) {
        const { agents, obstacles, pickups, width: worldWidth, height: worldHeight } = world;
        const rayData = [];

        const startAngle = this.rotation - fov / 2;
        const angleStep = fov / (numRays - 1);
        const maxDist = Math.hypot(worldWidth, worldHeight);

        // Check all alive agents for raycasts (full map visibility)
        const nearCandidates = agents.filter(a => a.alive && a !== this);

        for (let i = 0; i < numRays; i++) {
          const angle = startAngle + angleStep * i;
          let closestDist = maxDist;
          let closestType = 0;

          const edgeDist = this.raycastMapEdge(angle, worldWidth, worldHeight);
          if (edgeDist < closestDist) { closestDist = edgeDist; closestType = 0; }

          for (const obs of obstacles) {
            const dist = this.raycastRect(angle, closestDist, obs);
            if (dist < closestDist) { closestDist = dist; closestType = 0.5; }
          }

          // Check pickups (weapons, health, armor)
          for (const pickup of pickups) {
            const dist = this.raycastCircle(angle, closestDist, pickup.x, pickup.y, pickup.radius);
            if (dist < closestDist) { closestDist = dist; closestType = 0.25; }
          }

          // Check enemy rockets (type 0.75)
          for (const rocket of world.rockets) {
            if (rocket.owner && rocket.owner.team === this.team) continue; // Ignore own team's rockets
            const dist = this.raycastCircle(angle, closestDist, rocket.x, rocket.y, 8); // 8 = rocket radius
            if (dist < closestDist) { closestDist = dist; closestType = 0.75; }
          }

          for (const other of nearCandidates) {
            if (other === this || !other.alive) continue;
            const dist = this.raycastCircle(angle, closestDist, other.x, other.y, other.radius);
            if (dist < closestDist) { closestDist = dist; closestType = 1; }
          }

          rayData.push(closestDist / maxDist);
          rayData.push(closestType);
        }
        return rayData;
      }

      raycastMapEdge(angle, w, h) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = Infinity;
        if (dx < 0) { const t = -this.x / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dx > 0) { const t = (w - this.x) / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dy < 0) { const t = -this.y / dy; if (t > 0 && t < tMin) tMin = t; }
        if (dy > 0) { const t = (h - this.y) / dy; if (t > 0 && t < tMin) tMin = t; }
        return tMin;
      }

      raycastRect(angle, max, rect) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = 0, tMax = max;

        if (dx !== 0) {
          const t1 = (rect.x - this.x) / dx;
          const t2 = (rect.x + rect.w - this.x) / dx;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.x < rect.x || this.x > rect.x + rect.w) {
          return max;
        }

        if (dy !== 0) {
          const t1 = (rect.y - this.y) / dy;
          const t2 = (rect.y + rect.h - this.y) / dy;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.y < rect.y || this.y > rect.y + rect.h) {
          return max;
        }

        if (tMin <= tMax && tMin > 0) return tMin;
        return max;
      }

      raycastCircle(angle, max, cx, cy, r) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        const fx = this.x - cx, fy = this.y - cy;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - r * r;
        const d = b * b - 4 * a * c;
        if (d < 0) return max;
        const t = (-b - Math.sqrt(d)) / (2 * a);
        if (t > 0 && t < max) return t;
        return max;
      }

      think(world) {
        if (!this.alive) return null;

        const rayData = this.castRays(world);

        // Find nearest enemy
        let nearestEnemyDist = 1;
        let nearestEnemyAngle = 0;
        const enemies = world.agents.filter(a => a.alive && a.team !== this.team);
        for (const enemy of enemies) {
          const dx = enemy.x - this.x, dy = enemy.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 1000);
          if (nDist < nearestEnemyDist) {
            nearestEnemyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestEnemyAngle = a / Math.PI;
          }
        }

        // Find nearest ally (to avoid friendly fire)
        let nearestAllyDist = 1;
        let nearestAllyAngle = 0;
        const allies = world.agents.filter(a => a.alive && a.team === this.team && a !== this);
        for (const ally of allies) {
          const dx = ally.x - this.x, dy = ally.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 500);
          if (nDist < nearestAllyDist) {
            nearestAllyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestAllyAngle = a / Math.PI;
          }
        }

        // Find nearest enemy rocket (to dodge)
        let nearestRocketDist = 1;
        let nearestRocketAngle = 0;
        for (const rocket of world.rockets) {
          if (rocket.owner && rocket.owner.team === this.team) continue; // Ignore own team's rockets
          const dx = rocket.x - this.x, dy = rocket.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 500); // Normalize to 500 units
          if (nDist < nearestRocketDist) {
            nearestRocketDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestRocketAngle = a / Math.PI;
          }
        }

        const speedNorm = clamp(Math.hypot(this.vx, this.vy) / 200, 0, 1);
        const weaponReady = this.weaponCooldown <= 0 ? 1 : 0;
        const hasLaser = this.weapon === 'laser' ? 1 : 0;
        const hasSword = this.weapon === 'sword' ? 1 : 0;
        const dodgeReady = this.dodgeCooldown <= 0 ? 1 : 0;

        // Inputs: 54 total (42 rays + 12 internal)
        const internal = [
          this.health / this.maxHealth,
          speedNorm,
          weaponReady,
          nearestEnemyAngle,
          nearestEnemyDist,
          nearestAllyAngle,
          nearestAllyDist,
          nearestRocketAngle,
          nearestRocketDist,
          this.team,
          hasLaser,
          hasSword
        ];

        const outputs = this.brain.forward(rayData.concat(internal));

        const decision = {
          turnAmount: outputs[0],
          speedAmount: (outputs[1] + 1) / 2,
          wantsShoot: outputs[2] > 0,
          strafe: outputs[3],
          wantsDash: outputs[4] > 0
        };

        // Store for UI visualization
        this.lastDecision = decision;
        this.lastRayData = rayData;
        this.lastAwareness = {
          enemyDist: nearestEnemyDist,
          enemyAngle: nearestEnemyAngle,
          allyDist: nearestAllyDist,
          allyAngle: nearestAllyAngle,
          rocketDist: nearestRocketDist,
          rocketAngle: nearestRocketAngle
        };

        return decision;
      }

      update(decision, dt, world, obstacles) {
        if (!this.alive) return;

        this.attackCooldown = Math.max(0, this.attackCooldown - dt);
        this.attackRecovery = Math.max(0, this.attackRecovery - dt);
        this.weaponCooldown = Math.max(0, this.weaponCooldown - dt);
        this.dodgeCooldown = Math.max(0, this.dodgeCooldown - dt);

        // Handle sword lunge movement (with chain support)
        if (this.swordLunging) {
          if (this.chainTargets && this.chainTargets.length > 0) {
            // Chain lunge - follow path through multiple targets
            const chainSpeed = 600; // Slightly faster for chain kills

            // Calculate total chain distance
            let totalDist = 0;
            const segmentDists = [];
            for (const chain of this.chainTargets) {
              const d = Math.hypot(chain.toX - chain.fromX, chain.toY - chain.fromY);
              segmentDists.push(d);
              totalDist += d;
            }

            // Update progress based on total distance
            this.lungeProgress += (dt * chainSpeed) / Math.max(50, totalDist);

            if (this.lungeProgress >= 1) {
              this.swordLunging = false;
              const lastChain = this.chainTargets[this.chainTargets.length - 1];
              this.x = lastChain.toX;
              this.y = lastChain.toY;
              this.weaponCooldown = 1.0;
              this.chainTargets = null;
            } else {
              // Find which segment we're on
              let progressDist = this.lungeProgress * totalDist;
              let segmentIndex = 0;
              let segmentStart = 0;

              for (let i = 0; i < segmentDists.length; i++) {
                if (progressDist <= segmentStart + segmentDists[i]) {
                  segmentIndex = i;
                  break;
                }
                segmentStart += segmentDists[i];
              }

              const chain = this.chainTargets[segmentIndex];
              const segmentProgress = (progressDist - segmentStart) / segmentDists[segmentIndex];

              // Interpolate position within segment
              this.x = chain.fromX + (chain.toX - chain.fromX) * segmentProgress;
              this.y = chain.fromY + (chain.toY - chain.fromY) * segmentProgress;

              // Face the target
              this.rotation = Math.atan2(chain.toY - chain.fromY, chain.toX - chain.fromX);
            }
          } else {
            // Regular lunge (no chain)
            const lungeSpeed = 500 / Math.max(50, this.lungeDist);
            this.lungeProgress += dt * lungeSpeed;
            if (this.lungeProgress >= 1) {
              this.swordLunging = false;
              this.x = this.lungeEndX;
              this.y = this.lungeEndY;
              this.weaponCooldown = 1.0;
            } else {
              this.x = this.lungeStartX + (this.lungeEndX - this.lungeStartX) * this.lungeProgress;
              this.y = this.lungeStartY + (this.lungeEndY - this.lungeStartY) * this.lungeProgress;
            }
          }
          return; // Skip normal movement during lunge
        }

        // Handle dodge movement animation
        if (this.isDodging) {
          const dodgeSpeed = 8; // Complete dodge in ~0.125 seconds
          this.dodgeProgress += dt * dodgeSpeed;

          // Ease out for smooth deceleration
          const easedProgress = 1 - Math.pow(1 - Math.min(1, this.dodgeProgress), 2);

          if (this.dodgeProgress >= 1) {
            this.isDodging = false;
            this.x = this.dodgeEndX;
            this.y = this.dodgeEndY;
          } else {
            // Interpolate position with easing
            this.x = this.dodgeStartX + (this.dodgeEndX - this.dodgeStartX) * easedProgress;
            this.y = this.dodgeStartY + (this.dodgeEndY - this.dodgeStartY) * easedProgress;
          }
          return; // Skip normal movement during dodge
        }

        if (!decision) return;

        // Trigger dodge/dash (if enabled in world)
        if (decision.wantsDash && this.dodgeCooldown <= 0 && world.dodgingEnabled && !this.isDodging) {
          const dashDistance = 70; // Short dash distance

          // Dash in movement direction, or facing direction if not moving
          let dashAngle;
          const moveX = Math.cos(this.rotation) * decision.speedAmount + Math.cos(this.rotation + Math.PI/2) * (decision.strafe || 0);
          const moveY = Math.sin(this.rotation) * decision.speedAmount + Math.sin(this.rotation + Math.PI/2) * (decision.strafe || 0);
          const moveMag = Math.hypot(moveX, moveY);

          if (moveMag > 0.1) {
            dashAngle = Math.atan2(moveY, moveX);
          } else {
            dashAngle = this.rotation; // Dash forward if not moving
          }

          // Calculate new position
          let newX = this.x + Math.cos(dashAngle) * dashDistance;
          let newY = this.y + Math.sin(dashAngle) * dashDistance;

          // Clamp to world bounds
          newX = clamp(newX, this.radius, world.width - this.radius);
          newY = clamp(newY, this.radius, world.height - this.radius);

          // Check obstacle collision and adjust
          for (const obs of obstacles) {
            const col = this.checkRectCollision(newX, newY, obs);
            if (col) { newX = col.x; newY = col.y; }
          }

          // Set up dodge animation
          this.dodgeStartX = this.x;
          this.dodgeStartY = this.y;
          this.dodgeEndX = newX;
          this.dodgeEndY = newY;
          this.dodgeProgress = 0;
          this.isDodging = true;
          this.dodgeCooldown = 6.0; // 6 second cooldown

          // Add dodge trail effect
          world.dodgeTrails.push({
            startX: this.x,
            startY: this.y,
            endX: newX,
            endY: newY,
            team: this.team,
            timer: 0,
            maxTime: 0.3
          });
        }

        this.rotation += decision.turnAmount * 4 * dt; // Faster turning for dodging

        // Forward/backward movement
        let targetSpeed = decision.speedAmount * 150; // Faster base speed

        // 2x movement speed while holding sword (not charging)
        if (this.weapon === 'sword' && !this.swordCharging) {
          targetSpeed *= 2;
        }

        // 50% movement speed while charging laser
        if (this.laserCharging) {
          targetSpeed *= 0.5;
        }

        // 80% movement slow while charging sword (20% speed)
        if (this.swordCharging) {
          targetSpeed *= 0.2;
        }

        // Strafing (perpendicular movement)
        let strafeSpeed = (decision.strafe || 0) * 100;

        // 2x strafe speed while holding sword (not charging)
        if (this.weapon === 'sword' && !this.swordCharging) {
          strafeSpeed *= 2;
        }

        if (this.laserCharging) {
          strafeSpeed *= 0.5;
        }
        if (this.swordCharging) {
          strafeSpeed *= 0.2;
        }

        const tvx = Math.cos(this.rotation) * targetSpeed + Math.cos(this.rotation + Math.PI/2) * strafeSpeed;
        const tvy = Math.sin(this.rotation) * targetSpeed + Math.sin(this.rotation + Math.PI/2) * strafeSpeed;
        
        const lerp = Math.min(1, 8 * dt); // Snappier movement
        this.vx += (tvx - this.vx) * lerp;
        this.vy += (tvy - this.vy) * lerp;

        let nx = this.x + this.vx * dt;
        let ny = this.y + this.vy * dt;

        for (const obs of obstacles) {
          const col = this.checkRectCollision(nx, ny, obs);
          if (col) { nx = col.x; ny = col.y; }
        }

        this.x = clamp(nx, this.radius, world.width - this.radius);
        this.y = clamp(ny, this.radius, world.height - this.radius);
      }

      // Shoot rocket!
      tryShoot(world) {
        if (!this.alive || this.weaponCooldown > 0) return null;

        this.weaponCooldown = ROCKET.fireRate;

        // Rocket spawns from right shoulder position
        const shoulderOffset = this.radius * 0.7;
        const perpX = Math.cos(this.rotation - Math.PI / 2) * shoulderOffset; // right side
        const perpY = Math.sin(this.rotation - Math.PI / 2) * shoulderOffset;
        const forwardX = Math.cos(this.rotation) * (this.radius * 1.7);
        const forwardY = Math.sin(this.rotation) * (this.radius * 1.7);

        return {
          type: 'rocket',
          x: this.x + perpX + forwardX,
          y: this.y + perpY + forwardY,
          angle: this.rotation,
          owner: this,
          damage: ROCKET.damage,
          splashRadius: ROCKET.splashRadius,
          splashFalloff: ROCKET.splashFalloff,
          speed: ROCKET.speed,
          range: ROCKET.maxRange,
          traveled: 0,
          alive: true
        };
      }

      checkRectCollision(newX, newY, rect) {
        const cx = Math.max(rect.x, Math.min(newX, rect.x + rect.w));
        const cy = Math.max(rect.y, Math.min(newY, rect.y + rect.h));
        const dx = newX - cx, dy = newY - cy;
        const dist = Math.hypot(dx, dy);
        if (dist < this.radius) {
          const ov = this.radius - dist;
          if (dist > 0) return { x: newX + (dx / dist) * ov, y: newY + (dy / dist) * ov };
          return { x: newX + this.radius, y: newY };
        }
        return null;
      }

      tryAttack(agents, world) {
        // No melee in Quake mode - rockets only!
        return null;
      }

      takeDamage(amount, attacker, world) {
        // Armor absorbs damage first
        if (this.armor > 0) {
          const armorDamage = Math.min(this.armor, amount);
          this.armor -= armorDamage;
          amount -= armorDamage;
        }
        
        this.health -= amount;
        this.damageTaken += amount;

        // Track who hit us for assists
        if (attacker && attacker !== this.lastHitBy) {
          if (this.lastHitBy && this.health <= 0 && this.lastHitBy !== attacker) {
            this.lastHitBy.assists++;
          }
          this.lastHitBy = attacker;
        }

        if (this.health > 0) return false;

        // Death
        this.alive = false;
        this.deaths++;
        this.totalDeaths++;

        // Drop special weapon on death
        if (world && (this.weapon === 'laser' || this.weapon === 'sword')) {
          world.dropWeapon(this.x, this.y, this.weapon);
        }

        // Persistent mode: evaluate this life and evolve
        if (persistentMode && world) {
          const survivalTime = world.totalTime - this.lifeStartTime;
          const lifeScore = this.lifeKills * 50 + this.lifeDamageDealt - this.damageTaken;

          // Add to Hall of Fame
          const entry = {
            score: lifeScore,
            brain: this.brain.clone(),
            kills: this.lifeKills,
            damageDealt: this.lifeDamageDealt,
            survivalTime: survivalTime,
            timestamp: Date.now()
          };
          addToHallOfFame(this.team, entry);
          totalLivesEvaluated++;

          // Select parent and evolve
          const parent = selectParentFromHoF(this.team);
          if (parent) {
            const { rate, strength } = getMutationRateForRank(this.team, parent);
            this.brain = parent.brain.clone();
            this.brain.mutate(rate, strength);
          }

          // Immediate respawn in persistent mode
          this.respawnTimer = 0.1; // Tiny delay for visual feedback
        } else {
          this.respawnTimer = world ? world.respawnTime : 3; // Use world's respawn time
        }

        return true;
      }

      clone(newName, team) {
        const child = new Agent(this.x, this.y, newName, this.brain.clone(), team);
        return child;
      }
    }

    // --------------------
    // World
    // --------------------
    class World {
      constructor(width, height) {
        this.width = width;
        this.height = height;

        this.agents = [];
        this.obstacles = [];
        this.buildings = [];

        // Projectiles - ROCKETS ONLY in Quake mode
        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = []; // Smoke trail particles

        // Pickups
        this.pickups = [];
        this.pickupTimer = 0;
        this.pickupInterval = 20; // Spawn every 20 seconds
        this.nextPickupType = 'health'; // Alternates between health and armor
        this.healthSpawnsEnabled = true;
        this.armorSpawnsEnabled = true;

        // Pit spawn locations (enclosed areas for health/armor)
        this.pickupPits = [];
        
        // Laser spawns
        this.laserSpawnsEnabled = true;
        this.laserSpawned = false; // Only spawn once per round
        this.laserBeams = []; // Active laser beam animations
        
        // Sword spawns
        this.swordSpawnsEnabled = true;
        this.swordSpawned = false;
        this.swordSlashes = []; // Active sword slash animations

        // Dropped weapons (laser/sword dropped on death or weapon swap)
        this.droppedWeapons = [];

        // Dodge trail animations
        this.dodgeTrails = [];

        this.roundTime = 180; // 3 minutes
        this.timeLeft = this.roundTime;
        this.totalTime = 0; // Total elapsed time (for persistent mode)

        this.usedNames = new Set();
        this.generation = 1;
        this.events = [];
        this.paused = false;

        this.population = 100; // 50 per team
        this.aliveCount = 0;
        
        // Team Deathmatch specific
        this.teamKills = [0, 0]; // [red kills, blue kills] - NET score (kills - ricochets)
        this.teamRawKills = [0, 0]; // Actual enemy kills
        this.teamRicochets = [0, 0]; // Friendly fire incidents
        this.killLimit = 20;
        this.winningTeam = null;
        this.teamWins = [0, 0]; // Track total wins per team

        // Global weapon kill stats (for balance tracking)
        this.weaponKills = { rocket: 0, laser: 0, sword: 0 };
        this.totalWeaponKills = { rocket: 0, laser: 0, sword: 0 };
        
        // Game modifiers
        this.friendlyFire = false;
        this.friendlyFireRicochet = false;
        this.dodgingEnabled = true; // Agents can dash/dodge
        this.respawnTime = 3; // seconds

        // Teleporters - pair of portals for quick map traversal
        this.teleportersEnabled = true;
        this.teleporters = []; // Will be populated in generateObstacles
        this.teleporterActive = false; // Currently usable?
        this.teleporterActiveTimer = 0; // Time remaining in active window
        this.teleporterActiveDuration = 30; // Active for 30 seconds
        this.teleporterNextActivation = 0; // When portals will activate
        this.teleporterWarpEffects = []; // Warp in/out animations

        // Team brains (evolved separately)
        this.teamBrains = [null, null];

        this.spatialAgents = new SpatialHash(120);

        this.generateObstacles();
      }

      spawnLaserPickups() {
        if (this.laserSpawned || !this.laserSpawnsEnabled) return;

        // Spawn 10 lasers in a circle at map center (risk/reward)
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = 200; // Circle radius

        for (let i = 0; i < 10; i++) {
          // Offset angle so lasers alternate with swords
          const angle = (i / 10) * Math.PI * 2 + Math.PI / 20;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          this.pickups.push({
            x: x,
            y: y,
            type: 'laser',
            radius: 18
          });
        }

        this.laserSpawned = true;
        this.addEvent('‚ö° LASER WEAPONS SPAWNED AT CENTER!', 'laser');
      }

      spawnSwordPickups() {
        if (this.swordSpawned || !this.swordSpawnsEnabled) return;

        // Spawn 10 swords in a circle at map center (risk/reward)
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = 200; // Circle radius

        for (let i = 0; i < 10; i++) {
          // Offset angle so swords alternate with lasers
          const angle = (i / 10) * Math.PI * 2 - Math.PI / 20;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;

          this.pickups.push({
            x: x,
            y: y,
            type: 'sword',
            radius: 18
          });
        }

        this.swordSpawned = true;
        this.addEvent('üó°Ô∏è ENERGY SWORDS SPAWNED AT CENTER!', 'sword');
      }

      spawnPickupInPit(pit) {
        // Check if this type is enabled
        if (pit.type === 'health' && !this.healthSpawnsEnabled) return false;
        if (pit.type === 'armor' && !this.armorSpawnsEnabled) return false;

        // Spawn pickup at pit center
        this.pickups.push({
          x: pit.x,
          y: pit.y,
          type: pit.type,
          radius: 18,
          pitRef: pit
        });

        pit.hasPickup = true;
        pit.respawnTimer = 0;
        pit.respawnTime = 0;

        const icon = pit.type === 'health' ? 'ü©π' : 'üõ°Ô∏è';
        this.addEvent(icon + ' ' + pit.type.toUpperCase() + ' spawned in pit!', 'pickup');
        return true;
      }

      spawnPickups() {
        // Spawn pickups in all empty pits (used at round start)
        for (const pit of this.pickupPits) {
          if (!pit.hasPickup) {
            this.spawnPickupInPit(pit);
          }
        }
      }

      updatePitTimers(dt) {
        // Update per-pit respawn timers (Roshan-style random respawn)
        for (const pit of this.pickupPits) {
          if (pit.hasPickup) continue; // Pit has a pickup, no timer needed
          if (pit.respawnTime <= 0) continue; // No respawn scheduled

          pit.respawnTimer += dt;
          if (pit.respawnTimer >= pit.respawnTime) {
            this.spawnPickupInPit(pit);
          }
        }
      }

      // Set random respawn time when pickup is collected (15-25 seconds window)
      schedulePitRespawn(pit) {
        const baseTime = 20; // Base respawn time
        const variance = 5;  // +/- 5 seconds
        pit.respawnTime = baseTime + (Math.random() * 2 - 1) * variance; // 15-25 seconds
        pit.respawnTimer = 0;
      }

      fireLaser(agent) {
        if (!agent || !agent.alive) return;

        // Bouncing, piercing laser with 6 bounces
        var maxBounces = 6;
        var beamSegments = [];
        var hitTargets = {};  // Track hit target IDs
        var killCount = 0;

        var currentX = agent.x + Math.cos(agent.rotation) * agent.radius;
        var currentY = agent.y + Math.sin(agent.rotation) * agent.radius;
        currentX = Math.max(5, Math.min(this.width - 5, currentX));
        currentY = Math.max(5, Math.min(this.height - 5, currentY));

        var angle = agent.rotation;

        for (var bounce = 0; bounce <= maxBounces; bounce++) {
          var cosA = Math.cos(angle);
          var sinA = Math.sin(angle);

          // Find wall intersection
          var endX = currentX;
          var endY = currentY;

          for (var dist = 0; dist < 5000; dist += 10) {
            var testX = currentX + cosA * dist;
            var testY = currentY + sinA * dist;

            if (testX < 0 || testX > this.width || testY < 0 || testY > this.height) {
              endX = Math.max(0, Math.min(this.width, testX));
              endY = Math.max(0, Math.min(this.height, testY));
              break;
            }
            endX = testX;
            endY = testY;
          }

          // Check for enemy hits along this segment (piercing - hits all)
          var dx = endX - currentX;
          var dy = endY - currentY;
          var len = Math.sqrt(dx * dx + dy * dy);

          if (len > 1) {
            for (var i = 0; i < this.agents.length; i++) {
              var target = this.agents[i];
              if (!target || target === agent || !target.alive) continue;
              if (target.team === agent.team) continue;
              if (hitTargets[target.name]) continue;  // Already hit

              var px = target.x - currentX;
              var py = target.y - currentY;
              var dot = (px * dx + py * dy) / len;

              if (dot > 0 && dot < len) {
                var closestX = currentX + (dx / len) * dot;
                var closestY = currentY + (dy / len) * dot;
                var distToLine = Math.sqrt((target.x - closestX) * (target.x - closestX) + (target.y - closestY) * (target.y - closestY));

                if (distToLine < target.radius + 10) {
                  hitTargets[target.name] = true;
                  var killed = target.takeDamage(999, agent, this);
                  if (killed) {
                    agent.kills++;
                    agent.totalKills++;
                    agent.lifeKills++;
                    agent.weaponKills.laser++;
                    agent.totalWeaponKills.laser++;
                    this.weaponKills.laser++;
                    this.totalWeaponKills.laser++;
                    this.teamKills[agent.team]++;
                    this.teamRawKills[agent.team]++;
                    killCount++;
                  }
                }
              }
            }
          }

          // Store segment
          beamSegments.push({ startX: currentX, startY: currentY, endX: endX, endY: endY });

          // Calculate bounce direction
          var hitRight = Math.abs(endX - this.width) < 2;
          var hitLeft = endX < 2;
          var hitBottom = Math.abs(endY - this.height) < 2;
          var hitTop = endY < 2;

          if (hitRight || hitLeft) {
            angle = Math.PI - angle;
          }
          if (hitBottom || hitTop) {
            angle = -angle;
          }

          // Move to bounce point
          currentX = Math.max(2, Math.min(this.width - 2, endX));
          currentY = Math.max(2, Math.min(this.height - 2, endY));
        }

        // Event messages
        if (killCount >= 3) {
          this.addEvent('‚ö° ' + agent.name + ' LASER DEVASTATION x' + killCount + '!', 'laser');
        } else if (killCount >= 2) {
          this.addEvent('‚ö° ' + agent.name + ' LASER PIERCE x' + killCount + '!', 'laser');
        } else if (killCount === 1) {
          this.addEvent('‚ö° ' + agent.name + ' LASER KILL!', 'laser');
        }

        // Add beam with all segments
        this.laserBeams.push({
          segments: beamSegments,
          team: agent.team,
          timer: 0,
          maxTime: 1.5
        });
      }

      createLaserExplosion(x, y, radius, damage, owner) {
        // Deal splash damage to nearby enemies
        for (const target of this.agents) {
          if (target === owner || !target.alive) continue;
          if (target.team === owner.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;

          const dist = Math.hypot(target.x - x, target.y - y);
          if (dist < radius) {
            const dmgFalloff = 1 - (dist / radius);
            const actualDmg = Math.round(damage * dmgFalloff);

            if (target.team === owner.team) {
              if (this.friendlyFireRicochet) {
                owner.takeDamage(actualDmg, owner, this);
              } else if (this.friendlyFire) {
                target.takeDamage(actualDmg, owner, this);
              }
            } else {
              const killed = target.takeDamage(actualDmg, owner, this);
              owner.lifeDamageDealt += actualDmg;
              if (killed) {
                owner.kills++;
                owner.totalKills++;
                owner.lifeKills++;
                owner.weaponKills.laser++;
                owner.totalWeaponKills.laser++;
                this.weaponKills.laser++;
                this.totalWeaponKills.laser++;
                this.teamKills[owner.team]++;
                this.teamRawKills[owner.team]++;
                this.addEvent('üí• ' + owner.name + ' LASER EXPLOSION KILL!', 'laser');
              }
            }
          }
        }

        // Add explosion visual effect
        this.effects.push({
          type: 'laser_explosion',
          x, y, radius,
          timer: 0,
          maxTime: 0.4,
          team: owner.team
        });
      }

      executeSwordLunge(agent, chargeTime) {
        // Calculate initial lunge distance based on charge time (0.5s min charge, 2s max)
        const minDist = 50;
        const maxDist = 500;
        const chargeRatio = Math.min(1, Math.max(0, (chargeTime - 0.3) / 1.7));
        const lungeDist = minDist + chargeRatio * (maxDist - minDist);
        const chainRange = 200; // Range for chaining to next enemy

        const startX = agent.x;
        const startY = agent.y;

        // Build chain of targets
        const chainTargets = [];
        let currentX = startX;
        let currentY = startY;
        let currentAngle = agent.rotation;
        let currentRange = lungeDist;
        const hitTargets = new Set(); // Track already hit targets

        // Find chain of enemies to hit
        let searching = true;
        while (searching) {
          // Find first enemy along current lunge path
          let firstHit = null;
          let firstHitDist = currentRange;

          const endX = currentX + Math.cos(currentAngle) * currentRange;
          const endY = currentY + Math.sin(currentAngle) * currentRange;

          for (const target of this.agents) {
            if (target === agent || !target.alive || hitTargets.has(target)) continue;
            if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;

            // Point-to-line distance check
            const dx = endX - currentX;
            const dy = endY - currentY;
            const len = Math.hypot(dx, dy);
            if (len === 0) continue;

            const nx = -dy / len;
            const ny = dx / len;
            const px = target.x - currentX;
            const py = target.y - currentY;
            const perpDist = Math.abs(px * nx + py * ny);
            const alongDist = px * (dx / len) + py * (dy / len);

            // Check if target is along the path and closer than current first hit
            if (perpDist < target.radius + 20 && alongDist > 0 && alongDist < firstHitDist) {
              firstHit = target;
              firstHitDist = alongDist;
            }
          }

          if (firstHit) {
            // Found an enemy - add to chain
            hitTargets.add(firstHit);
            chainTargets.push({
              target: firstHit,
              fromX: currentX,
              fromY: currentY,
              toX: firstHit.x,
              toY: firstHit.y
            });

            // Look for next chain target from this position
            currentX = firstHit.x;
            currentY = firstHit.y;
            currentRange = chainRange;

            // Find closest enemy within chain range (any direction)
            let nextTarget = null;
            let nextDist = chainRange;

            for (const target of this.agents) {
              if (target === agent || !target.alive || hitTargets.has(target)) continue;
              if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;

              const dist = Math.hypot(target.x - currentX, target.y - currentY);
              if (dist < nextDist) {
                nextTarget = target;
                nextDist = dist;
              }
            }

            if (nextTarget) {
              // Update angle to face next target
              currentAngle = Math.atan2(nextTarget.y - currentY, nextTarget.x - currentX);
            } else {
              searching = false; // No more targets in range
            }
          } else {
            searching = false; // No enemy hit on this path
          }
        }

        // Determine final destination
        let finalX, finalY;
        if (chainTargets.length > 0) {
          // End at last chain target
          const lastChain = chainTargets[chainTargets.length - 1];
          finalX = lastChain.toX;
          finalY = lastChain.toY;
        } else {
          // No hits - lunge to original destination
          finalX = startX + Math.cos(agent.rotation) * lungeDist;
          finalY = startY + Math.sin(agent.rotation) * lungeDist;
        }

        // Clamp to world bounds
        finalX = clamp(finalX, agent.radius, this.width - agent.radius);
        finalY = clamp(finalY, agent.radius, this.height - agent.radius);

        // Set up lunge (for now, teleport through chain - we'll animate later)
        agent.lungeStartX = startX;
        agent.lungeStartY = startY;
        agent.lungeEndX = finalX;
        agent.lungeEndY = finalY;
        agent.lungeProgress = 0;
        agent.lungeDist = Math.hypot(finalX - startX, finalY - startY);
        agent.swordLunging = true;
        agent.chainTargets = chainTargets; // Store for animation
        agent.chainIndex = 0;

        // Deal damage to all chain targets
        let killCount = 0;
        for (const chain of chainTargets) {
          const target = chain.target;
          if (!target.alive) continue;

          if (target.team === agent.team) {
            if (this.friendlyFireRicochet) {
              const killed = agent.takeDamage(999, agent, this);
              this.teamRicochets[agent.team]++;
              if (killed) {
                this.addEvent('üîÑ ' + agent.name + ' SWORD RICOCHET!', 'sword');
              }
            } else if (this.friendlyFire) {
              const killed = target.takeDamage(999, agent, this);
              if (killed) {
                this.teamRicochets[agent.team]++;
                this.addEvent('üó°Ô∏è ' + agent.name + ' TEAMKILLED ' + target.name + '!', 'sword');
              }
            }
          } else {
            const killed = target.takeDamage(999, agent, this);
            if (killed) {
              agent.kills++;
              agent.totalKills++;
              agent.lifeKills++;
              agent.weaponKills.sword++;
              agent.totalWeaponKills.sword++;
              this.weaponKills.sword++;
              this.totalWeaponKills.sword++;
              this.teamKills[agent.team]++;
              this.teamRawKills[agent.team]++;
              killCount++;
            }
          }
        }

        // Event messages
        if (killCount > 0) {
          let msg;
          if (killCount >= 4) {
            msg = '‚öîÔ∏è ' + agent.name + ' SWORD RAMPAGE x' + killCount + '!';
          } else if (killCount >= 2) {
            msg = '‚öîÔ∏è ' + agent.name + ' CHAIN KILL x' + killCount + '!';
          } else {
            msg = 'üó°Ô∏è ' + agent.name + ' SWORD KILL!';
          }
          this.addEvent(msg, 'sword');
        }

        // Add slash animations for each chain segment
        const bladeLength = agent.radius * 1.7;
        const swordOffset = agent.radius * 1.35;

        if (chainTargets.length > 0) {
          // Create slash for each chain hop
          for (const chain of chainTargets) {
            const segAngle = Math.atan2(chain.toY - chain.fromY, chain.toX - chain.fromX);
            const perpX = Math.cos(segAngle + Math.PI / 2);
            const perpY = Math.sin(segAngle + Math.PI / 2);
            const segDist = Math.hypot(chain.toX - chain.fromX, chain.toY - chain.fromY);
            const segDuration = segDist / 500;

            this.swordSlashes.push({
              startX: chain.fromX + perpX * swordOffset,
              startY: chain.fromY + perpY * swordOffset,
              endX: chain.toX + perpX * swordOffset,
              endY: chain.toY + perpY * swordOffset,
              bladeLength: bladeLength,
              team: agent.team,
              timer: 0,
              maxTime: segDuration + 0.15,
              lungeDuration: segDuration,
              isChain: true
            });
          }
        } else {
          // No chain - regular slash
          const perpX = Math.cos(agent.rotation + Math.PI / 2);
          const perpY = Math.sin(agent.rotation + Math.PI / 2);
          const actualDist = Math.hypot(finalX - startX, finalY - startY);
          const lungeDuration = actualDist / 500;

          this.swordSlashes.push({
            startX: startX + perpX * swordOffset,
            startY: startY + perpY * swordOffset,
            endX: finalX + perpX * swordOffset,
            endY: finalY + perpY * swordOffset,
            bladeLength: bladeLength,
            team: agent.team,
            timer: 0,
            maxTime: lungeDuration + 0.2,
            lungeDuration: lungeDuration
          });
        }
      }

      setRoundTimeSeconds(sec) {
        this.roundTime = Math.max(10, sec);
        this.timeLeft = Math.min(this.timeLeft, this.roundTime);
      }

      generateObstacles() {
        this.obstacles = [];
        this.buildings = [];

        const bTypes = [
          { w: 100, h: 100 },
          { w: 150, h: 100 },
          { w: 80, h: 80 },
          { w: 120, h: 60 },
          { w: 60, h: 120 },
        ];

        // =====================
        // RESERVE PIT AREAS FIRST - prevent other obstacles from spawning here
        // =====================
        const pitSize = 100;
        const pitMargin = 60; // Extra space around pits
        const pitOffsetX = this.width * 0.2;
        const pitOffsetY = 300;

        // Store pit center locations for later
        this.pitLocations = [
          { x: pitOffsetX, y: pitOffsetY },
          { x: pitOffsetX, y: this.height - pitOffsetY },
          { x: this.width - pitOffsetX, y: pitOffsetY },
          { x: this.width - pitOffsetX, y: this.height - pitOffsetY }
        ];

        // Add temporary reservations (will be replaced by actual pit walls)
        const pitReservations = [];
        for (const loc of this.pitLocations) {
          const reservation = {
            x: loc.x - pitSize/2 - pitMargin,
            y: loc.y - pitSize/2 - pitMargin,
            w: pitSize + pitMargin * 2,
            h: pitSize + pitMargin * 2,
            isReservation: true
          };
          pitReservations.push(reservation);
          this.obstacles.push(reservation);
        }

        const overlaps = (x, y, w, h, margin = 30) => {
          for (const o of this.obstacles) {
            if (x < o.x + o.w + margin && x + w > o.x - margin &&
                y < o.y + o.h + margin && y + h > o.y - margin) return true;
          }
          return false;
        };

        const addBuilding = (x, y, w, h) => {
          if (!overlaps(x, y, w, h)) {
            this.buildings.push({ x, y, w, h });
            this.obstacles.push({ x, y, w, h });
            return true;
          }
          return false;
        };

        // =====================
        // SPAWN AREA COVER - Heavy protection near spawns
        // =====================
        
        // Red spawn cover (left side, x: 100-500)
        for (let i = 0; i < 8; i++) {
          const x = 120 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue spawn cover (right side, x: width-500 to width-100)
        for (let i = 0; i < 8; i++) {
          const x = this.width - 470 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // MID TRANSITION - Some cover between spawn and open middle
        // =====================
        
        // Red side transition (x: 500-800)
        for (let i = 0; i < 4; i++) {
          const x = 500 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue side transition (x: width-800 to width-500)
        for (let i = 0; i < 4; i++) {
          const x = this.width - 750 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // OPEN MIDDLE - Very sparse, just a few small covers
        // =====================
        
        // Only 2-3 small obstacles in the center zone (x: 900-1500)
        for (let i = 0; i < 3; i++) {
          const x = 950 + Math.random() * 500;
          const y = 300 + Math.random() * (this.height - 600);
          addBuilding(x, y, 60, 60); // Small cover only
        }

        // =====================
        // EDGE LANES - Cover along top and bottom for flanking
        // =====================
        
        // Top lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, 80 + Math.random() * 60, 80, 80);
        }
        
        // Bottom lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, this.height - 160 + Math.random() * 60, 80, 80);
        }

        // =====================
        // PICKUP PITS - Enclosed areas for health/armor (like Roshan pit)
        // =====================
        // Remove temporary reservations (keep only non-reservation obstacles)
        this.obstacles = this.obstacles.filter(o => !o.isReservation);

        this.pickupPits = [];
        const wallThick = 20;

        // Helper to create a pit with 3 walls (U-shape), opening facing outward (toward walls)
        const createPit = (cx, cy, openingDir, type) => {
          // openingDir: 'up', 'down' (which way the entrance faces - toward the wall)
          const walls = [];

          if (openingDir === 'down') {
            // Opening faces down (toward bottom wall)
            // Back wall (top)
            walls.push({ x: cx - pitSize/2, y: cy - pitSize/2 - wallThick, w: pitSize, h: wallThick });
            // Left wall
            walls.push({ x: cx - pitSize/2 - wallThick, y: cy - pitSize/2 - wallThick, w: wallThick, h: pitSize + wallThick });
            // Right wall
            walls.push({ x: cx + pitSize/2, y: cy - pitSize/2 - wallThick, w: wallThick, h: pitSize + wallThick });
          } else if (openingDir === 'up') {
            // Opening faces up (toward top wall)
            // Back wall (bottom)
            walls.push({ x: cx - pitSize/2, y: cy + pitSize/2, w: pitSize, h: wallThick });
            // Left wall
            walls.push({ x: cx - pitSize/2 - wallThick, y: cy - pitSize/2, w: wallThick, h: pitSize + wallThick });
            // Right wall
            walls.push({ x: cx + pitSize/2, y: cy - pitSize/2, w: wallThick, h: pitSize + wallThick });
          }

          // Add walls to obstacles
          for (const w of walls) {
            this.obstacles.push(w);
            this.buildings.push(w);
          }

          // Store pit info for spawning with random respawn timer
          this.pickupPits.push({
            x: cx, y: cy,
            type: type, // 'health' or 'armor'
            hasPickup: false,
            respawnTimer: 0,
            respawnTime: 0 // Will be set when pickup is taken
          });
        };

        // 4 pits - using stored locations from reservation phase
        // Top-left area: health pit (opening faces UP toward wall)
        createPit(pitOffsetX, pitOffsetY, 'up', 'health');

        // Bottom-left area: armor pit (opening faces DOWN toward wall)
        createPit(pitOffsetX, this.height - pitOffsetY, 'down', 'armor');

        // Top-right area: armor pit (opening faces UP toward wall)
        createPit(this.width - pitOffsetX, pitOffsetY, 'up', 'armor');

        // Bottom-right area: health pit (opening faces DOWN toward wall)
        createPit(this.width - pitOffsetX, this.height - pitOffsetY, 'down', 'health');

        // =====================
        // TELEPORTERS - Pair of portals for quick map traversal
        // =====================
        this.teleporters = [];
        const teleporterRadius = 35;
        const teleporterMargin = 150; // Distance from corners

        // Bottom-left teleporter (near red side)
        const tele1 = {
          x: teleporterMargin + 100,
          y: this.height - teleporterMargin,
          radius: teleporterRadius,
          linkedTo: null, // Will be set after both are created
          lastUsedBy: null, // Prevent instant re-teleport
          useCooldown: 0
        };

        // Top-right teleporter (near blue side)
        const tele2 = {
          x: this.width - teleporterMargin - 100,
          y: teleporterMargin,
          radius: teleporterRadius,
          linkedTo: null,
          lastUsedBy: null,
          useCooldown: 0
        };

        // Link them together
        tele1.linkedTo = tele2;
        tele2.linkedTo = tele1;

        this.teleporters.push(tele1, tele2);

        // Schedule first activation at random time (leaving 30s buffer at end)
        this.scheduleTeleporterActivation();
      }

      scheduleTeleporterActivation() {
        // Activate at random time, but ensure 30s active window fits before round ends
        // Random activation between 10s and (roundTime - 30s)
        const minTime = 10;
        const maxTime = Math.max(minTime, this.roundTime - this.teleporterActiveDuration);
        const activationTime = minTime + Math.random() * (maxTime - minTime);
        this.teleporterNextActivation = this.roundTime - activationTime; // timeLeft when it activates
        this.teleporterActive = false;
        this.teleporterActiveTimer = 0;
      }

      updateTeleporters(dt) {
        if (!this.teleportersEnabled || this.teleporters.length < 2) return;

        // Update warp effects
        for (const effect of this.teleporterWarpEffects) {
          effect.timer += dt;
        }
        this.teleporterWarpEffects = this.teleporterWarpEffects.filter(e => e.timer < e.maxTime);

        // Update teleporter cooldowns
        for (const tele of this.teleporters) {
          if (tele.useCooldown > 0) {
            tele.useCooldown -= dt;
            if (tele.useCooldown <= 0) {
              tele.lastUsedBy = null;
            }
          }
        }

        // Check for activation
        if (!this.teleporterActive) {
          // Waiting to activate
          if (this.timeLeft <= this.teleporterNextActivation && this.timeLeft > 0) {
            this.teleporterActive = true;
            this.teleporterActiveTimer = this.teleporterActiveDuration;
            this.addEvent('üåÄ TELEPORTERS ACTIVATED!', 'teleporter');

            // Add activation warp effects at both portals
            for (const tele of this.teleporters) {
              this.teleporterWarpEffects.push({
                x: tele.x, y: tele.y,
                type: 'activate',
                timer: 0,
                maxTime: 0.5
              });
            }
          }
        } else {
          // Currently active, count down
          this.teleporterActiveTimer -= dt;
          if (this.teleporterActiveTimer <= 0) {
            this.teleporterActive = false;
            this.teleporterNextActivation = -1; // Prevent reactivation this round
            this.addEvent('üåÄ Teleporters deactivated', 'teleporter');

            // Add deactivation effects
            for (const tele of this.teleporters) {
              this.teleporterWarpEffects.push({
                x: tele.x, y: tele.y,
                type: 'deactivate',
                timer: 0,
                maxTime: 0.3
              });
            }
          }
        }

        // Check for agent teleportation (only when active)
        if (this.teleporterActive) {
          for (const agent of this.agents) {
            if (!agent.alive) continue;

            for (const tele of this.teleporters) {
              // Skip if this agent just used this teleporter
              if (tele.lastUsedBy === agent || tele.useCooldown > 0) continue;

              const dist = Math.hypot(agent.x - tele.x, agent.y - tele.y);
              if (dist < tele.radius + agent.radius) {
                // Teleport!
                const dest = tele.linkedTo;

                // Warp out effect at entry
                this.teleporterWarpEffects.push({
                  x: agent.x, y: agent.y,
                  type: 'warp_out',
                  team: agent.team,
                  timer: 0,
                  maxTime: 0.25
                });

                // Move agent to destination (offset slightly so they don't instantly re-enter)
                const exitAngle = Math.atan2(this.height/2 - dest.y, this.width/2 - dest.x);
                agent.x = dest.x + Math.cos(exitAngle) * (dest.radius + agent.radius + 10);
                agent.y = dest.y + Math.sin(exitAngle) * (dest.radius + agent.radius + 10);

                // Warp in effect at exit
                this.teleporterWarpEffects.push({
                  x: agent.x, y: agent.y,
                  type: 'warp_in',
                  team: agent.team,
                  timer: 0,
                  maxTime: 0.25
                });

                // Set cooldown on destination to prevent instant return
                dest.lastUsedBy = agent;
                dest.useCooldown = 1.0; // 1 second cooldown

                this.addEvent('üåÄ ' + agent.name + ' teleported!', 'teleporter');
                break; // Only teleport once per frame
              }
            }
          }
        }
      }

      generateUniqueName() {
        let n;
        let att = 0;
        do {
          n = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)] + ' ' + LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
          if (this.usedNames.has(n)) {
            let s = 2;
            while (this.usedNames.has(n + ' (' + s + ')')) s++;
            n = n + ' (' + s + ')';
          }
          att++;
        } while (this.usedNames.has(n) && att < 100);
        this.usedNames.add(n);
        return n;
      }

      spawnAgents(count) {
        this.population = count;
        this.agents = [];
        this.usedNames.clear();

        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = [];

        // Reset pickups and weapon state
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        this.droppedWeapons = [];
        this.dodgeTrails = [];

        // Reset pit spawn flags and timers, then spawn initial pickups
        for (const pit of this.pickupPits) {
          pit.hasPickup = false;
          pit.respawnTimer = 0;
          pit.respawnTime = 0;
        }
        this.spawnPickups(); // Spawn initial pickups in all pits

        // Reset teleporters for new round
        this.teleporterActive = false;
        this.teleporterActiveTimer = 0;
        this.teleporterWarpEffects = [];
        for (const tele of this.teleporters) {
          tele.lastUsedBy = null;
          tele.useCooldown = 0;
        }
        this.scheduleTeleporterActivation();

        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.weaponKills = { rocket: 0, laser: 0, sword: 0 };
        this.winningTeam = null;

        const perTeam = Math.floor(count / 2);

        // Create persistent soldiers for each team
        for (let team = 0; team < 2; team++) {
          const clusterX = team === 0 ? 80 : this.width - 80;
          const clusterY = this.height / 2;

          for (let i = 0; i < perTeam; i++) {
            let x = clusterX + (Math.random() - 0.5) * 150;
            let y = clusterY + (Math.random() - 0.5) * (this.height - 200);
            x = clamp(x, 40, this.width - 40);
            y = clamp(y, 40, this.height - 40);

            const brain = this.teamBrains[team]?.clone() || null;
            const agent = new Agent(x, y, this.generateUniqueName(), brain, team);
            agent.rotation = team === 0 ? 0 : Math.PI;

            if (this.teamBrains[team] && i > 0) {
              agent.brain.mutate(0.1, 0.3);
            }

            this.agents.push(agent);
          }
        }

        this.timeLeft = this.roundTime;

        // Apply forceWeapon if debug mode is active
        if (forceWeapon) {
          for (const agent of this.agents) {
            agent.weapon = forceWeapon;
            agent.hasPickedUpWeapon = true;
          }
        }

        // Spawn weapons at round start
        this.spawnLaserPickups();
        this.spawnSwordPickups();
      }

      spawnNextRound() {
        // Sort each team by score
        const redAgents = this.agents.filter(a => a.team === 0);
        const blueAgents = this.agents.filter(a => a.team === 1);
        
        redAgents.sort((a, b) => b.score - a.score);
        blueAgents.sort((a, b) => b.score - a.score);
        
        // Brain transfer: EVERYONE below top 10% gets a clone of a top performer
        const transferBrains = (agents) => {
          if (agents.length === 0) return;
          
          const top10pct = Math.max(1, Math.floor(agents.length * 0.1)); // Top 5 agents
          const top10Brains = agents.slice(0, top10pct).map(a => a.brain.clone());
          
          // Top 10% - keep their brains, tiny mutation to explore
          for (let i = 0; i < top10pct; i++) {
            agents[i].brain.mutate(0.02, 0.1);
          }
          
          // Everyone else gets a random top performer's brain with mutation
          for (let i = top10pct; i < agents.length; i++) {
            const parentBrain = top10Brains[Math.floor(Math.random() * top10Brains.length)];
            agents[i].brain = parentBrain.clone();
            
            // More mutation the worse they performed
            const performanceRatio = i / agents.length; // 0.1 to 1.0
            const mutationRate = 0.1 + performanceRatio * 0.2; // 0.1 to 0.3
            const mutationStrength = 0.2 + performanceRatio * 0.4; // 0.2 to 0.6
            agents[i].brain.mutate(mutationRate, mutationStrength);
          }
        };
        
        transferBrains(redAgents);
        transferBrains(blueAgents);
        
        // Update team brains to best performer
        if (redAgents[0]) this.teamBrains[0] = redAgents[0].brain.clone();
        if (blueAgents[0]) this.teamBrains[1] = blueAgents[0].brain.clone();
        
        // Reset round state
        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.weaponKills = { rocket: 0, laser: 0, sword: 0 };
        this.winningTeam = null;
        this.timeLeft = this.roundTime;
        this.generateObstacles();

        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = [];
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        this.droppedWeapons = []; // Weapons dropped by dead players or weapon swaps
        this.dodgeTrails = [];

        // Reset pit spawn flags and timers, then spawn initial pickups
        for (const pit of this.pickupPits) {
          pit.hasPickup = false;
          pit.respawnTimer = 0;
          pit.respawnTime = 0;
        }
        this.spawnPickups(); // Spawn initial pickups in all pits

        // Reset teleporters for new round
        this.teleporterActive = false;
        this.teleporterActiveTimer = 0;
        this.teleporterWarpEffects = [];
        for (const tele of this.teleporters) {
          tele.lastUsedBy = null;
          tele.useCooldown = 0;
        }
        this.scheduleTeleporterActivation();

        // Reset all agents for new round (but keep names and lifetime stats)
        for (const agent of this.agents) {
          const clusterX = agent.team === 0 ? 80 : this.width - 80;
          agent.x = clusterX + (Math.random() - 0.5) * 150;
          agent.y = this.height / 2 + (Math.random() - 0.5) * (this.height - 200);
          agent.x = clamp(agent.x, 40, this.width - 40);
          agent.y = clamp(agent.y, 40, this.height - 40);
          agent.rotation = agent.team === 0 ? 0 : Math.PI;
          agent.resetForRound();
        }

        // Apply forceWeapon after reset if debug mode is active
        if (forceWeapon) {
          for (const agent of this.agents) {
            agent.weapon = forceWeapon;
            agent.hasPickedUpWeapon = true;
          }
        }

        // Spawn weapons at round start (near team spawns)
        this.spawnLaserPickups();
        this.spawnSwordPickups();
      }

      // Keep for compatibility
      spawnFromParents(parents, total) {
        this.spawnNextRound();
      }

      rebuildSpatial() {
        this.spatialAgents.clear();
        for (const a of this.agents) if (a.alive) this.spatialAgents.insert(a, a.x, a.y);
      }

      update(dt) {
        if (this.paused) return;

        this.totalTime += dt;
        if (!persistentMode) {
          this.timeLeft -= dt;
        }

        // Pickup spawning (health/armor only - weapons spawn at round start)
        // Update per-pit respawn timers (Roshan-style random respawn)
        this.updatePitTimers(dt);

        // Teleporter activation and usage
        this.updateTeleporters(dt);

        // Pickup collection
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            const dist = Math.hypot(agent.x - p.x, agent.y - p.y);
            
            if (dist < agent.radius + p.radius) {
              // Collect pickup
              if (p.type === 'health') {
                const healed = Math.min(50, agent.maxHealth - agent.health);
                agent.health = Math.min(agent.maxHealth, agent.health + 50);
                if (healed > 0) {
                  this.addEvent('ü©π ' + agent.name + ' +' + healed + 'hp', 'pickup');
                }
                // Schedule random respawn for this pit
                if (p.pitRef) {
                  p.pitRef.hasPickup = false;
                  this.schedulePitRespawn(p.pitRef);
                }
                this.pickups.splice(i, 1);
              } else if (p.type === 'armor') {
                if (agent.armor < agent.maxArmor) {
                  const gained = Math.min(50, agent.maxArmor - agent.armor);
                  agent.armor = Math.min(agent.maxArmor, agent.armor + 50);
                  this.addEvent('üõ°Ô∏è ' + agent.name + ' +' + gained + ' armor', 'pickup');
                  // Schedule random respawn for this pit
                  if (p.pitRef) {
                    p.pitRef.hasPickup = false;
                    this.schedulePitRespawn(p.pitRef);
                  }
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'laser') {
                // Auto pickup on walk-over, but only once per round
                if (!agent.hasPickedUpWeapon) {
                  agent.weapon = 'laser';
                  agent.laserCharge = 0;
                  agent.weaponCooldown = 0;
                  agent.hasPickedUpWeapon = true;
                  this.addEvent('‚ö° ' + agent.name + ' GOT THE LASER!', 'laser');
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'sword') {
                // Auto pickup on walk-over, but only once per round
                if (!agent.hasPickedUpWeapon) {
                  agent.weapon = 'sword';
                  agent.swordCharge = 0;
                  agent.swordCharging = false;
                  agent.weaponCooldown = 0;
                  agent.hasPickedUpWeapon = true;
                  this.addEvent('üó°Ô∏è ' + agent.name + ' GOT THE ENERGY SWORD!', 'sword');
                  this.pickups.splice(i, 1);
                }
              }
            }
          }
        }

        // Check for dropped weapon pickups (auto pickup, but only once per round)
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          // Only pick up if agent hasn't picked up a weapon this round
          if (agent.hasPickedUpWeapon) continue;

          for (let i = this.droppedWeapons.length - 1; i >= 0; i--) {
            const w = this.droppedWeapons[i];
            const dx = agent.x - w.x;
            const dy = agent.y - w.y;
            if (dx * dx + dy * dy < (agent.radius + w.radius) * (agent.radius + w.radius)) {
              if (w.type === 'laser') {
                agent.weapon = 'laser';
                agent.laserCharge = 0;
                agent.weaponCooldown = 0;
                agent.hasPickedUpWeapon = true;
                this.addEvent('‚ö° ' + agent.name + ' PICKED UP DROPPED LASER!', 'laser');
                this.droppedWeapons.splice(i, 1);
              } else if (w.type === 'sword') {
                agent.weapon = 'sword';
                agent.swordCharge = 0;
                agent.swordCharging = false;
                agent.weaponCooldown = 0;
                agent.hasPickedUpWeapon = true;
                this.addEvent('üó°Ô∏è ' + agent.name + ' PICKED UP DROPPED SWORD!', 'sword');
                this.droppedWeapons.splice(i, 1);
              }
            }
          }
        }

        // Update alive count + spatial hash
        let alive = 0;
        for (const a of this.agents) if (a.alive) alive++;
        this.aliveCount = alive;
        this.rebuildSpatial();
        
        // Handle respawns
        for (const agent of this.agents) {
          if (!agent.alive && agent.respawnTimer > 0) {
            agent.respawnTimer -= dt;
            if (agent.respawnTimer <= 0) {
              agent.respawn(this);
              this.addEvent('üîÑ ' + agent.name + ' respawned', 'damage');
            }
          }
        }

        // Update rockets
        for (const r of this.rockets) {
          if (!r.alive) continue;
          
          // Move rocket
          r.x += Math.cos(r.angle) * r.speed * dt;
          r.y += Math.sin(r.angle) * r.speed * dt;
          r.traveled += r.speed * dt;
          
          // Spawn smoke particles behind rocket
          r.smokeTimer = (r.smokeTimer || 0) + dt;
          if (r.smokeTimer > 0.02) { // Every 20ms
            r.smokeTimer = 0;
            this.smokeParticles.push({
              x: r.x - Math.cos(r.angle) * 15,
              y: r.y - Math.sin(r.angle) * 15,
              vx: (Math.random() - 0.5) * 30,
              vy: (Math.random() - 0.5) * 30,
              life: 0.4, // 400ms lifetime
              maxLife: 0.4,
              size: 8 + Math.random() * 6
            });
          }
          
          let explode = false;
          let explodeX = r.x;
          let explodeY = r.y;
          
          // Check range
          if (r.traveled >= r.range) {
            explode = true;
          }
          
          // Check wall collision
          if (r.x < 0 || r.x > this.width || r.y < 0 || r.y > this.height) {
            explode = true;
            explodeX = clamp(r.x, 0, this.width);
            explodeY = clamp(r.y, 0, this.height);
          }
          
          // Check obstacle collision
          if (!explode) {
            for (const obs of this.obstacles) {
              if (r.x >= obs.x && r.x <= obs.x + obs.w && r.y >= obs.y && r.y <= obs.y + obs.h) {
                explode = true;
                break;
              }
            }
          }
          
          // Check agent collision (direct hit)
          if (!explode) {
            for (const agent of this.agents) {
              if (agent === r.owner || !agent.alive) continue;
              if (Math.hypot(r.x - agent.x, r.y - agent.y) < agent.radius + 8) {
                explode = true;
                explodeX = agent.x;
                explodeY = agent.y;
                break;
              }
            }
          }
          
          // Create explosion
          if (explode) {
            r.alive = false;
            this.explosions.push({
              x: explodeX, y: explodeY, 
              owner: r.owner, 
              damage: r.damage,
              splashRadius: r.splashRadius,
              splashFalloff: r.splashFalloff,
              timer: 0, 
              maxTime: 0.4, 
              dealtDamage: false
            });
          }
        }
        this.rockets = this.rockets.filter(r => r.alive);

        // Update smoke particles
        for (const p of this.smokeParticles) {
          p.life -= dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.95; // Slow down
          p.vy *= 0.95;
          p.size += dt * 10; // Expand
        }
        this.smokeParticles = this.smokeParticles.filter(p => p.life > 0);

        // Update explosions - SPLASH DAMAGE
        for (const e of this.explosions) {
          e.timer += dt;
          
          if (!e.dealtDamage && e.timer >= 0.05) {
            e.dealtDamage = true;
            
            for (const agent of this.agents) {
              if (!agent.alive) continue;
              
              const dist = Math.hypot(agent.x - e.x, agent.y - e.y);
              if (dist > e.splashRadius) continue;
              
              // Damage falloff based on distance
              const falloff = 1 - (dist / e.splashRadius) * e.splashFalloff;
              const dmg = Math.floor(e.damage * falloff);
              
              if (agent === e.owner) {
                // Direct self-damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (killed) {
                  this.addEvent('üíÄ ' + e.owner.name + ' ROCKET JUMPED TOO HARD!', 'kill');
                }
              } else if (e.owner && agent.team === e.owner.team) {
                // Teammate hit
                if (this.friendlyFire) {
                  // Direct friendly fire - damage teammate
                  const killed = agent.takeDamage(dmg, e.owner, this);
                  if (killed) {
                    this.teamRicochets[e.owner.team]++;
                    this.addEvent('üíÄ ' + e.owner.name + ' TEAMKILLED ' + agent.name + '!', 'kill');
                  }
                } else if (this.friendlyFireRicochet) {
                  // Ricochet - damage reflects to shooter
                  const killed = e.owner.takeDamage(dmg, e.owner, this);
                  this.teamRicochets[e.owner.team]++;
                  if (killed) {
                    this.addEvent('üîÑ ' + e.owner.name + ' DIED FROM RICOCHET!', 'kill');
                  } else {
                    this.addEvent('üîÑ ' + e.owner.name + ' ricochet -' + dmg + 'hp', 'damage');
                  }
                }
                // Else: no friendly fire, skip
              } else {
                // Enemy damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (e.owner) {
                  e.owner.damageDealt += dmg;
                  e.owner.lifeDamageDealt += dmg;
                  if (killed) {
                    e.owner.kills++;
                    e.owner.totalKills = (e.owner.totalKills || 0) + 1;
                    e.owner.lifeKills++;
                    e.owner.weaponKills.rocket++;
                    e.owner.totalWeaponKills.rocket++;
                    this.weaponKills.rocket++;
                    this.totalWeaponKills.rocket++;
                    this.teamKills[e.owner.team]++;
                    this.teamRawKills[e.owner.team]++;
                    this.addEvent('üöÄ ' + e.owner.name + ' FRAGGED ' + agent.name + '!', 'kill');
                  }
                }
              }
            }
          }
        }
        this.explosions = this.explosions.filter(e => e.timer < e.maxTime);

        // Get decisions
        const decisions = new Array(this.agents.length);
        for (let i = 0; i < this.agents.length; i++) {
          decisions[i] = this.agents[i].think(this);
        }

        // Update agents
        for (let i = 0; i < this.agents.length; i++) {
          const a = this.agents[i];
          const d = decisions[i];
          a.update(d, dt, this, this.obstacles);

          // Handle shooting based on weapon type
          if (d && d.wantsShoot) {
            if (a.weapon === 'rocket') {
              const rocket = a.tryShoot(this);
              if (rocket) {
                this.rockets.push(rocket);
              }
            } else if (a.weapon === 'laser') {
              // Laser charging
              if (a.weaponCooldown <= 0) {
                a.laserCharging = true;
                a.laserCharge += dt;
                
                // Fire when fully charged
                if (a.laserCharge >= 3.0) {
                  this.fireLaser(a);
                  a.laserCharge = 0;
                  a.laserCharging = false;
                  a.weaponCooldown = 1.0; // 1 second cooldown
                }
              }
            } else if (a.weapon === 'sword') {
              // Hold to aim - instantly max charged
              if (a.weaponCooldown <= 0 && !a.swordLunging) {
                a.swordCharging = true;
                a.swordCharge = 2.0; // Instant max charge
              }
            }
          } else {
            // Reset laser charge if not holding shoot
            if (a.weapon === 'laser' && a.laserCharging) {
              a.laserCharge = 0;
              a.laserCharging = false;
            }
            // Execute sword lunge when releasing
            if (a.weapon === 'sword' && a.swordCharging) {
              this.executeSwordLunge(a, a.swordCharge);
              a.swordCharge = 0;
              a.swordCharging = false;
            }
          }
        }
        
        // Update laser beams animation
        for (const beam of this.laserBeams) {
          beam.timer += dt;
        }
        this.laserBeams = this.laserBeams.filter(b => b.timer < b.maxTime);
        
        // Update sword slash animations
        for (const slash of this.swordSlashes) {
          slash.timer += dt;
        }
        this.swordSlashes = this.swordSlashes.filter(s => s.timer < s.maxTime);

        // Update dodge trail animations
        for (const trail of this.dodgeTrails) {
          trail.timer += dt;
        }
        this.dodgeTrails = this.dodgeTrails.filter(t => t.timer < t.maxTime);

        // Agent-agent collision (push apart)
        const aliveAgents = this.agents.filter(a => a.alive);
        for (let i = 0; i < aliveAgents.length; i++) {
          for (let j = i + 1; j < aliveAgents.length; j++) {
            const a = aliveAgents[i];
            const b = aliveAgents[j];
            
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = a.radius + b.radius;
            
            if (dist < minDist && dist > 0) {
              // Push apart
              const overlap = minDist - dist;
              const pushX = (dx / dist) * overlap * 0.5;
              const pushY = (dy / dist) * overlap * 0.5;
              
              a.x -= pushX;
              a.y -= pushY;
              b.x += pushX;
              b.y += pushY;
              
              // Clamp to world bounds
              a.x = clamp(a.x, a.radius, this.width - a.radius);
              a.y = clamp(a.y, a.radius, this.height - a.radius);
              b.x = clamp(b.x, b.radius, this.width - b.radius);
              b.y = clamp(b.y, b.radius, this.height - b.radius);
            }
          }
        }

        // Check win condition (only in generational mode)
        if (!persistentMode) {
          if (this.teamKills[0] >= this.killLimit || this.teamKills[1] >= this.killLimit || this.timeLeft <= 0) {
            this.endRound();
          }
        }
      }
      endRound() {
        // Determine winner
        if (this.teamKills[0] >= this.killLimit) {
          this.winningTeam = 0;
          this.teamWins[0]++;
          this.addEvent('üî¥ RED TEAM WINS! ' + this.teamKills[0] + ' kills!', 'kill');
        } else if (this.teamKills[1] >= this.killLimit) {
          this.winningTeam = 1;
          this.teamWins[1]++;
          this.addEvent('üîµ BLUE TEAM WINS! ' + this.teamKills[1] + ' kills!', 'kill');
        } else {
          // Time out - team with most kills wins
          this.winningTeam = this.teamKills[0] > this.teamKills[1] ? 0 : 1;
          this.teamWins[this.winningTeam]++;
          const winnerName = this.winningTeam === 0 ? 'RED' : 'BLUE';
          this.addEvent('‚è±Ô∏è TIME! ' + winnerName + ' WINS ' + this.teamKills[this.winningTeam] + '-' + this.teamKills[1-this.winningTeam], 'kill');
        }
        
        // Get best brain from winning team
        const winningAgents = this.agents.filter(a => a.team === this.winningTeam);
        const bestAgent = winningAgents.sort((a, b) => b.score - a.score)[0];
        
        // Update the winning team's brain
        this.teamBrains[this.winningTeam] = bestAgent.brain.clone();
        
        // Losing team gets a mutated version of their best, or copy winner if they had none
        const losingTeam = 1 - this.winningTeam;
        const losingAgents = this.agents.filter(a => a.team === losingTeam);
        const bestLoser = losingAgents.sort((a, b) => b.score - a.score)[0];
        if (bestLoser) {
          this.teamBrains[losingTeam] = bestLoser.brain.clone();
          this.teamBrains[losingTeam].mutate(0.2, 0.5);
        }
        
        this.addEvent('GENERATION ' + this.generation + ' COMPLETE', 'kill');
        this.generation++;
        this.spawnNextRound();
      }

      // Drop a weapon on the ground (when player dies)
      dropWeapon(x, y, weaponType) {
        if (weaponType !== 'laser' && weaponType !== 'sword') return;

        this.droppedWeapons.push({
          x: x,
          y: y,
          type: weaponType,
          radius: 15
        });

        this.addEvent('üí´ ' + weaponType.toUpperCase() + ' DROPPED!', weaponType);
      }

      addEvent(text, type) {
        this.events.unshift({ text, type, time: Date.now() });
        if (this.events.length > 80) this.events.pop();
      }

      getLeaderboard() {
        return [...this.agents].sort((a, b) => b.score - a.score).slice(0, 10);
      }
    }

    // --------------------
    // Renderer
    // --------------------
    class Renderer {
      constructor(canvas, world) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.world = world;
        this.cameraX = 0;
        this.cameraY = 0;
        this.zoom = 1;
        this.minZoom = 0.25;
        this.maxZoom = 3;
        this.isDragging = false;
        this.baseScale = 1;
        this.cssW = 0;
        this.cssH = 0;
        this.dpr = 1;
        this.followAgent = null;
        this.dragDistance = 0;
        this.setupControls();
        this.resize();
      }

      getCenterOffset() {
        const s = this.baseScale * this.zoom;
        const worldW = this.world.width * s;
        const worldH = this.world.height * s;
        return {
          x: Math.max(0, (this.cssW - worldW) / 2),
          y: Math.max(0, (this.cssH - worldH) / 2)
        };
      }

      setupControls() {
        const onWheel = (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          const offset = this.getCenterOffset();
          const adjustedMouseX = mouseX - offset.x;
          const adjustedMouseY = mouseY - offset.y;
          const worldX = this.cameraX + adjustedMouseX / (this.baseScale * this.zoom);
          const worldY = this.cameraY + adjustedMouseY / (this.baseScale * this.zoom);
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          this.zoom = clamp(this.zoom * zoomFactor, this.minZoom, this.maxZoom);
          const newOffset = this.getCenterOffset();
          const newAdjustedMouseX = mouseX - newOffset.x;
          const newAdjustedMouseY = mouseY - newOffset.y;
          this.cameraX = worldX - newAdjustedMouseX / (this.baseScale * this.zoom);
          this.cameraY = worldY - newAdjustedMouseY / (this.baseScale * this.zoom);
          this.clampCamera();
        };
        this.canvas.addEventListener('wheel', onWheel, { passive: false });

        const startDrag = (x, y) => {
          this.isDragging = true;
          this.dragStartX = x;
          this.dragStartY = y;
          this.dragCamX = this.cameraX;
          this.dragCamY = this.cameraY;
          this.dragDistance = 0;
          this.canvas.style.cursor = 'grabbing';
        };

        const moveDrag = (x, y) => {
          if (!this.isDragging) return;
          const dx = x - this.dragStartX;
          const dy = y - this.dragStartY;
          this.dragDistance = Math.hypot(dx, dy);
          this.cameraX = this.dragCamX - dx / (this.baseScale * this.zoom);
          this.cameraY = this.dragCamY - dy / (this.baseScale * this.zoom);
          this.clampCamera();
          if (this.dragDistance > 5) this.followAgent = null;
        };

        const endDrag = (x, y) => {
          const wasClick = this.dragDistance < 5;
          this.isDragging = false;
          this.canvas.style.cursor = 'grab';
          if (wasClick && x !== undefined) this.handleClick(x, y);
        };

        this.canvas.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
        window.addEventListener('mouseup', (e) => endDrag(e.clientX, e.clientY));

        // Touch support
        this.canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) startDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: true });
        this.canvas.addEventListener('touchmove', (e) => {
            if (!this.isDragging || e.touches.length !== 1) return;
            e.preventDefault();
            moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        this.canvas.addEventListener('touchend', endDrag);
        this.canvas.style.cursor = 'grab';
      }

      clampCamera() {
        const vw = this.cssW / (this.baseScale * this.zoom);
        const vh = this.cssH / (this.baseScale * this.zoom);
        // Allow looking slightly outside bounds
        this.cameraX = clamp(this.cameraX, -500, this.world.width - vw + 500);
        this.cameraY = clamp(this.cameraY, -500, this.world.height - vh + 500);
      }

      handleClick(clientX, clientY) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;
        const offset = this.getCenterOffset();
        const s = this.baseScale * this.zoom;
        const worldX = this.cameraX + (mouseX - offset.x) / s;
        const worldY = this.cameraY + (mouseY - offset.y) / s;

        let closestAgent = null;
        let closestDist = 50; // Increased click radius

        for (const agent of this.world.agents) {
          const dist = Math.hypot(agent.x - worldX, agent.y - worldY);
          if (dist < closestDist) {
            closestDist = dist;
            closestAgent = agent;
          }
        }
        this.followAgent = closestAgent || null;
      }

      updateFollow() {
        if (!this.followAgent) return;
        if (this.followAgent.alive) {
          const vw = this.cssW / (this.baseScale * this.zoom);
          const vh = this.cssH / (this.baseScale * this.zoom);
          // Smooth follow
          const targetX = this.followAgent.x - vw / 2;
          const targetY = this.followAgent.y - vh / 2;
          this.cameraX += (targetX - this.cameraX) * 0.1;
          this.cameraY += (targetY - this.cameraY) * 0.1;
          this.clampCamera();
        }
      }

      resize() {
        const container = this.canvas.parentElement;
        this.cssW = container.clientWidth;
        this.cssH = container.clientHeight;
        this.dpr = window.devicePixelRatio || 1;
        this.canvas.width = Math.floor(this.cssW * this.dpr);
        this.canvas.height = Math.floor(this.cssH * this.dpr);

        const scaleX = this.cssW / this.world.width;
        const scaleY = this.cssH / this.world.height;
        this.baseScale = Math.min(scaleX, scaleY);
        this.clampCamera();
      }

      render() {
        const ctx = this.ctx;
        const s = this.baseScale * this.zoom;

        // Reset and Clear
        ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, this.cssW, this.cssH);

        const worldW = this.world.width * s;
        const worldH = this.world.height * s;
        const offsetX = Math.max(0, (this.cssW - worldW) / 2);
        const offsetY = Math.max(0, (this.cssH - worldH) / 2);

        ctx.save();
        ctx.translate(offsetX - this.cameraX * s, offsetY - this.cameraY * s);

        const maxX = this.world.width * s;
        const maxY = this.world.height * s;

        // --- BACKGROUND & GRID ---
        if (turboMode) {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, maxX, maxY);
        } else {
            // World Boundary
            ctx.strokeStyle = '#334455';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, maxX, maxY);

            // Grid
            ctx.strokeStyle = 'rgba(50, 100, 150, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 100 * s;

            ctx.beginPath();
            for (let x = 0; x <= maxX; x += gridSize) {
                ctx.moveTo(x, 0); ctx.lineTo(x, maxY);
            }
            for (let y = 0; y <= maxY; y += gridSize) {
                ctx.moveTo(0, y); ctx.lineTo(maxX, y);
            }
            ctx.stroke();

            // Spawn Zones
            const drawZone = (x, color) => {
                const grad = ctx.createRadialGradient(x, maxY/2, 0, x, maxY/2, 300 * s);
                grad.addColorStop(0, color.replace('1)', '0.15)'));
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0, maxX, maxY);
            };
            drawZone(80*s, 'rgba(255, 50, 80, 1)');
            drawZone(maxX - 80*s, 'rgba(50, 150, 255, 1)');
        }

        // --- OBSTACLES ---
        for (const b of this.world.buildings) {
            const x = b.x * s, y = b.y * s, w = b.w * s, h = b.h * s;
            if (turboMode) {
                ctx.fillStyle = '#222';
                ctx.fillRect(x,y,w,h);
                ctx.strokeStyle = '#444';
                ctx.strokeRect(x,y,w,h);
            } else {
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.fillStyle = '#101216';
                ctx.fillRect(x, y, w, h);
                ctx.shadowBlur = 0;

                // Tech borders
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x,y,w,h);

                // Inner details
                ctx.fillStyle = 'rgba(100, 200, 255, 0.05)';
                ctx.fillRect(x+5, y+5, w-10, h-10);
            }
        }

        // --- TELEPORTERS ---
        this.drawTeleporters(ctx, s);

        // --- DROPPED WEAPONS ---
        for (const w of this.world.droppedWeapons) {
             const wx = w.x * s, wy = w.y * s, wr = w.radius * s;
             const color = w.type === 'laser' ? '#0ff' : '#f0f';
             ctx.shadowBlur = 15;
             ctx.shadowColor = color;
             ctx.strokeStyle = color;
             ctx.lineWidth = 2;
             ctx.beginPath();
             ctx.arc(wx, wy, wr, 0, Math.PI*2);
             ctx.stroke();
             // Label
             ctx.fillStyle = color;
             ctx.font = `bold ${10*s}px monospace`;
             ctx.textAlign = 'center';
             ctx.fillText(w.type.toUpperCase(), wx, wy - wr - 5);
             ctx.shadowBlur = 0;
        }

        // --- PICKUPS ---
        for (const p of this.world.pickups) {
            const px = p.x * s, py = p.y * s, pr = p.radius * s;
            let color = '#fff';
            let icon = '';
            if (p.type === 'health') { color = '#0f9'; icon = '+'; }
            if (p.type === 'armor') { color = '#09f'; icon = 'üõ°'; }
            if (p.type === 'laser') { color = '#0ff'; icon = '‚ö°'; }
            if (p.type === 'sword') { color = '#f0f'; icon = 'üó°'; }

            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            // Rotating Box
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(Date.now() / 500);
            ctx.strokeRect(-pr/2, -pr/2, pr, pr);
            ctx.restore();

            // Icon
            ctx.fillStyle = color;
            ctx.font = `bold ${14*s}px monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(icon, px, py);
            ctx.shadowBlur = 0;
        }

        // --- ROCKETS ---
        for (const r of this.world.rockets) {
            if (!r.alive) continue;
            const rx = r.x * s, ry = r.y * s;

            ctx.save();
            ctx.translate(rx, ry);
            ctx.rotate(r.angle);

            // Trail
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#f60';
            ctx.fillStyle = '#f60';
            ctx.fillRect(-15*s, -2*s, 15*s, 4*s);

            // Head
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, -3*s, 8*s, 6*s);

            ctx.restore();
            ctx.shadowBlur = 0;
        }

        // --- SMOKE PARTICLES ---
        if(!turboMode) {
            for (const p of this.world.smokeParticles) {
                ctx.fillStyle = `rgba(100,100,100, ${p.life * 0.5})`;
                ctx.beginPath();
                ctx.arc(p.x * s, p.y * s, p.size * s, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // --- AGENTS ---
        for (const agent of this.world.agents) {
            if (!agent.alive) {
                // Dead marker
                ctx.fillStyle = 'rgba(50,50,50,0.5)';
                ctx.beginPath();
                ctx.arc(agent.x*s, agent.y*s, agent.radius*s*0.8, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.font = `${12*s}px monospace`;
                ctx.textAlign = 'center';
                ctx.fillText('‚ò†', agent.x*s, agent.y*s + 4*s);
                continue;
            }

            const x = agent.x * s, y = agent.y * s, r = agent.radius * s;
            const isRed = agent.team === 0;
            const baseColor = isRed ? '#ff4466' : '#4488ff';

            // Selected highlight
            if (agent === this.followAgent) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, r * 1.8, 0, Math.PI*2);
                ctx.stroke();

                // Vision Cone visualization for selected
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.beginPath();
                ctx.moveTo(x,y);
                ctx.arc(x, y, 300*s, agent.rotation - 0.4, agent.rotation + 0.4);
                ctx.fill();
            }

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(agent.rotation);

            // Body
            ctx.shadowBlur = 10;
            ctx.shadowColor = baseColor;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();

            // Ring
            ctx.strokeStyle = baseColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();

            // Direction Arrow
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.moveTo(r*0.6, -r*0.4);
            ctx.lineTo(r*1.2, 0);
            ctx.lineTo(r*0.6, r*0.4);
            ctx.fill();

            // Weapon indicators
            if (agent.weapon === 'sword') {
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, r); ctx.lineTo(r*2, r); // Blade sticking out
                ctx.stroke();
            }
            if (agent.weapon === 'laser') {
                 // Laser glow
                 ctx.fillStyle = '#0ff';
                 ctx.beginPath();
                 ctx.arc(0, -r, 3*s, 0, Math.PI*2);
                 ctx.fill();
            }

            ctx.restore();
            ctx.shadowBlur = 0;

            // Bars
            const barW = 24 * s;
            const barY = y - r - 8 * s;

            // Health BG
            ctx.fillStyle = '#222';
            ctx.fillRect(x - barW/2, barY, barW, 3*s);
            // Health FG
            const hpPct = agent.health / agent.maxHealth;
            ctx.fillStyle = hpPct > 0.5 ? '#0f9' : '#f44';
            ctx.fillRect(x - barW/2, barY, barW * hpPct, 3*s);

            // Armor (if any)
            if (agent.armor > 0) {
                ctx.fillStyle = '#09f';
                ctx.fillRect(x - barW/2, barY - 4*s, barW * (agent.armor/100), 2*s);
            }
        }

        // --- EXPLOSIONS ---
        ctx.globalCompositeOperation = 'lighter';
        for (const e of this.world.explosions) {
            const ex = e.x * s, ey = e.y * s;
            const progress = e.timer / e.maxTime;
            const radius = e.splashRadius * s * Math.sin(progress * Math.PI);

            // Core
            const grad = ctx.createRadialGradient(ex, ey, 0, ex, ey, radius);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.4, 'rgba(255, 150, 50, 0.8)');
            grad.addColorStop(1, 'rgba(255, 50, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(ex, ey, radius, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';

        // --- LASER BEAMS ---
        for (const beam of this.world.laserBeams) {
            const alpha = 1 - (beam.timer / beam.maxTime);
            if (alpha <= 0) continue;

            ctx.lineWidth = 4 * s * alpha;
            ctx.lineCap = 'round';
            ctx.strokeStyle = beam.team === 0 ? `rgba(255,0,100,${alpha})` : `rgba(0,150,255,${alpha})`;
            ctx.shadowBlur = 10;
            ctx.shadowColor = ctx.strokeStyle;

            ctx.beginPath();
            for (const seg of beam.segments) {
                ctx.moveTo(seg.startX * s, seg.startY * s);
                ctx.lineTo(seg.endX * s, seg.endY * s);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // --- SWORD SLASHES ---
        for (const slash of this.world.swordSlashes) {
            const alpha = 1 - (slash.timer / slash.maxTime);
            ctx.strokeStyle = slash.team === 0 ? `rgba(255,50,50,${alpha})` : `rgba(50,100,255,${alpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(slash.startX * s, slash.startY * s);
            ctx.lineTo(slash.endX * s, slash.endY * s);
            ctx.stroke();
        }

        // --- DODGE TRAILS ---
        for (const trail of this.world.dodgeTrails) {
            const alpha = (1 - trail.timer / trail.maxTime) * 0.3;
            ctx.strokeStyle = trail.team === 0 ? `rgba(255,0,0,${alpha})` : `rgba(0,100,255,${alpha})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(trail.startX * s, trail.startY * s);
            ctx.lineTo(trail.endX * s, trail.endY * s);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.restore();
      }

      drawTeleporters(ctx, s) {
        if (!this.world.teleporters) return;
        for (const t of this.world.teleporters) {
            const x = t.x * s, y = t.y * s, r = t.radius * s;
            const active = this.world.teleporterActive;

            ctx.save();
            ctx.translate(x, y);
            if (active) ctx.rotate(Date.now() / 200);

            ctx.shadowBlur = active ? 20 : 0;
            ctx.shadowColor = '#a0f';
            ctx.strokeStyle = active ? '#d0f' : '#444';
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI*2);
            ctx.stroke();

            // Inner spiral
            ctx.beginPath();
            ctx.arc(0, 0, r*0.6, 0, Math.PI*1.5);
            ctx.stroke();

            ctx.restore();
        }
      }
    }

    // --------------------
    // Init
    // --------------------
    const canvas = document.getElementById('canvas');
    const world = new World(3600, 2400); // 50% wider arena
    const renderer = new Renderer(canvas, world);

    let population = 100;
    let simSpeed = 1;

    world.spawnAgents(population);

    const ui = {
      gen: document.getElementById('generation'),
      genRow: document.getElementById('generation-row'),
      alive: document.getElementById('alive'),
      time: document.getElementById('time-left'),
      leaderboard: document.getElementById('leaderboard'),

      zoom: document.getElementById('zoom'),
      speed: document.getElementById('speed'),
      population: document.getElementById('population'),
      roundTime: document.getElementById('round-time'),
      killLimit: document.getElementById('kill-limit'),

      zoomValue: document.getElementById('zoom-value'),
      speedValue: document.getElementById('speed-value'),
      populationValue: document.getElementById('population-value'),
      roundTimeValue: document.getElementById('round-time-value'),
      killLimitValue: document.getElementById('kill-limit-value'),
      killLimitDisplay: document.getElementById('kill-limit-display'),

      // Team score elements (new layout)
      redScore: document.getElementById('red-score'),
      blueScore: document.getElementById('blue-score'),
      redWins: document.getElementById('red-wins'),
      blueWins: document.getElementById('blue-wins'),

      // Toggles
      toggleHealth: document.getElementById('toggle-health'),
      toggleArmor: document.getElementById('toggle-armor'),
      toggleLaser: document.getElementById('toggle-laser'),
      toggleSword: document.getElementById('toggle-sword'),
      toggleDodge: document.getElementById('toggle-dodge'),
      toggleTeleporter: document.getElementById('toggle-teleporter'),
      toggleFf: document.getElementById('toggle-ff'),
      toggleRicochet: document.getElementById('toggle-ricochet'),
      // Mode selector
      modeRounds: document.getElementById('mode-rounds'),
      modePersistent: document.getElementById('mode-persistent'),
      modeSub: document.getElementById('mode-sub'),

      // Pre-simulation screen
      preSimScreen: document.getElementById('pre-sim-screen'),
      preSimTitle: document.getElementById('pre-sim-title'),
      preSimSubtitle: document.getElementById('pre-sim-subtitle'),
      preSimDescription: document.getElementById('pre-sim-description'),
      preSimFeatures: document.getElementById('pre-sim-features'),
      startSimBtn: document.getElementById('start-sim-btn'),

      // Stats panel
      statsBtn: document.getElementById('stats-btn'),
      statsPanel: document.getElementById('stats-panel'),
      statsClose: document.getElementById('stats-close'),
      statsMode: document.getElementById('stats-mode'),
      statsTotalLives: document.getElementById('stats-total-lives'),
      statsRocketKills: document.getElementById('stats-rocket-kills'),
      statsLaserKills: document.getElementById('stats-laser-kills'),
      statsSwordKills: document.getElementById('stats-sword-kills'),
      statsRedHof: document.getElementById('stats-red-hof'),
      statsBlueHof: document.getElementById('stats-blue-hof'),
      clearHofBtn: document.getElementById('clear-hof-btn'),

      // Respawn time slider
      respawnTime: document.getElementById('respawn-time'),
      respawnTimeValue: document.getElementById('respawn-time-value'),

      pauseBtn: document.getElementById('pause-btn'),
      restartBtn: document.getElementById('restart-btn'),
      saveBtn: document.getElementById('save-btn'),
      loadBtn: document.getElementById('load-btn'),
      copyBtn: document.getElementById('copy-btn'),
      demoBtn: document.getElementById('demo-btn'),
      loadFile: document.getElementById('load-file'),
      headlessBtn: document.getElementById('headless-btn'),
      turboBtn: document.getElementById('turbo-btn'),
      headlessOverlay: document.getElementById('headless-overlay'),

      // Global weapon stats
      globalRocketKills: document.getElementById('global-rocket-kills'),
      globalLaserKills: document.getElementById('global-laser-kills'),
      globalSwordKills: document.getElementById('global-sword-kills'),

      // Agent profile card
      agentProfile: document.getElementById('agent-profile'),
      profileName: document.getElementById('profile-name'),
      profileTeam: document.getElementById('profile-team'),
      profileHealthBar: document.getElementById('profile-health-bar'),
      profileHealthVal: document.getElementById('profile-health-val'),
      profileArmorBar: document.getElementById('profile-armor-bar'),
      profileArmorVal: document.getElementById('profile-armor-val'),
      profileWeapon: document.getElementById('profile-weapon'),
      profileKd: document.getElementById('profile-kd'),
      neuralTurn: document.getElementById('neural-turn'),
      neuralSpeed: document.getElementById('neural-speed'),
      neuralStrafe: document.getElementById('neural-strafe'),
      neuralShoot: document.getElementById('neural-shoot'),
      neuralDash: document.getElementById('neural-dash'),
      awarenessEnemy: document.getElementById('awareness-enemy'),
      awarenessAlly: document.getElementById('awareness-ally'),

      // Control bar
      ctrlSave: document.getElementById('ctrl-save'),
      ctrlLoad: document.getElementById('ctrl-load'),
      ctrlReset: document.getElementById('ctrl-reset'),
      ctrlPlay: document.getElementById('ctrl-play'),
      ctrlHeadless: document.getElementById('ctrl-headless'),
      ctrlPerformance: document.getElementById('ctrl-performance'),

      // Stats panel elements
      statsUps: document.getElementById('stats-ups'),
      statsLeaderboard: document.getElementById('stats-leaderboard'),
      statsCombatLog: document.getElementById('stats-combat-log'),
      hofSection: document.getElementById('hof-section'),
      statsTotalLivesRow: document.getElementById('stats-total-lives-row'),
    };

    // Headless mode
    let headlessMode = true;
    ui.headlessOverlay.classList.add('visible');
    
    ui.headlessBtn.addEventListener('click', () => {
      headlessMode = !headlessMode;
      ui.headlessBtn.textContent = headlessMode ? 'üñ•Ô∏è HEADLESS MODE (ON)' : 'üñ•Ô∏è HEADLESS MODE (OFF)';
      ui.headlessBtn.style.background = headlessMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(100, 100, 100, 0.1)';
      ui.headlessBtn.style.borderColor = headlessMode ? '#0f0' : '#888';
      ui.headlessBtn.style.color = headlessMode ? '#0f0' : '#888';
      ui.headlessOverlay.classList.toggle('visible', headlessMode);
      ui.ctrlHeadless.classList.toggle('active', headlessMode);
    });

    // Turbo mode - ultra performance rendering
    ui.turboBtn.addEventListener('click', () => {
      turboMode = !turboMode;
      ui.turboBtn.textContent = turboMode ? '‚ö° TURBO MODE (ON)' : '‚ö° TURBO MODE (OFF)';
      ui.turboBtn.style.background = turboMode ? 'rgba(255, 100, 0, 0.5)' : 'rgba(255, 100, 0, 0.2)';
      ui.turboBtn.style.borderColor = turboMode ? '#ff6400' : '#ff6400';
      ui.turboBtn.style.color = turboMode ? '#fff' : '#ff6400';
      world.addEvent(turboMode ? '‚ö° TURBO MODE ON - Max Performance!' : '‚ö° TURBO MODE OFF', 'kill');
      ui.ctrlPerformance.classList.toggle('active', turboMode);
    });

    // Debug buttons - give all agents a weapon (persists after death)
    const debugSwordBtn = document.getElementById('debug-sword-btn');
    const debugLaserBtn = document.getElementById('debug-laser-btn');

    function updateDebugButtonStyles() {
      // Sword button
      if (forceWeapon === 'sword') {
        debugSwordBtn.style.background = 'rgba(255, 0, 255, 0.5)';
        debugSwordBtn.style.color = '#fff';
        debugSwordBtn.textContent = 'üó°Ô∏è SWORD (ON)';
      } else {
        debugSwordBtn.style.background = 'rgba(255, 0, 255, 0.1)';
        debugSwordBtn.style.color = '#ff00ff';
        debugSwordBtn.textContent = 'üó°Ô∏è ALL SWORD';
      }
      // Laser button
      if (forceWeapon === 'laser') {
        debugLaserBtn.style.background = 'rgba(0, 200, 255, 0.5)';
        debugLaserBtn.style.color = '#fff';
        debugLaserBtn.textContent = '‚ö° LASER (ON)';
      } else {
        debugLaserBtn.style.background = 'rgba(0, 200, 255, 0.1)';
        debugLaserBtn.style.color = '#00aaff';
        debugLaserBtn.textContent = '‚ö° ALL LASER';
      }
    }

    debugSwordBtn.addEventListener('click', () => {
      if (forceWeapon === 'sword') {
        // Toggle off - reset all to rocket
        forceWeapon = null;
        for (const agent of world.agents) {
          agent.weapon = 'rocket';
          agent.hasPickedUpWeapon = false;
        }
        world.addEvent('üó°Ô∏è Sword mode OFF - weapons reset', 'sword');
      } else {
        forceWeapon = 'sword';
        for (const agent of world.agents) {
          agent.weapon = 'sword';
          agent.hasPickedUpWeapon = true;
        }
        world.addEvent('üó°Ô∏è Sword mode ON - persists after death!', 'sword');
      }
      updateDebugButtonStyles();
    });

    debugLaserBtn.addEventListener('click', () => {
      if (forceWeapon === 'laser') {
        // Toggle off - reset all to rocket
        forceWeapon = null;
        for (const agent of world.agents) {
          agent.weapon = 'rocket';
          agent.hasPickedUpWeapon = false;
        }
        world.addEvent('‚ö° Laser mode OFF - weapons reset', 'laser');
      } else {
        forceWeapon = 'laser';
        for (const agent of world.agents) {
          agent.weapon = 'laser';
          agent.hasPickedUpWeapon = true;
        }
        world.addEvent('‚ö° Laser mode ON - persists after death!', 'laser');
      }
      updateDebugButtonStyles();
    });

    // Toggle handlers - connect to world
    ui.toggleFf.addEventListener('click', () => {
      if (ui.toggleFf.classList.contains('disabled')) return;
      ui.toggleFf.classList.toggle('active');
      world.friendlyFire = ui.toggleFf.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFire) {
        ui.toggleRicochet.classList.add('disabled');
        ui.toggleRicochet.classList.remove('active');
        world.friendlyFireRicochet = false;
      } else {
        ui.toggleRicochet.classList.remove('disabled');
      }
    });

    ui.toggleRicochet.addEventListener('click', () => {
      if (ui.toggleRicochet.classList.contains('disabled')) return;
      ui.toggleRicochet.classList.toggle('active');
      world.friendlyFireRicochet = ui.toggleRicochet.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFireRicochet) {
        ui.toggleFf.classList.add('disabled');
        ui.toggleFf.classList.remove('active');
        world.friendlyFire = false;
      } else {
        ui.toggleFf.classList.remove('disabled');
      }
    });

    // Respawn time slider
    ui.respawnTime.addEventListener('input', (e) => {
      const seconds = parseInt(e.target.value, 10);
      world.respawnTime = seconds;
      ui.respawnTimeValue.textContent = seconds + 's';
    });

    // Health/Armor toggle handlers
    ui.toggleHealth.addEventListener('click', () => {
      ui.toggleHealth.classList.toggle('active');
      world.healthSpawnsEnabled = ui.toggleHealth.classList.contains('active');
    });

    ui.toggleArmor.addEventListener('click', () => {
      ui.toggleArmor.classList.toggle('active');
      world.armorSpawnsEnabled = ui.toggleArmor.classList.contains('active');
    });

    ui.toggleLaser.addEventListener('click', () => {
      ui.toggleLaser.classList.toggle('active');
      world.laserSpawnsEnabled = ui.toggleLaser.classList.contains('active');
    });

    ui.toggleSword.addEventListener('click', () => {
      ui.toggleSword.classList.toggle('active');
      world.swordSpawnsEnabled = ui.toggleSword.classList.contains('active');
    });

    ui.toggleDodge.addEventListener('click', () => {
      ui.toggleDodge.classList.toggle('active');
      world.dodgingEnabled = ui.toggleDodge.classList.contains('active');
    });

    ui.toggleTeleporter.addEventListener('click', () => {
      ui.toggleTeleporter.classList.toggle('active');
      world.teleportersEnabled = ui.toggleTeleporter.classList.contains('active');
    });

    // Mode info content
    const modeInfo = {
      rounds: {
        title: 'ROUNDS MODE',
        subtitle: 'Generation-based Evolution',
        description: 'Teams battle in timed rounds. After each round, the losing team evolves by learning from the winners. Watch neural networks improve over generations.',
        features: [
          { icon: '‚è±Ô∏è', text: 'Timed rounds with kill limit' },
          { icon: 'üß¨', text: 'Losers evolve after each round' },
          { icon: 'üèÜ', text: 'Track wins across generations' }
        ]
      },
      persistent: {
        title: 'PERSISTENT MODE',
        subtitle: 'Continuous Per-Life Evolution',
        description: 'No rounds - evolution happens continuously. When an agent dies, it immediately respawns with an evolved brain based on the Hall of Fame. Best performers are remembered.',
        features: [
          { icon: '‚ôæÔ∏è', text: 'Continuous gameplay - no rounds' },
          { icon: 'üíÄ', text: 'Evolve immediately on death' },
          { icon: 'üèÖ', text: 'Hall of Fame tracks best lives' }
        ]
      }
    };

    // Update pre-sim screen content
    function updatePreSimScreen() {
      const mode = persistentMode ? modeInfo.persistent : modeInfo.rounds;
      ui.preSimTitle.textContent = mode.title;
      ui.preSimSubtitle.textContent = mode.subtitle;
      ui.preSimDescription.textContent = mode.description;
      ui.preSimFeatures.innerHTML = mode.features.map(f =>
        '<div class="feature"><span class="icon">' + f.icon + '</span> ' + f.text + '</div>'
      ).join('');
    }

    // Show pre-sim screen
    function showPreSimScreen() {
      world.paused = true;
      updatePreSimScreen();
      ui.preSimScreen.classList.remove('hidden');
    }

    // Hide pre-sim screen and start
    function hidePreSimScreen() {
      ui.preSimScreen.classList.add('hidden');
      world.paused = false;
    }

    // Switch mode function
    function switchMode(toPersistent) {
      if (persistentMode === toPersistent) return;

      persistentMode = toPersistent;

      // Update button states
      ui.modeRounds.classList.toggle('active', !persistentMode);
      ui.modePersistent.classList.toggle('active', persistentMode);

      // Update header display
      ui.modeSub.textContent = persistentMode ? 'elapsed' : 'first to';
      ui.killLimitDisplay.textContent = persistentMode ? formatTime(world.totalTime) : world.killLimit;

      // Full reset when switching modes - they are separate
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      world.teamWins = [0, 0];
      forceWeapon = null;
      updateDebugButtonStyles();
      clearHallOfFame();
      world.spawnAgents(population);

      // Hide generation row in persistent mode (not relevant)
      ui.genRow.style.display = persistentMode ? 'none' : 'flex';

      if (persistentMode) {
        // Initialize life stats for all agents
        for (const agent of world.agents) {
          agent.lifeStartTime = world.totalTime;
          agent.lifeKills = 0;
          agent.lifeDamageDealt = 0;
        }
      }

      // Show pre-sim screen
      showPreSimScreen();
    }

    // Mode selector button handlers
    ui.modeRounds.addEventListener('click', () => switchMode(false));
    ui.modePersistent.addEventListener('click', () => switchMode(true));

    // Start simulation button
    ui.startSimBtn.addEventListener('click', hidePreSimScreen);

    // Show pre-sim screen on initial load
    showPreSimScreen();

    // Stats panel open/close
    function openStatsPanel() {
      ui.statsPanel.classList.add('open');
      ui.statsBtn.classList.add('active');
    }
    function closeStatsPanel() {
      ui.statsPanel.classList.remove('open');
      ui.statsBtn.classList.remove('active');
    }
    function toggleStatsPanel() {
      if (ui.statsPanel.classList.contains('open')) {
        closeStatsPanel();
      } else {
        openStatsPanel();
      }
    }
    ui.statsBtn.addEventListener('click', toggleStatsPanel);
    ui.statsClose.addEventListener('click', closeStatsPanel);

    // Click outside to close stats panel
    document.addEventListener('click', (e) => {
      if (ui.statsPanel.classList.contains('open')) {
        // Check if click is outside the panel and not on the stats button
        const clickedInPanel = ui.statsPanel.contains(e.target);
        const clickedOnStatsBtn = ui.statsBtn.contains(e.target);
        if (!clickedInPanel && !clickedOnStatsBtn) {
          closeStatsPanel();
        }
      }
    });

    // Control bar event handlers
    function updatePlayButton() {
      ui.ctrlPlay.classList.toggle('paused', world.paused);
    }

    ui.ctrlPlay.addEventListener('click', () => {
      world.paused = !world.paused;
      updatePlayButton();
      ui.pauseBtn.textContent = world.paused ? 'RESUME' : 'PAUSE';
    });

    ui.ctrlReset.addEventListener('click', () => {
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      forceWeapon = null;
      updateDebugButtonStyles();
      world.spawnAgents(population);
    });

    ui.ctrlSave.addEventListener('click', () => {
      const checkpoint = {
        version: '2.8',
        timestamp: Date.now(),
        generation: world.generation,
        teamWins: world.teamWins,
        teamBrains: world.teamBrains.map(b => b ? {
          weightsIH: b.weightsIH.map(row => Array.from(row)),
          weightsHO: b.weightsHO.map(row => Array.from(row)),
          biasH: Array.from(b.biasH),
          biasO: Array.from(b.biasO),
          inputSize: b.inputSize,
          hiddenSize: b.hiddenSize,
          outputSize: b.outputSize
        } : null)
      };
      localStorage.setItem('quake-checkpoint', JSON.stringify(checkpoint));
      world.addEvent('üíæ Checkpoint saved! Gen ' + world.generation, 'kill');
      ui.ctrlSave.classList.add('active');
      setTimeout(() => ui.ctrlSave.classList.remove('active'), 1000);
    });

    ui.ctrlLoad.addEventListener('click', () => {
      try {
        const data = localStorage.getItem('quake-checkpoint');
        if (!data) {
          world.addEvent('‚ùå No checkpoint saved!', 'kill');
          return;
        }

        const checkpoint = JSON.parse(data);
        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];

        world.teamBrains = checkpoint.teamBrains.map(data => {
          if (!data) return null;
          const nn = new NeuralNetwork(data.inputSize, data.hiddenSize, data.outputSize);
          nn.weightsIH = data.weightsIH.map(row => Float64Array.from(row));
          nn.weightsHO = data.weightsHO.map(row => Float64Array.from(row));
          nn.biasH = Float64Array.from(data.biasH);
          nn.biasO = Float64Array.from(data.biasO);
          return nn;
        });

        world.spawnAgents(population);
        world.addEvent('üìÇ Loaded! Gen ' + world.generation, 'kill');
        ui.ctrlLoad.classList.add('active');
        setTimeout(() => ui.ctrlLoad.classList.remove('active'), 1000);
      } catch (err) {
        world.addEvent('‚ùå Failed to load checkpoint', 'kill');
      }
    });

    function updateHeadlessButton() {
      ui.ctrlHeadless.classList.toggle('active', headlessMode);
    }

    ui.ctrlHeadless.addEventListener('click', () => {
      headlessMode = !headlessMode;
      ui.headlessBtn.textContent = headlessMode ? 'üñ•Ô∏è HEADLESS MODE (ON)' : 'üñ•Ô∏è HEADLESS MODE (OFF)';
      ui.headlessBtn.style.background = headlessMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(100, 100, 100, 0.1)';
      ui.headlessBtn.style.borderColor = headlessMode ? '#0f0' : '#888';
      ui.headlessBtn.style.color = headlessMode ? '#0f0' : '#888';
      ui.headlessOverlay.classList.toggle('visible', headlessMode);
      updateHeadlessButton();
    });

    function updatePerformanceButton() {
      ui.ctrlPerformance.classList.toggle('active', turboMode);
    }

    ui.ctrlPerformance.addEventListener('click', () => {
      turboMode = !turboMode;
      ui.turboBtn.textContent = turboMode ? '‚ö° TURBO MODE (ON)' : '‚ö° TURBO MODE (OFF)';
      ui.turboBtn.style.background = turboMode ? 'rgba(255, 100, 0, 0.5)' : 'rgba(255, 100, 0, 0.2)';
      ui.turboBtn.style.borderColor = turboMode ? '#ff6400' : '#ff6400';
      ui.turboBtn.style.color = turboMode ? '#fff' : '#ff6400';
      world.addEvent(turboMode ? '‚ö° PERFORMANCE MODE ON' : '‚ö° PERFORMANCE MODE OFF', 'kill');
      updatePerformanceButton();
    });

    // Initialize control bar button states
    updatePlayButton();
    updateHeadlessButton();
    updatePerformanceButton();

    // Clear Hall of Fame button
    ui.clearHofBtn.addEventListener('click', () => {
      if (confirm('Clear all Hall of Fame entries? This cannot be undone.')) {
        clearHallOfFame();
        world.addEvent('üóëÔ∏è Hall of Fame cleared!', 'kill');
      }
    });

    // Sliders
    ui.zoom.addEventListener('input', (e) => {
      renderer.zoom = parseInt(e.target.value, 10) / 100;
      renderer.clampCamera();
      ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    });

    ui.speed.addEventListener('input', (e) => {
      simSpeed = parseInt(e.target.value, 10);
      ui.speedValue.textContent = simSpeed + 'x';
    });

    ui.population.addEventListener('input', (e) => {
      population = parseInt(e.target.value, 10);
      ui.populationValue.textContent = String(population);
      world.spawnAgents(population);
    });

    ui.roundTime.addEventListener('input', (e) => {
      const minutes = parseInt(e.target.value, 10);
      world.setRoundTimeSeconds(minutes * 60);
      ui.roundTimeValue.textContent = String(minutes);
    });
    
    ui.killLimit.addEventListener('input', (e) => {
      world.killLimit = parseInt(e.target.value, 10);
      ui.killLimitValue.textContent = String(world.killLimit);
      ui.killLimitDisplay.textContent = String(world.killLimit);
    });

    // Pause/Reset
    ui.pauseBtn.addEventListener('click', (e) => {
      world.paused = !world.paused;
      e.target.textContent = world.paused ? 'RESUME' : 'PAUSE';
      updatePlayButton();
    });

    ui.restartBtn.addEventListener('click', () => {
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      forceWeapon = null; // Reset forced weapon mode
      updateDebugButtonStyles();
      world.spawnAgents(population);
    });

    // Save checkpoint to localStorage
    ui.saveBtn.addEventListener('click', () => {
      const checkpoint = {
        version: '2.8',
        timestamp: Date.now(),
        generation: world.generation,
        teamWins: world.teamWins,
        teamBrains: world.teamBrains.map(b => b ? {
          weightsIH: b.weightsIH.map(row => Array.from(row)),
          weightsHO: b.weightsHO.map(row => Array.from(row)),
          biasH: Array.from(b.biasH),
          biasO: Array.from(b.biasO),
          inputSize: b.inputSize,
          hiddenSize: b.hiddenSize,
          outputSize: b.outputSize
        } : null)
      };
      
      localStorage.setItem('quake-checkpoint', JSON.stringify(checkpoint));
      world.addEvent('üíæ Checkpoint saved! Gen ' + world.generation, 'kill');
      ui.saveBtn.textContent = 'üíæ SAVED!';
      setTimeout(() => ui.saveBtn.textContent = 'üíæ SAVE', 1000);
    });

    // Copy checkpoint to clipboard (for sharing)
    ui.copyBtn.addEventListener('click', async () => {
      const data = localStorage.getItem('quake-checkpoint');
      if (!data) {
        alert('No checkpoint saved! Click SAVE first.');
        return;
      }

      try {
        await navigator.clipboard.writeText(data);
        world.addEvent('üìã Checkpoint copied to clipboard!', 'kill');
        ui.copyBtn.textContent = 'üìã COPIED!';
        setTimeout(() => ui.copyBtn.textContent = 'üìã COPY', 1000);
      } catch (err) {
        // Fallback for iPad/iOS
        const textarea = document.createElement('textarea');
        textarea.value = data;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '50%';
        textarea.style.transform = 'translate(-50%, -50%)';
        textarea.style.width = '80%';
        textarea.style.height = '200px';
        textarea.style.zIndex = '9999';
        textarea.style.background = '#000';
        textarea.style.color = '#0f0';
        textarea.style.border = '2px solid #0f0';
        textarea.style.padding = '10px';
        textarea.style.fontSize = '12px';
        document.body.appendChild(textarea);
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        alert('Select all text (Cmd+A) and copy (Cmd+C), then tap outside to close.');
        textarea.addEventListener('blur', () => textarea.remove());
      }
    });

    // Load checkpoint from localStorage
    ui.loadBtn.addEventListener('click', () => {
      try {
        const data = localStorage.getItem('quake-checkpoint');
        if (!data) {
          alert('No checkpoint found!');
          return;
        }
        
        const checkpoint = JSON.parse(data);
        
        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];
        
        // Restore brains
        world.teamBrains = checkpoint.teamBrains.map(b => {
          if (!b) return null;
          const brain = new NeuralNetwork(b.inputSize, b.hiddenSize, b.outputSize);
          brain.weightsIH = b.weightsIH.map(row => [...row]);
          brain.weightsHO = b.weightsHO.map(row => [...row]);
          brain.biasH = [...b.biasH];
          brain.biasO = [...b.biasO];
          return brain;
        });
        
        // Respawn with loaded brains
        world.spawnAgents(population);
        
        const savedTime = new Date(checkpoint.timestamp).toLocaleTimeString();
        world.addEvent('üìÇ Loaded Gen ' + world.generation + ' (saved ' + savedTime + ')', 'kill');
        ui.loadBtn.textContent = 'üìÇ LOADED!';
        setTimeout(() => ui.loadBtn.textContent = 'üìÇ LOAD', 1000);
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    });

    // Load demo checkpoint (pre-trained AI)
    ui.demoBtn.addEventListener('click', () => {
      if (!DEMO_CHECKPOINT) {
        alert('No demo available yet! Train an AI, save it, then embed it in the code.');
        return;
      }

      try {
        const checkpoint = typeof DEMO_CHECKPOINT === 'string'
          ? JSON.parse(DEMO_CHECKPOINT)
          : DEMO_CHECKPOINT;

        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];

        // Restore brains
        world.teamBrains = checkpoint.teamBrains.map(b => {
          if (!b) return null;
          const brain = new NeuralNetwork(b.inputSize, b.hiddenSize, b.outputSize);
          brain.weightsIH = b.weightsIH.map(row => [...row]);
          brain.weightsHO = b.weightsHO.map(row => [...row]);
          brain.biasH = [...b.biasH];
          brain.biasO = [...b.biasO];
          return brain;
        });

        // Respawn with demo brains
        world.spawnAgents(population);

        world.addEvent('üéÆ DEMO LOADED! Gen ' + world.generation, 'kill');
        ui.demoBtn.textContent = 'üéÆ LOADED!';
        setTimeout(() => ui.demoBtn.textContent = 'üéÆ DEMO', 1000);
      } catch (err) {
        alert('Failed to load demo: ' + err.message);
      }
    });

    // Hotkeys: Space pause, R reset, F fullscreen
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        world.paused = !world.paused;
        ui.pauseBtn.textContent = world.paused ? 'RESUME' : 'PAUSE';
      } else if (e.code === 'KeyR') {
        world.generation = 1;
        world.events = [];
        world.teamBrains = [null, null];
        world.spawnAgents(population);
      } else if (e.code === 'KeyF') {
        ui.fullscreenBtn.click();
      }
    });

    // Resize
    window.addEventListener('resize', () => renderer.resize());

    // --------------------
    // Game loop (fixed timestep)
    // --------------------
    const FIXED_DT = 1 / 60;
    let accumulator = 0;
    let lastTime = performance.now();

    // UPS tracking
    let upsCounter = 0;
    let upsTimer = 0;
    let currentUps = 60;

    let uiTimer = 0;
    const UI_INTERVAL = 0.2; // seconds

    function drawUI(dt) {
      uiTimer += dt;
      if (uiTimer < UI_INTERVAL) return;
      uiTimer = 0;

      // Only update generation in rounds mode (hidden in persistent mode)
      if (!persistentMode) {
        ui.gen.textContent = world.generation;
      }
      ui.alive.textContent = world.agents.filter(a => a.alive).length;
      ui.time.textContent = persistentMode
        ? formatTime(world.totalTime)
        : Math.ceil(world.timeLeft) + 's';

      // Team scores (new layout)
      ui.redScore.textContent = world.teamKills[0];
      ui.blueScore.textContent = world.teamKills[1];
      ui.redWins.textContent = world.teamWins[0];
      ui.blueWins.textContent = world.teamWins[1];

      // Update stats panel
      ui.statsMode.textContent = persistentMode ? 'Persistent' : 'Rounds';
      ui.statsTotalLives.textContent = totalLivesEvaluated;
      ui.statsRocketKills.textContent = world.weaponKills.rocket + ' / ' + world.totalWeaponKills.rocket;
      ui.statsLaserKills.textContent = world.weaponKills.laser + ' / ' + world.totalWeaponKills.laser;
      ui.statsSwordKills.textContent = world.weaponKills.sword + ' / ' + world.totalWeaponKills.sword;

      // Update stats panel UPS
      ui.statsUps.textContent = currentUps;
      if (currentUps >= 55) {
        ui.statsUps.style.color = '#00ff9d';
      } else if (currentUps >= 30) {
        ui.statsUps.style.color = '#ffc800';
      } else {
        ui.statsUps.style.color = '#ff4444';
      }

      // Show/hide Hall of Fame section based on mode
      ui.hofSection.style.display = persistentMode ? 'block' : 'none';
      ui.statsTotalLivesRow.style.display = persistentMode ? 'flex' : 'none';

      // Update Overall Kill Leaderboard in stats panel (works in both modes)
      const allAgents = world.agents.slice().sort((a, b) => b.totalKills - a.totalKills).slice(0, 10);
      ui.statsLeaderboard.innerHTML = allAgents.length > 0
        ? allAgents.map((a, i) => {
            const medal = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : ''));
            const teamColor = a.team === 0 ? '#ff6666' : '#6699ff';
            return '<div class="hof-entry" style="border-left: 2px solid ' + teamColor + '"><span>' + medal + ' ' + a.name + '</span><span style="color:#00ff9d">' + a.totalKills + 'K</span></div>';
          }).join('')
        : '<div style="opacity: 0.5; font-size: 0.75rem;">No data yet</div>';

      // Update Combat Log in stats panel
      ui.statsCombatLog.innerHTML = world.events.slice(-15).reverse().map(e => {
        const typeColors = { kill: '#ff4444', death: '#888', spawn: '#00ff9d', damage: '#ffc800', sword: '#ff00ff', laser: '#00aaff', pickup: '#00ff9d', teleporter: '#aa00ff' };
        const color = typeColors[e.type] || '#888';
        return '<div style="color: ' + color + '; padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.05);">' + e.text + '</div>';
      }).join('');

      // Update Hall of Fame in stats panel (only shown in persistent mode)
      ui.statsRedHof.innerHTML = hallOfFame[0].length > 0
        ? hallOfFame[0].slice(0, 5).map((e, i) => {
            const medal = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : ''));
            return '<div class="hof-entry"><span>' + medal + ' ' + e.kills + 'K</span><span style="color:#00ff9d">' + e.score + '</span></div>';
          }).join('')
        : '<div style="opacity: 0.5; font-size: 0.75rem;">No entries yet</div>';

      ui.statsBlueHof.innerHTML = hallOfFame[1].length > 0
        ? hallOfFame[1].slice(0, 5).map((e, i) => {
            const medal = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : ''));
            return '<div class="hof-entry"><span>' + medal + ' ' + e.kills + 'K</span><span style="color:#00ff9d">' + e.score + '</span></div>';
          }).join('')
        : '<div style="opacity: 0.5; font-size: 0.75rem;">No entries yet</div>';

      // Update header display in persistent mode
      if (persistentMode) {
        ui.killLimitDisplay.textContent = formatTime(world.totalTime);
      }

      // Leaderboard - different in persistent mode
      if (persistentMode) {
        // Show Hall of Fame entries (combined from both teams, sorted by score)
        const combinedHoF = [
          ...hallOfFame[0].slice(0, 5).map(e => ({ ...e, team: 0 })),
          ...hallOfFame[1].slice(0, 5).map(e => ({ ...e, team: 1 }))
        ].sort((a, b) => b.score - a.score).slice(0, 10);

        ui.leaderboard.innerHTML = combinedHoF.length > 0
          ? combinedHoF.map((e, i) => {
              const timeAgo = Math.floor((Date.now() - e.timestamp) / 1000);
              const timeStr = timeAgo < 60 ? timeAgo + 's' : Math.floor(timeAgo / 60) + 'm';
              return '<div class="leader-entry" style="border-left: 2px solid ' + (e.team === 0 ? '#ff4444' : '#4488ff') + '">' +
                '<span class="name" style="color: ' + (e.team === 0 ? '#ff8888' : '#88aaff') + '">' + e.kills + 'K ' + timeStr + ' ago</span>' +
                '<span class="score">' + e.score + '</span>' +
              '</div>';
            }).join('')
          : '<div class="stat-row" style="opacity: 0.5;">No entries yet - start dying!</div>';

        // Legends moved to stats panel
      } else {
        // Normal round leaderboard
        ui.leaderboard.innerHTML = world.getLeaderboard().map((a, i) => {
          const status = a.alive ? '' : (a.respawnTimer > 0 ? ' (' + Math.ceil(a.respawnTimer) + 's)' : '');
          const kd = a.kills + '/' + a.deaths;
          return '<div class="leader-entry ' + (a.alive ? '' : 'dead') + '" style="border-left: 2px solid ' + (a.team === 0 ? '#ff4444' : '#4488ff') + '">' +
            '<span class="name" style="color: ' + (a.team === 0 ? '#ff8888' : '#88aaff') + '">' + a.name + status + '</span>' +
            '<span class="score">' + a.score + '</span>' +
          '</div>';
        }).join('');

        // Legends moved to stats panel
      }

      // Combat log moved to stats panel

      // Update agent profile card
      updateAgentProfile();
    }

    function updateAgentProfile() {
      const agent = renderer.followAgent;

      if (!agent) {
        ui.agentProfile.style.display = 'none';
        return;
      }

      ui.agentProfile.style.display = 'block';

      // Header - show dead status and respawn timer
      ui.profileName.textContent = agent.name;
      if (!agent.alive) {
        ui.profileName.style.color = '#666';
        const respawnSec = Math.ceil(agent.respawnTimer);
        ui.profileTeam.textContent = 'DEAD - Respawn in ' + respawnSec + 's';
        ui.profileTeam.style.color = '#888';
      } else {
        ui.profileName.style.color = agent.team === 0 ? '#ff6666' : '#6699ff';
        ui.profileTeam.textContent = agent.team === 0 ? 'RED TEAM' : 'BLUE TEAM';
        ui.profileTeam.style.color = agent.team === 0 ? '#ff4444' : '#4488ff';
      }

      // Health and armor bars
      const healthPct = agent.alive ? Math.max(0, agent.health / agent.maxHealth * 100) : 0;
      const armorPct = agent.alive ? Math.max(0, agent.armor / agent.maxArmor * 100) : 0;
      ui.profileHealthBar.style.width = healthPct + '%';
      ui.profileHealthVal.textContent = agent.alive ? Math.ceil(agent.health) : '0';
      ui.profileArmorBar.style.width = armorPct + '%';
      ui.profileArmorVal.textContent = agent.alive ? Math.ceil(agent.armor) : '0';

      // Weapon
      const weaponDisplay = {
        'rocket': 'üöÄ Rocket',
        'laser': '‚ö° Laser',
        'sword': 'üó°Ô∏è Sword'
      };
      ui.profileWeapon.textContent = weaponDisplay[agent.weapon] || agent.weapon;

      // K/D
      ui.profileKd.textContent = agent.kills + '/' + agent.deaths;

      // Neural activity (from last decision)
      if (agent.lastDecision) {
        const d = agent.lastDecision;

        // Turn: -1 to 1, show as bar from center
        const turnVal = Math.abs(d.turnAmount) * 50;
        ui.neuralTurn.style.setProperty('--bar-height', turnVal + '%');
        ui.neuralTurn.className = 'indicator-bar ' + (d.turnAmount >= 0 ? 'positive' : 'negative');

        // Speed: 0 to 1
        ui.neuralSpeed.style.setProperty('--bar-height', d.speedAmount * 50 + '%');
        ui.neuralSpeed.className = 'indicator-bar positive';

        // Strafe: -1 to 1
        const strafeVal = Math.abs(d.strafe) * 50;
        ui.neuralStrafe.style.setProperty('--bar-height', strafeVal + '%');
        ui.neuralStrafe.className = 'indicator-bar ' + (d.strafe >= 0 ? 'positive' : 'negative');

        // Fire and Dash: boolean
        ui.neuralShoot.className = 'indicator-light' + (d.wantsShoot ? ' active' : '');
        ui.neuralDash.className = 'indicator-light' + (d.wantsDash ? ' active' : '');
      }

      // Awareness
      if (agent.lastAwareness) {
        const a = agent.lastAwareness;
        if (a.enemyDist < 1) {
          const dist = Math.round(a.enemyDist * 1000);
          const dir = a.enemyAngle > 0 ? 'R' : 'L';
          ui.awarenessEnemy.textContent = dist + 'm ' + dir;
        } else {
          ui.awarenessEnemy.textContent = 'None';
        }
        if (a.allyDist < 1) {
          const dist = Math.round(a.allyDist * 500);
          const dir = a.allyAngle > 0 ? 'R' : 'L';
          ui.awarenessAlly.textContent = dist + 'm ' + dir;
        } else {
          ui.awarenessAlly.textContent = 'None';
        }
      }
    }

    function gameLoop(curr) {
      const realDt = Math.min((curr - lastTime) / 1000, 0.1);
      lastTime = curr;

      // UPS tracking
      upsTimer += realDt;
      if (upsTimer >= 1.0) {
        currentUps = upsCounter;
        upsCounter = 0;
        upsTimer = 0;
      }

      // scale by simSpeed into the simulation accumulator
      accumulator += realDt * simSpeed;

      // prevent spiral of death - but allow more steps in headless mode
      const maxSteps = headlessMode ? 100 : 12;
      let steps = 0;
      while (accumulator >= FIXED_DT && steps < maxSteps) {
        world.update(FIXED_DT);
        accumulator -= FIXED_DT;
        steps++;
        upsCounter++;
      }
      // if we hit max steps, drop the rest to keep UI responsive
      if (steps === maxSteps) accumulator = 0;

      // Only render if not headless
      if (!headlessMode) {
        renderer.updateFollow();
        renderer.render();
      }
      drawUI(realDt);

      requestAnimationFrame(gameLoop);
    }

    // Initialize UI values
    ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    ui.speedValue.textContent = simSpeed + 'x';
    ui.populationValue.textContent = String(population);
    ui.roundTimeValue.textContent = String(parseInt(ui.roundTime.value, 10));
    ui.killLimitValue.textContent = String(world.killLimit);

    // ========== MODULAR DRAGGABLE PANELS ==========
    (function initDraggablePanels() {
      const STORAGE_KEY = 'panelOrder';

      // Get saved panel order from localStorage
      function getSavedOrder() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          return saved ? JSON.parse(saved) : null;
        } catch { return null; }
      }

      // Save panel order to localStorage
      function saveOrder() {
        const order = {
          left: Array.from(document.querySelectorAll('#left-sidebar .panel[data-panel-id]'))
            .map(p => p.dataset.panelId),
          right: Array.from(document.querySelectorAll('#right-sidebar .panel[data-panel-id]'))
            .map(p => p.dataset.panelId)
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(order));
      }

      // Restore saved panel order
      function restoreOrder() {
        const order = getSavedOrder();
        if (!order) return;

        ['left', 'right'].forEach(side => {
          const sidebar = document.getElementById(side + '-sidebar');
          if (!sidebar || !order[side]) return;

          const panels = {};
          sidebar.querySelectorAll('.panel[data-panel-id]').forEach(p => {
            panels[p.dataset.panelId] = p;
          });

          order[side].forEach(id => {
            if (panels[id]) sidebar.appendChild(panels[id]);
          });
        });
      }

      // Drag state
      let draggedPanel = null;
      let draggedRect = null;
      let placeholder = null;
      let startY = 0;
      let offsetY = 0;
      let currentSidebar = null;

      // Get all panels in a sidebar, sorted by visual position
      function getPanelsInOrder(sidebar) {
        return Array.from(sidebar.querySelectorAll('.panel[data-panel-id]'))
          .filter(p => p !== draggedPanel && !p.classList.contains('placeholder'));
      }

      // Calculate where the dragged panel should be inserted
      function getInsertIndex(sidebar, y) {
        const panels = getPanelsInOrder(sidebar);
        for (let i = 0; i < panels.length; i++) {
          const rect = panels[i].getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          if (y < midY) return i;
        }
        return panels.length;
      }

      // Handle drag start (mouse/touch)
      function startDrag(e, panel) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;

        e.preventDefault();

        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        draggedPanel = panel;
        currentSidebar = panel.parentElement;
        draggedRect = panel.getBoundingClientRect();
        startY = clientY;
        offsetY = clientY - draggedRect.top;

        // Create placeholder
        placeholder = document.createElement('div');
        placeholder.className = 'panel placeholder';
        placeholder.style.height = draggedRect.height + 'px';
        placeholder.style.marginBottom = getComputedStyle(panel).marginBottom;
        panel.parentElement.insertBefore(placeholder, panel);

        // Style dragged panel
        panel.classList.add('dragging');
        panel.style.position = 'fixed';
        panel.style.width = draggedRect.width + 'px';
        panel.style.left = draggedRect.left + 'px';
        panel.style.top = draggedRect.top + 'px';
        panel.style.margin = '0';

        document.body.style.cursor = 'grabbing';
      }

      // Handle drag move
      function moveDrag(e) {
        if (!draggedPanel) return;

        e.preventDefault();

        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const newTop = clientY - offsetY;

        draggedPanel.style.top = newTop + 'px';

        // Find which sidebar we're over
        const sidebars = [
          document.getElementById('left-sidebar'),
          document.getElementById('right-sidebar')
        ];

        let targetSidebar = currentSidebar;
        for (const sidebar of sidebars) {
          const rect = sidebar.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          if (clientX >= rect.left && clientX <= rect.right) {
            targetSidebar = sidebar;
            break;
          }
        }

        // Move placeholder to new position
        if (targetSidebar) {
          const insertIdx = getInsertIndex(targetSidebar, clientY);
          const panels = getPanelsInOrder(targetSidebar);

          // Remove placeholder from current position
          if (placeholder.parentElement) {
            placeholder.parentElement.removeChild(placeholder);
          }

          // Insert at new position
          if (insertIdx >= panels.length) {
            targetSidebar.appendChild(placeholder);
          } else {
            targetSidebar.insertBefore(placeholder, panels[insertIdx]);
          }

          currentSidebar = targetSidebar;
        }
      }

      // Handle drag end
      function endDrag() {
        if (!draggedPanel) return;

        // Animate panel to placeholder position
        const placeholderRect = placeholder.getBoundingClientRect();

        draggedPanel.style.transition = 'top 0.2s ease, left 0.2s ease';
        draggedPanel.style.top = placeholderRect.top + 'px';
        draggedPanel.style.left = placeholderRect.left + 'px';

        setTimeout(() => {
          // Reset panel styles
          draggedPanel.classList.remove('dragging');
          draggedPanel.style.position = '';
          draggedPanel.style.width = '';
          draggedPanel.style.left = '';
          draggedPanel.style.top = '';
          draggedPanel.style.margin = '';
          draggedPanel.style.transition = '';

          // Insert panel where placeholder was
          placeholder.parentElement.insertBefore(draggedPanel, placeholder);
          placeholder.remove();

          // Save new order
          saveOrder();

          draggedPanel = null;
          placeholder = null;
          currentSidebar = null;
        }, 200);

        document.body.style.cursor = '';
      }

      // Attach event listeners to all panels
      document.querySelectorAll('.panel[data-panel-id] h2').forEach(header => {
        const panel = header.parentElement;

        // Mouse events
        header.addEventListener('mousedown', e => startDrag(e, panel));

        // Touch events
        header.addEventListener('touchstart', e => startDrag(e, panel), { passive: false });
      });

      // Global move/end handlers
      document.addEventListener('mousemove', moveDrag);
      document.addEventListener('mouseup', endDrag);
      document.addEventListener('touchmove', moveDrag, { passive: false });
      document.addEventListener('touchend', endDrag);

      // Restore saved order on load
      restoreOrder();
    })();

    requestAnimationFrame(gameLoop);
  })();
  </script>

</body>
</html>
