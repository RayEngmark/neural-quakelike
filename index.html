<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NEURAL QUAKE ARENA // V3.0</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #050510;
      --panel-bg: rgba(13, 13, 25, 0.95);
      --neon-blue: #00f3ff;
      --neon-pink: #ff0055;
      --neon-green: #00ff9d;
      --neon-yellow: #ffd700;
      --laser-blue: #00aaff;
      --text-main: #e0e6ed;
      --border-color: rgba(255, 255, 255, 0.1);
    }

```
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: var(--bg-dark);
  color: var(--text-main);
  font-family: 'Rajdhani', sans-serif;
  overflow: hidden;
  height: 100vh;
}

/* === NEW LAYOUT: Top bar + Game + Right sidebar === */
#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* TOP BAR - Scores */
#top-bar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
  padding: 8px 15px;
  background: var(--panel-bg);
  border-bottom: 2px solid var(--border-color);
  flex-shrink: 0;
}

.team-block {
  display: flex;
  align-items: center;
  gap: 15px;
}
.team-block.red { flex-direction: row; }
.team-block.blue { flex-direction: row; }

.team-score {
  text-align: center;
}
.team-score .score {
  font-family: 'JetBrains Mono', monospace;
  font-size: 2.5rem;
  font-weight: bold;
  text-shadow: 0 0 20px currentColor;
  line-height: 1;
}
.team-score .label {
  font-size: 0.7rem;
  opacity: 0.7;
  text-transform: uppercase;
}
.team-block.red .team-score { color: #ff4444; }
.team-block.blue .team-score { color: #4488ff; }

.team-wins {
  text-align: center;
  padding: 5px 12px;
  background: rgba(255,255,255,0.05);
  border-radius: 4px;
}
.team-wins .wins {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.4rem;
  font-weight: bold;
}
.team-wins .label {
  font-size: 0.6rem;
  opacity: 0.5;
  text-transform: uppercase;
}
.team-block.red .team-wins { color: #ff6666; }
.team-block.blue .team-wins { color: #6699ff; }

#center-info {
  text-align: center;
  padding: 0 30px;
  border-left: 1px solid var(--border-color);
  border-right: 1px solid var(--border-color);
}
#center-info .big {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.8rem;
  color: var(--neon-green);
  font-weight: bold;
}
#center-info .sub {
  font-size: 0.65rem;
  color: #666;
  text-transform: uppercase;
}

/* MAIN AREA - Canvas + Sidebars */
#main-area {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* LEFT SIDEBAR - Stats & Controls */
#left-sidebar {
  width: 250px;
  background: var(--panel-bg);
  border-right: 1px solid var(--border-color);
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  overflow-y: auto;
  flex-shrink: 0;
}

/* CANVAS */
#canvas-container {
  flex: 1;
  position: relative;
  background: radial-gradient(circle at center, #1a1a2e 0%, #050510 100%);
  overflow: hidden;
  margin: 5px 0;
}
canvas { display: block; width: 100%; height: 100%; }

/* RIGHT SIDEBAR - Game Modifiers */
#right-sidebar {
  width: 200px;
  background: var(--panel-bg);
  border-left: 1px solid var(--border-color);
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  overflow-y: auto;
  flex-shrink: 0;
}

/* PANELS */
.panel {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 10px;
  position: relative;
}
.panel::before {
  content: '';
  position: absolute;
  top: -1px; left: -1px;
  width: 8px; height: 8px;
  border-top: 2px solid var(--neon-blue);
  border-left: 2px solid var(--neon-blue);
}
.panel::after {
  content: '';
  position: absolute;
  bottom: -1px; right: -1px;
  width: 8px; height: 8px;
  border-bottom: 2px solid var(--neon-blue);
  border-right: 2px solid var(--neon-blue);
}
.panel h2 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  color: #667;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 8px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  font-size: 0.85rem;
  border-bottom: 1px dashed rgba(255,255,255,0.05);
}
.stat-value {
  font-family: 'JetBrains Mono', monospace;
  color: var(--neon-green);
  font-weight: bold;
}

/* TOGGLES */
.toggle-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 0;
}
.toggle-row label {
  font-size: 0.8rem;
  color: #adb5bd;
}
.toggle {
  width: 38px;
  height: 20px;
  background: rgba(255,255,255,0.15);
  border-radius: 10px;
  cursor: pointer;
  position: relative;
  transition: background 0.3s;
}
.toggle::after {
  content: '';
  position: absolute;
  top: 2px; left: 2px;
  width: 16px; height: 16px;
  background: #888;
  border-radius: 50%;
  transition: all 0.3s;
}
.toggle.active { background: var(--neon-green); }
.toggle.active::after { 
  transform: translateX(18px); 
  background: #fff;
}
.toggle.disabled { opacity: 0.3; cursor: not-allowed; }

/* SLIDERS */
.control-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
}
.control-row label {
  width: 40px;
  flex-shrink: 0;
  font-size: 0.75rem;
  color: #adb5bd;
}
input[type="range"] {
  -webkit-appearance: none;
  flex: 1;
  min-width: 60px;
  height: 4px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 14px;
  width: 14px;
  border-radius: 50%;
  background: var(--neon-blue);
  cursor: pointer;
  box-shadow: 0 0 8px var(--neon-blue);
}
.control-row .value {
  min-width: 35px;
  width: 35px;
  flex-shrink: 0;
  text-align: right;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem;
  color: var(--neon-blue);
}

/* BUTTONS */
button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: rgba(0, 243, 255, 0.1);
  border: 1px solid var(--neon-blue);
  color: var(--neon-blue);
  padding: 10px 16px;
  border-radius: 2px;
  cursor: pointer;
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
  font-size: 0.8rem;
  text-transform: uppercase;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}
button:hover {
  background: var(--neon-blue);
  color: #000;
  box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
}
button.secondary {
  border-color: #666;
  color: #aaa;
  background: transparent;
}
button.secondary:hover {
  border-color: #fff;
  color: #fff;
  background: rgba(255,255,255,0.1);
  box-shadow: none;
}
.btn-row {
  display: flex;
  gap: 10px;
}
.btn-row button { flex: 1; }

/* SCROLLBARS */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb {
  background: var(--neon-blue);
  border-radius: 4px;
  border: 2px solid transparent;
  background-clip: padding-box;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--neon-green);
  border: 2px solid transparent;
  background-clip: padding-box;
}

/* LEADERBOARD */
#leaderboard, #alltime-leaderboard {
  max-height: 140px;
  overflow-y: auto;
}
.leader-entry {
  display: flex;
  justify-content: space-between;
  padding: 4px 6px;
  font-size: 0.75rem;
  margin-bottom: 2px;
  background: rgba(255,255,255,0.02);
  border-radius: 2px;
}
.leader-entry .name {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.leader-entry .score {
  font-family: 'JetBrains Mono', monospace;
  font-weight: bold;
}
.leader-entry.dead { opacity: 0.3; }

/* EVENT LOG */
#event-log {
  max-height: 100px;
  overflow-y: auto;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
}
.event { padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.03); }
.event .kill { color: var(--neon-pink); }
.event .damage { color: var(--neon-yellow); }
.event .pickup { color: var(--neon-green); }
.event .laser { color: var(--laser-blue); }

#load-file { display: none; }

/* HEADLESS OVERLAY */
#headless-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(5, 5, 16, 0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}
#headless-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}
#headless-overlay .icon {
  font-size: 4rem;
  margin-bottom: 20px;
}
#headless-overlay h2 {
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.5rem;
  color: var(--neon-green);
  text-transform: uppercase;
  letter-spacing: 3px;
  margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
}
#headless-overlay p {
  color: #888;
  font-size: 0.9rem;
  margin-bottom: 25px;
}
#headless-overlay .hint {
  background: rgba(0, 255, 157, 0.1);
  border: 1px solid rgba(0, 255, 157, 0.3);
  border-radius: 6px;
  padding: 15px 25px;
  color: #aaa;
  font-size: 0.85rem;
}
#headless-overlay .hint strong {
  color: var(--neon-green);
}
```

  </style>
</head>
<body>
  <div id="app">
    <!-- TOP BAR: Scores & Match Info -->
    <div id="top-bar">
      <div class="team-block red">
        <div class="team-wins">
          <div class="wins" id="red-wins">0</div>
          <div class="label">wins</div>
        </div>
        <div class="team-score">
          <div class="score" id="red-score">0</div>
          <div class="label">üî¥ RED</div>
        </div>
      </div>

```
  <div id="center-info">
    <div class="big" id="kill-limit-display">50</div>
    <div class="sub">first to</div>
  </div>

  <div class="team-block blue">
    <div class="team-score">
      <div class="score" id="blue-score">0</div>
      <div class="label">BLUE üîµ</div>
    </div>
    <div class="team-wins">
      <div class="wins" id="blue-wins">0</div>
      <div class="label">wins</div>
    </div>
  </div>
</div>

<!-- MAIN AREA -->
<div id="main-area">
  <!-- LEFT SIDEBAR: Stats & Controls -->
  <div id="left-sidebar">
    <div class="panel">
      <h2>// Status</h2>
      <div class="stat-row">
        <span>Generation</span>
        <span class="stat-value" id="generation">1</span>
      </div>
      <div class="stat-row">
        <span>Alive</span>
        <span class="stat-value" id="alive">100</span>
      </div>
      <div class="stat-row">
        <span>Time</span>
        <span class="stat-value" id="time-left">60s</span>
      </div>
      <div class="stat-row">
        <span>UPS</span>
        <span class="stat-value" id="ups">60</span>
      </div>
    </div>

    <div class="panel">
      <h2>// Parameters</h2>
      <div class="control-row">
        <label>Zoom</label>
        <input type="range" id="zoom" min="25" max="300" value="100" />
        <span class="value" id="zoom-value">1.0x</span>
      </div>
      <div class="control-row">
        <label>Speed</label>
        <input type="range" id="speed" min="1" max="20" value="1" />
        <span class="value" id="speed-value">1x</span>
      </div>
      <div class="control-row">
        <label>Pop</label>
        <input type="range" id="population" min="20" max="200" value="100" step="10" />
        <span class="value" id="population-value">100</span>
      </div>
      <div class="control-row">
        <label>Time</label>
        <input type="range" id="round-time" min="1" max="10" value="1" step="1" />
        <span class="value" id="round-time-value">1m</span>
      </div>
      <div class="control-row">
        <label>Kills</label>
        <input type="range" id="kill-limit" min="10" max="100" value="50" step="5" />
        <span class="value" id="kill-limit-value">50</span>
      </div>
      <div class="control-row">
        <label>Respawn</label>
        <input type="range" id="respawn-time" min="1" max="10" value="3" step="1" />
        <span class="value" id="respawn-time-value">3s</span>
      </div>
    </div>

    <div class="panel">
      <h2>// Controls</h2>
      <div class="btn-row">
        <button id="pause-btn">PAUSE</button>
        <button id="restart-btn" class="secondary">RESET</button>
      </div>
      <div class="btn-row" style="margin-top:10px;">
        <button id="save-btn" style="background: rgba(0, 200, 255, 0.1); border-color: #00c8ff; color: #00c8ff;">üíæ SAVE</button>
        <button id="load-btn" style="background: rgba(200, 0, 255, 0.1); border-color: #c800ff; color: #c800ff;">üìÇ LOAD</button>
      </div>
      <div class="btn-row" style="margin-top:10px;">
        <button id="headless-btn" style="background: rgba(0, 255, 0, 0.3); border-color: #0f0; color: #0f0; width: 100%;">üñ•Ô∏è HEADLESS MODE (ON)</button>
      </div>
      <input type="file" id="load-file" accept=".json" />
    </div>

    <div class="panel">
      <h2>// Legends üèÜ</h2>
      <div id="alltime-leaderboard"></div>
    </div>

    <div class="panel">
      <h2>// Leaderboard</h2>
      <div id="leaderboard"></div>
    </div>

    <div class="panel">
      <h2>// Combat Log</h2>
      <div id="event-log"></div>
    </div>
  </div>

  <!-- CANVAS -->
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="headless-overlay">
      <div class="icon">üñ•Ô∏è</div>
      <h2>Simulation Running in Headless Mode</h2>
      <p>Rendering is disabled for faster simulation speed.</p>
      <div class="hint">Toggle <strong>üñ•Ô∏è HEADLESS</strong> in Controls to view the battle.</div>
    </div>
  </div>

  <!-- RIGHT SIDEBAR: Game Modifiers -->
  <div id="right-sidebar">
    <div class="panel">
      <h2>// Game Modifiers</h2>
      <div class="toggle-row" title="Spawns health packs every 10s. Instant 50HP + 50HP regen over 5s.">
        <label>ü©π Health Spawns</label>
        <div class="toggle active" id="toggle-health"></div>
      </div>
      <div class="toggle-row" title="Spawns armor pickups every 10s. +50 armor per pickup, max 100.">
        <label>üõ°Ô∏è Armor Spawns</label>
        <div class="toggle active" id="toggle-armor"></div>
      </div>
      <div class="toggle-row" title="Laser weapons spawn at map center when half kills/time reached. 3s charge, instant kill beam.">
        <label>‚ö° Laser Drops</label>
        <div class="toggle active" id="toggle-laser"></div>
      </div>
      <div class="toggle-row" title="Energy swords spawn at map center. Hold to charge, release to lunge. Instant kill.">
        <label>üó°Ô∏è Sword Drops</label>
        <div class="toggle active" id="toggle-sword"></div>
      </div>
      <div class="toggle-row" style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;" title="Rockets damage teammates directly.">
        <label>üí• Friendly Fire</label>
        <div class="toggle" id="toggle-ff"></div>
      </div>
      <div class="toggle-row" title="Teammate damage reflects back to shooter.">
        <label>üîÑ FF Ricochet</label>
        <div class="toggle" id="toggle-ricochet"></div>
      </div>
    </div>

    <div class="panel">
      <h2>// Field Items</h2>
      <div id="field-items-list">
        <div class="stat-row" style="opacity: 0.5; font-size: 0.75rem;">No active spawns</div>
      </div>
    </div>

    <div class="panel">
      <h2>// Weapons</h2>
      <div class="stat-row" title="4s cooldown, 90 damage, 120 radius splash">
        <span>üöÄ Rocket</span>
        <span class="stat-value">90 dmg</span>
      </div>
      <div class="stat-row" title="3s charge time, infinite range beam, instant kill">
        <span style="color: var(--neon-blue);">‚ö° Laser</span>
        <span class="stat-value" style="color: var(--neon-blue);">‚àû dmg</span>
      </div>
      <div class="stat-row" title="Hold to charge (0.3-2s), release to lunge. Team colored.">
        <span style="color: #ff00ff;">üó°Ô∏è Sword</span>
        <span class="stat-value" style="color: #ff00ff;">‚àû dmg</span>
      </div>
    </div>
  </div>
</div>
```

  </div>

  <script>
  (() => {
    'use strict';

    // --------------------
    // Utility
    // --------------------
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    // --------------------
    // Names
    // --------------------
    const FIRST_NAMES = ['Ole', 'Lars', 'Erik', 'Anders', 'Magnus', 'Henrik', 'Jonas', 'Marius', 'Kristian', 'Thomas', 'Astrid', 'Ingrid', 'Solveig', 'Freya', 'Sigrid', 'Nora', 'Emma', 'Maja', 'Thea', 'Ella', 'Bj√∏rn', 'Torstein', 'Gunnar', 'H√•kon', 'Leif', 'Ragnar', 'Sven', 'Olav', 'Knut', 'Arne', 'Liv', 'Grete', 'Kari', 'Anne', 'James', 'John', 'William', 'David', 'Richard', 'Mary', 'Patricia', 'Jennifer', 'Linda', 'Elizabeth', 'Michael', 'Christopher', 'Joshua', 'Andrew', 'Brandon', 'Emily', 'Hannah', 'Madison', 'Ashley', 'Olivia', 'Jack', 'Harry', 'Oliver', 'George', 'Charlie', 'Grace', 'Chloe', 'Lily', 'Mia', 'Ruby', 'Viktor', 'Felix', 'Oscar', 'Sebastian', 'Adrian', 'Aurora', 'Emilie', 'Hedda', 'Sara', 'Julie'];
    const LAST_NAMES = ['Hansen', 'Johansen', 'Olsen', 'Larsen', 'Andersen', 'Pedersen', 'Nilsen', 'Kristiansen', 'Jensen', 'Karlsen', 'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Miller', 'Davis', 'Garcia', 'Rodriguez', 'Wilson', 'Martinez', 'Anderson', 'Taylor', 'Thomas', 'Moore', 'Martin', 'Jackson', 'Thompson', 'White', 'Lopez'];

    // --------------------
    // Neural net
    // --------------------
    class NeuralNetwork {
      constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize, hiddenSize);
        this.biasH = new Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
        this.biasO = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
      }
      randomMatrix(rows, cols, fanIn) {
        const scale = Math.sqrt(2 / fanIn);
        const m = new Array(rows);
        for (let r = 0; r < rows; r++) {
          const row = new Array(cols);
          for (let c = 0; c < cols; c++) row[c] = (Math.random() - 0.5) * 2 * scale;
          m[r] = row;
        }
        return m;
      }
      activate(x) { return Math.tanh(x); }
      forward(inputs) {
        // Safe pad/truncate so we always use the full weight matrix.
        const x = (inputs.length === this.inputSize)
          ? inputs
          : inputs.length > this.inputSize
            ? inputs.slice(0, this.inputSize)
            : inputs.concat(new Array(this.inputSize - inputs.length).fill(0));

        const hidden = new Array(this.hiddenSize);
        for (let i = 0; i < this.hiddenSize; i++) {
          let sum = this.biasH[i];
          const w = this.weightsIH[i];
          for (let j = 0; j < this.inputSize; j++) sum += w[j] * x[j];
          hidden[i] = this.activate(sum);
        }

        const out = new Array(this.outputSize);
        for (let i = 0; i < this.outputSize; i++) {
          let sum = this.biasO[i];
          const w = this.weightsHO[i];
          for (let j = 0; j < this.hiddenSize; j++) sum += w[j] * hidden[j];
          out[i] = this.activate(sum);
        }
        return out;
      }
      clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(row => row.slice());
        nn.weightsHO = this.weightsHO.map(row => row.slice());
        nn.biasH = this.biasH.slice();
        nn.biasO = this.biasO.slice();
        return nn;
      }
      mutate(rate = 0.1, strength = 0.3) {
        const mutateVal = (v) => (Math.random() < rate ? v + (Math.random() - 0.5) * 2 * strength : v);
        const mutateArr = (arr) => { for (let i = 0; i < arr.length; i++) arr[i] = mutateVal(arr[i]); };
        const mutateMat = (mat) => { for (let r = 0; r < mat.length; r++) mutateArr(mat[r]); };
        mutateMat(this.weightsIH);
        mutateMat(this.weightsHO);
        mutateArr(this.biasH);
        mutateArr(this.biasO);
      }
    }

    // --------------------
    // Pickups
    // --------------------
    class BowPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class KnifePickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }
    class SniperPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class ShotgunPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 18; this.pickedUp = false; } }
    class BazookaPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 22; this.pickedUp = false; this.spawnTime = Date.now(); } }
    class HealingPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; this.healAmount = 50; } }
    class ArmorPickup { constructor(x, y) { this.x = x; this.y = y; this.radius = 14; this.pickedUp = false; } }

    // --------------------
    // Projectiles
    // --------------------
    class Arrow {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 350; this.damage = 50; this.maxRange = 1200;
        this.distanceTraveled = 0; this.alive = true; this.radius = 5;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class Bullet {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 800; this.damage = 100; this.maxRange = 2000;
        this.distanceTraveled = 0; this.alive = true; this.radius = 3;
      }
      update(dt, agents, obstacles) {
        if (!this.alive) return null;
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        this.x += moveX; this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        if (this.distanceTraveled >= this.maxRange) { this.alive = false; return null; }
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false; return null;
          }
        }
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) { this.alive = false; return agent; }
        }
        return null;
      }
    }

    class ShotgunBlast {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.nearRange = 80; this.farRange = 150; this.spreadAngle = Math.PI / 4;
        this.maxTime = 0.2; this.timer = 0; this.active = true;
        this.hasDealtNearDamage = false; this.hasDealtFarDamage = false;
        this.currentRadius = 0; this.speed = 800;
      }
      update(dt, agents, world) {
        if (!this.active) return;
        this.timer += dt;
        this.currentRadius = this.timer * this.speed;
        if (!this.hasDealtNearDamage && this.currentRadius >= this.nearRange) {
          this.hasDealtNearDamage = true;
          this.dealDamageInRange(agents, world, 0, this.nearRange, 100);
        }
        if (!this.hasDealtFarDamage && this.currentRadius >= this.farRange) {
          this.hasDealtFarDamage = true;
          this.dealDamageInRange(agents, world, this.nearRange, this.farRange, 50);
        }
        if (this.timer >= this.maxTime) this.active = false;
      }
      dealDamageInRange(agents, world, minDist, maxDist, damage) {
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = agent.x - this.x, dy = agent.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist || dist > maxDist) continue;

          let angleToAgent = Math.atan2(dy, dx);
          let angleDiff = angleToAgent - this.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          if (Math.abs(angleDiff) > this.spreadAngle) continue;

          const killed = agent.takeDamage(damage, this.owner, world);
          this.owner.damageDealt += damage;
          world.addEvent(this.owner.name + ' blasted ' + agent.name, 'damage');
          if (killed) {
            this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
            world.teamKills[this.owner.team]++;
            this.owner.killScore += 50;
            world.addEvent(this.owner.name + ' killed ' + agent.name + '!', 'kill');
          }
        }
      }
    }

    class Rocket {
      constructor(x, y, angle, owner) {
        this.x = x; this.y = y; this.angle = angle; this.owner = owner;
        this.speed = 280; // Slower than arrows (350)
        this.maxRange = 1500;
        this.distanceTraveled = 0;
        this.alive = true;
        this.radius = 8;
        this.explosionRadius = 120;
        this.damage = 200; // Instakill in center
        // Trail particles
        this.trail = [];
        this.trailTimer = 0;
      }
      update(dt, agents, obstacles, world) {
        if (!this.alive) return null;
        
        // Wobbly flight path for visual fun
        const wobble = Math.sin(this.distanceTraveled * 0.05) * 0.02;
        const moveAngle = this.angle + wobble;
        
        const moveX = Math.cos(moveAngle) * this.speed * dt;
        const moveY = Math.sin(moveAngle) * this.speed * dt;
        this.x += moveX;
        this.y += moveY;
        this.distanceTraveled += Math.hypot(moveX, moveY);
        
        // Add smoke trail particles
        this.trailTimer += dt;
        if (this.trailTimer > 0.02) {
          this.trailTimer = 0;
          this.trail.push({
            x: this.x - Math.cos(this.angle) * 15,
            y: this.y - Math.sin(this.angle) * 15,
            life: 1,
            size: 8 + Math.random() * 6,
            vx: (Math.random() - 0.5) * 30,
            vy: (Math.random() - 0.5) * 30
          });
        }
        
        // Update trail
        for (const p of this.trail) {
          p.life -= dt * 2;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.size *= 0.98;
        }
        this.trail = this.trail.filter(p => p.life > 0);
        
        // Max range - explode
        if (this.distanceTraveled >= this.maxRange) {
          this.alive = false;
          return { type: 'explode', x: this.x, y: this.y };
        }
        
        // Hit obstacle - explode
        for (const obs of obstacles) {
          if (this.x >= obs.x && this.x <= obs.x + obs.w && this.y >= obs.y && this.y <= obs.y + obs.h) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        // Hit agent - explode
        for (const agent of agents) {
          if (agent === this.owner || !agent.alive || agent.team === this.owner.team) continue;
          const dx = this.x - agent.x, dy = this.y - agent.y;
          if (Math.hypot(dx, dy) < agent.radius + this.radius) {
            this.alive = false;
            return { type: 'explode', x: this.x, y: this.y };
          }
        }
        
        return null;
      }
    }

    class Explosion {
      constructor(x, y, owner, radius, damage) {
        this.x = x;
        this.y = y;
        this.owner = owner;
        this.radius = radius;
        this.damage = damage;
        this.maxTime = 0.6;
        this.timer = 0;
        this.hasDealtDamage = false;
        this.currentRadius = 0;
        // Shockwave rings
        this.rings = [];
        // Debris particles
        this.particles = [];
        for (let i = 0; i < 40; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 150 + Math.random() * 350;
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.4 + Math.random() * 0.4,
            size: 3 + Math.random() * 8,
            color: Math.random() > 0.5 ? '#ff6600' : (Math.random() > 0.5 ? '#ffcc00' : '#ff0000')
          });
        }
        // Initial flash
        this.flashIntensity = 1;
      }
      update(dt, agents, world) {
        this.timer += dt;
        this.currentRadius = Math.min(this.radius, (this.timer / 0.15) * this.radius);
        this.flashIntensity = Math.max(0, 1 - this.timer * 4);
        
        // Add expanding rings
        if (this.timer < 0.3 && Math.random() < 0.3) {
          this.rings.push({ radius: this.currentRadius * 0.3, alpha: 1 });
        }
        
        // Update rings
        for (const ring of this.rings) {
          ring.radius += 400 * dt;
          ring.alpha -= dt * 3;
        }
        this.rings = this.rings.filter(r => r.alpha > 0);
        
        // Update particles
        for (const p of this.particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += 200 * dt; // Gravity
          p.life -= dt;
          p.size *= 0.97;
        }
        this.particles = this.particles.filter(p => p.life > 0);
        
        // Deal damage once at peak
        if (!this.hasDealtDamage && this.timer >= 0.05) {
          this.hasDealtDamage = true;
          for (const agent of agents) {
            if (!agent.alive || (this.owner && agent.team === this.owner.team)) continue;
            const dx = agent.x - this.x, dy = agent.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > this.radius) continue;
            
            // Damage falloff: 100% at center, 50% at edge
            const falloff = 1 - (dist / this.radius) * 0.5;
            const finalDamage = Math.floor(this.damage * falloff);
            
            const killed = agent.takeDamage(finalDamage, this.owner, world);
            if (this.owner) {
              this.owner.damageDealt += finalDamage;
              if (killed) {
                this.owner.kills++; this.owner.totalKills = (this.owner.totalKills || 0) + 1;
                world.teamKills[this.owner.team]++;
                this.owner.killScore += 50;
                world.addEvent('üí• ' + this.owner.name + ' OBLITERATED ' + agent.name + '!', 'kill');
              } else {
                world.addEvent(this.owner.name + ' rocket hit ' + agent.name, 'damage');
              }
            }
          }
        }
        
        return this.timer >= this.maxTime;
      }
    }

    // --------------------
    // Control Point
    // --------------------
    class ControlPoint {
      constructor(x, y, size) {
        this.x = x; this.y = y; this.size = size;
        this.owner = null; this.capturer = null;
        this.captureProgress = 0; this.captureTime = 10;
        this.contested = false;
        this.color = 'hsl(' + (Math.random() * 360) + ', 100%, 50%)';
      }
      containsAgent(agent) {
        return agent.x >= this.x && agent.x <= this.x + this.size && agent.y >= this.y && agent.y <= this.y + this.size;
      }
      getAgentsInside(agents) { return agents.filter(a => a.alive && this.containsAgent(a)); }
      update(dt, agents, world) {
        const inside = this.getAgentsInside(agents);

        if (this.owner && !this.owner.alive) {
          world.addEvent(this.owner.name + ' lost point', 'damage');
          this.owner = null;
        }

        this.contested = inside.length > 1;
        if (this.contested) {
          this.capturer = null;
          this.captureProgress = 0;
          return;
        }

        if (inside.length === 1) {
          const agent = inside[0];

          if (this.owner === agent) {
            agent.controlPointSeconds += dt;
            return;
          }

          // Capturing
          if (this.capturer !== agent) {
            this.capturer = agent;
            this.captureProgress = 0;
          }
          this.captureProgress += dt;

          if (this.captureProgress >= this.captureTime) {
            if (this.owner && this.owner !== agent) world.addEvent(agent.name + ' took point from ' + this.owner.name + '!', 'kill');
            this.owner = agent;
            this.capturer = null;
            this.captureProgress = 0;
            agent.controlPointCaptures++;
            world.addEvent(agent.name + ' captured point!', 'kill');
          }
          return;
        }

        // Nobody inside
        this.capturer = null;
        this.captureProgress = 0;
        if (this.owner && this.owner.alive) this.owner.controlPointSeconds += dt;
      }
    }

    // --------------------
    // Spatial hash (cheap nearest-neighbor acceleration)
    // --------------------
    class SpatialHash {
      constructor(cellSize) {
        this.cellSize = cellSize;
        this.map = new Map();
      }
      key(cx, cy) { return (cx << 16) ^ (cy & 0xffff); }
      cell(v) { return Math.floor(v / this.cellSize); }
      clear() { this.map.clear(); }
      insert(obj, x, y) {
        const cx = this.cell(x), cy = this.cell(y);
        const k = this.key(cx, cy);
        let arr = this.map.get(k);
        if (!arr) { arr = []; this.map.set(k, arr); }
        arr.push(obj);
      }
      query(x, y, radius) {
        const r = radius;
        const cs = this.cellSize;
        const minX = this.cell(x - r), maxX = this.cell(x + r);
        const minY = this.cell(y - r), maxY = this.cell(y + r);
        const out = [];
        for (let cx = minX; cx <= maxX; cx++) {
          for (let cy = minY; cy <= maxY; cy++) {
            const arr = this.map.get(this.key(cx, cy));
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    }

    // --------------------
    // Agent
    // --------------------
    // QUAKE MODE - Everyone gets a rocket launcher!
    const ROCKET = {
      damage: 90,          // Direct hit = almost one-shot
      splashRadius: 120,   // Big splash
      splashFalloff: 0.4,  // 40% damage at edge
      speed: 450,          // Fast enough to hit, slow enough to dodge
      fireRate: 4.0,        // 4 seconds between shots - makes each rocket count!
      selfDamage: true,    // Watch your feet!
      maxRange: 2000
    };

    class Agent {
      constructor(x, y, name, brain = null, team = 0) {
        this.x = x; this.y = y; this.name = name;
        this.team = team; // 0 = red, 1 = blue
        this.rotation = Math.random() * Math.PI * 2;
        this.vx = 0; this.vy = 0;

        this.health = 100; this.maxHealth = 100;
        this.armor = 0; this.maxArmor = 100; // 2 armor packs = 100
        this.stamina = 100; this.maxStamina = 100;

        this.alive = true;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        
        // Respawn system
        this.respawnTimer = 0;
        this.deaths = 0;

        // Weapon system
        this.weaponCooldown = 0;
        this.weapon = 'rocket'; // 'rocket', 'laser', or 'sword'
        this.laserCharge = 0; // 0-3 seconds
        this.laserCharging = false;
        
        // Sword mechanics
        this.swordCharge = 0; // 0-2 seconds max
        this.swordCharging = false;
        this.swordLunging = false;
        this.lungeStartX = 0;
        this.lungeStartY = 0;
        this.lungeEndX = 0;
        this.lungeEndY = 0;
        this.lungeProgress = 0;

        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.assists = 0;
        this.lastHitBy = null; // For assist tracking
        
        // Lifetime stats (persist across rounds)
        this.totalKills = 0;
        this.totalDeaths = 0;
        this.roundsPlayed = 0;

        // Network: 24 inputs ‚Üí 16 hidden ‚Üí 4 outputs (simplified)
        // Inputs: 16 raycast distances/types + 8 state (health, cooldown, velocity, etc)
        // Outputs: turn, move speed, shoot, strafe
        this.brain = brain || new NeuralNetwork(24, 16, 4);

        this.radius = 16;
        this.color = team === 0 ? '#ff4444' : '#4488ff';
      }
      
      // Reset for new round but keep identity
      resetForRound() {
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        this.weapon = 'rocket';
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;
        
        // Reset round stats but not lifetime stats
        this.damageDealt = 0;
        this.damageTaken = 0;
        this.kills = 0;
        this.deaths = 0;
        this.assists = 0;
        this.roundsPlayed++;
        
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
      }
      
      // Respawn after death
      respawn(world) {
        this.health = this.maxHealth;
        this.armor = 0;
        this.stamina = this.maxStamina;
        this.alive = true;
        this.respawnTimer = 0;
        this.vx = 0;
        this.vy = 0;
        this.attackCooldown = 0;
        this.attackRecovery = 0;
        this.weaponCooldown = 0;
        this.weapon = 'rocket'; // Lose special weapons on death
        this.laserCharge = 0;
        this.laserCharging = false;
        this.swordCharge = 0;
        this.swordCharging = false;
        this.swordLunging = false;
        this.lastHitBy = null;
        
        // Spawn at back of team's side
        const clusterX = this.team === 0 ? 80 : world.width - 80;
        this.x = clusterX + (Math.random() - 0.5) * 100;
        this.y = world.height / 2 + (Math.random() - 0.5) * (world.height - 200);
        this.x = clamp(this.x, 40, world.width - 40);
        this.y = clamp(this.y, 40, world.height - 40);
        this.rotation = this.team === 0 ? 0 : Math.PI;
      }

      get score() {
        const killPoints = this.kills * 50;
        const assistPoints = this.assists * 25;
        const damagePoints = this.damageDealt;
        return killPoints + assistPoints + damagePoints - this.damageTaken;
      }

      castRays(world, numRays = 8, fov = Math.PI * 0.8) {
        const { agents, obstacles, width: worldWidth, height: worldHeight } = world;
        const rayData = [];

        const startAngle = this.rotation - fov / 2;
        const angleStep = fov / (numRays - 1);
        const maxDist = Math.hypot(worldWidth, worldHeight);

        // Check all alive agents for raycasts (full map visibility)
        const nearCandidates = agents.filter(a => a.alive && a !== this);

        for (let i = 0; i < numRays; i++) {
          const angle = startAngle + angleStep * i;
          let closestDist = maxDist;
          let closestType = 0;

          const edgeDist = this.raycastMapEdge(angle, worldWidth, worldHeight);
          if (edgeDist < closestDist) { closestDist = edgeDist; closestType = 0; }

          for (const obs of obstacles) {
            const dist = this.raycastRect(angle, closestDist, obs);
            if (dist < closestDist) { closestDist = dist; closestType = 0.5; }
          }

          for (const other of nearCandidates) {
            if (other === this || !other.alive) continue;
            const dist = this.raycastCircle(angle, closestDist, other.x, other.y, other.radius);
            if (dist < closestDist) { closestDist = dist; closestType = 1; }
          }

          rayData.push(closestDist / maxDist);
          rayData.push(closestType);
        }
        return rayData;
      }

      raycastMapEdge(angle, w, h) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = Infinity;
        if (dx < 0) { const t = -this.x / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dx > 0) { const t = (w - this.x) / dx; if (t > 0 && t < tMin) tMin = t; }
        if (dy < 0) { const t = -this.y / dy; if (t > 0 && t < tMin) tMin = t; }
        if (dy > 0) { const t = (h - this.y) / dy; if (t > 0 && t < tMin) tMin = t; }
        return tMin;
      }

      raycastRect(angle, max, rect) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let tMin = 0, tMax = max;

        if (dx !== 0) {
          const t1 = (rect.x - this.x) / dx;
          const t2 = (rect.x + rect.w - this.x) / dx;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.x < rect.x || this.x > rect.x + rect.w) {
          return max;
        }

        if (dy !== 0) {
          const t1 = (rect.y - this.y) / dy;
          const t2 = (rect.y + rect.h - this.y) / dy;
          tMin = Math.max(tMin, Math.min(t1, t2));
          tMax = Math.min(tMax, Math.max(t1, t2));
        } else if (this.y < rect.y || this.y > rect.y + rect.h) {
          return max;
        }

        if (tMin <= tMax && tMin > 0) return tMin;
        return max;
      }

      raycastCircle(angle, max, cx, cy, r) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        const fx = this.x - cx, fy = this.y - cy;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - r * r;
        const d = b * b - 4 * a * c;
        if (d < 0) return max;
        const t = (-b - Math.sqrt(d)) / (2 * a);
        if (t > 0 && t < max) return t;
        return max;
      }

      think(world) {
        if (!this.alive) return null;

        const rayData = this.castRays(world);

        // Find nearest enemy
        let nearestEnemyDist = 1;
        let nearestEnemyAngle = 0;
        const enemies = world.agents.filter(a => a.alive && a.team !== this.team);
        for (const enemy of enemies) {
          const dx = enemy.x - this.x, dy = enemy.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 1000);
          if (nDist < nearestEnemyDist) {
            nearestEnemyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestEnemyAngle = a / Math.PI;
          }
        }

        // Find nearest ally (to avoid friendly fire)
        let nearestAllyDist = 1;
        let nearestAllyAngle = 0;
        const allies = world.agents.filter(a => a.alive && a.team === this.team && a !== this);
        for (const ally of allies) {
          const dx = ally.x - this.x, dy = ally.y - this.y;
          const dist = Math.hypot(dx, dy);
          const nDist = Math.min(1, dist / 500);
          if (nDist < nearestAllyDist) {
            nearestAllyDist = nDist;
            let a = Math.atan2(dy, dx) - this.rotation;
            while (a > Math.PI) a -= Math.PI * 2;
            while (a < -Math.PI) a += Math.PI * 2;
            nearestAllyAngle = a / Math.PI;
          }
        }

        const speedNorm = clamp(Math.hypot(this.vx, this.vy) / 200, 0, 1);
        const weaponReady = this.weaponCooldown <= 0 ? 1 : 0;

        // Simplified inputs for rocket mode: 24 total (16 rays + 8 internal)
        const internal = [
          this.health / this.maxHealth,
          speedNorm,
          weaponReady,
          nearestEnemyAngle,
          nearestEnemyDist,
          nearestAllyAngle,
          nearestAllyDist,
          this.team
        ];

        const outputs = this.brain.forward(rayData.concat(internal));

        return {
          turnAmount: outputs[0],
          speedAmount: (outputs[1] + 1) / 2,
          wantsShoot: outputs[2] > 0,
          strafe: outputs[3]
        };
      }

      update(decision, dt, world, obstacles) {
        if (!this.alive) return;

        this.attackCooldown = Math.max(0, this.attackCooldown - dt);
        this.attackRecovery = Math.max(0, this.attackRecovery - dt);
        this.weaponCooldown = Math.max(0, this.weaponCooldown - dt);

        // Handle sword lunge movement
        if (this.swordLunging) {
          // Scale lunge speed with distance (500 units/sec for consistent visual speed)
          const lungeSpeed = 500 / Math.max(50, this.lungeDist);
          this.lungeProgress += dt * lungeSpeed;
          if (this.lungeProgress >= 1) {
            this.swordLunging = false;
            this.x = this.lungeEndX;
            this.y = this.lungeEndY;
            this.weaponCooldown = 1.0; // 1 second cooldown after lunge
          } else {
            // Interpolate position
            this.x = this.lungeStartX + (this.lungeEndX - this.lungeStartX) * this.lungeProgress;
            this.y = this.lungeStartY + (this.lungeEndY - this.lungeStartY) * this.lungeProgress;
          }
          return; // Skip normal movement during lunge
        }

        if (!decision) return;

        this.rotation += decision.turnAmount * 4 * dt; // Faster turning for dodging

        // Forward/backward movement
        let targetSpeed = decision.speedAmount * 150; // Faster base speed
        
        // 50% movement speed while charging laser
        if (this.laserCharging) {
          targetSpeed *= 0.5;
        }
        
        // 80% movement slow while charging sword (20% speed)
        if (this.swordCharging) {
          targetSpeed *= 0.2;
        }
        
        // Strafing (perpendicular movement)
        let strafeSpeed = (decision.strafe || 0) * 100;
        if (this.laserCharging) {
          strafeSpeed *= 0.5;
        }
        if (this.swordCharging) {
          strafeSpeed *= 0.2;
        }

        const tvx = Math.cos(this.rotation) * targetSpeed + Math.cos(this.rotation + Math.PI/2) * strafeSpeed;
        const tvy = Math.sin(this.rotation) * targetSpeed + Math.sin(this.rotation + Math.PI/2) * strafeSpeed;
        
        const lerp = Math.min(1, 8 * dt); // Snappier movement
        this.vx += (tvx - this.vx) * lerp;
        this.vy += (tvy - this.vy) * lerp;

        let nx = this.x + this.vx * dt;
        let ny = this.y + this.vy * dt;

        for (const obs of obstacles) {
          const col = this.checkRectCollision(nx, ny, obs);
          if (col) { nx = col.x; ny = col.y; }
        }

        this.x = clamp(nx, this.radius, world.width - this.radius);
        this.y = clamp(ny, this.radius, world.height - this.radius);
      }

      // Shoot rocket!
      tryShoot(world) {
        if (!this.alive || this.weaponCooldown > 0) return null;

        this.weaponCooldown = ROCKET.fireRate;
        
        return { 
          type: 'rocket', 
          x: this.x + Math.cos(this.rotation) * 25, 
          y: this.y + Math.sin(this.rotation) * 25, 
          angle: this.rotation, 
          owner: this, 
          damage: ROCKET.damage,
          splashRadius: ROCKET.splashRadius,
          splashFalloff: ROCKET.splashFalloff,
          speed: ROCKET.speed, 
          range: ROCKET.maxRange,
          traveled: 0,
          alive: true
        };
      }

      checkRectCollision(newX, newY, rect) {
        const cx = Math.max(rect.x, Math.min(newX, rect.x + rect.w));
        const cy = Math.max(rect.y, Math.min(newY, rect.y + rect.h));
        const dx = newX - cx, dy = newY - cy;
        const dist = Math.hypot(dx, dy);
        if (dist < this.radius) {
          const ov = this.radius - dist;
          if (dist > 0) return { x: newX + (dx / dist) * ov, y: newY + (dy / dist) * ov };
          return { x: newX + this.radius, y: newY };
        }
        return null;
      }

      tryAttack(agents, world) {
        // No melee in Quake mode - rockets only!
        return null;
      }

      takeDamage(amount, attacker, world) {
        // Armor absorbs damage first
        if (this.armor > 0) {
          const armorDamage = Math.min(this.armor, amount);
          this.armor -= armorDamage;
          amount -= armorDamage;
        }
        
        this.health -= amount;
        this.damageTaken += amount;

        // Track who hit us for assists
        if (attacker && attacker !== this.lastHitBy) {
          if (this.lastHitBy && this.health <= 0 && this.lastHitBy !== attacker) {
            this.lastHitBy.assists++;
          }
          this.lastHitBy = attacker;
        }

        if (this.health > 0) return false;

        // Death
        this.alive = false;
        this.deaths++;
        this.totalDeaths++;
        this.respawnTimer = world ? world.respawnTime : 3; // Use world's respawn time
        return true;
      }

      clone(newName, team) {
        const child = new Agent(this.x, this.y, newName, this.brain.clone(), team);
        return child;
      }
    }

    // --------------------
    // World
    // --------------------
    class World {
      constructor(width, height) {
        this.width = width;
        this.height = height;

        this.agents = [];
        this.obstacles = [];
        this.buildings = [];

        // Projectiles - ROCKETS ONLY in Quake mode
        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = []; // Smoke trail particles

        // Pickups
        this.pickups = [];
        this.pickupTimer = 0;
        this.pickupInterval = 20; // Spawn every 20 seconds
        this.nextPickupType = 'health'; // Alternates between health and armor
        this.healthSpawnsEnabled = true;
        this.armorSpawnsEnabled = true;
        
        // Laser spawns
        this.laserSpawnsEnabled = true;
        this.laserSpawned = false; // Only spawn once per round
        this.laserBeams = []; // Active laser beam animations
        
        // Sword spawns
        this.swordSpawnsEnabled = true;
        this.swordSpawned = false;
        this.swordSlashes = []; // Active sword slash animations

        this.roundTime = 180; // 3 minutes
        this.timeLeft = this.roundTime;

        this.usedNames = new Set();
        this.generation = 1;
        this.events = [];
        this.paused = false;

        this.population = 100; // 50 per team
        this.aliveCount = 0;
        
        // Team Deathmatch specific
        this.teamKills = [0, 0]; // [red kills, blue kills] - NET score (kills - ricochets)
        this.teamRawKills = [0, 0]; // Actual enemy kills
        this.teamRicochets = [0, 0]; // Friendly fire incidents
        this.killLimit = 20;
        this.winningTeam = null;
        this.teamWins = [0, 0]; // Track total wins per team
        
        // Game modifiers
        this.friendlyFire = false;
        this.friendlyFireRicochet = false;
        this.respawnTime = 3; // seconds
        
        // Team brains (evolved separately)
        this.teamBrains = [null, null];

        this.spatialAgents = new SpatialHash(120);

        this.generateObstacles();
      }

      spawnLaserPickups() {
        if (this.laserSpawned || !this.laserSpawnsEnabled) return;
        
        // Spawn 2 lasers at center of map
        const cx = this.width / 2;
        const cy = this.height / 2;
        
        this.pickups.push({
          x: cx - 50,
          y: cy,
          type: 'laser',
          radius: 18
        });
        this.pickups.push({
          x: cx + 50,
          y: cy,
          type: 'laser',
          radius: 18
        });
        
        this.laserSpawned = true;
        this.addEvent('‚ö° LASER WEAPONS SPAWNED!', 'laser');
      }

      spawnSwordPickups() {
        if (this.swordSpawned || !this.swordSpawnsEnabled) return;
        
        // Spawn 2 swords at center of map (offset from laser)
        const cx = this.width / 2;
        const cy = this.height / 2;
        
        this.pickups.push({
          x: cx,
          y: cy - 80,
          type: 'sword',
          radius: 18
        });
        this.pickups.push({
          x: cx,
          y: cy + 80,
          type: 'sword',
          radius: 18
        });
        
        this.swordSpawned = true;
        this.addEvent('üó°Ô∏è ENERGY SWORDS SPAWNED!', 'sword');
      }

      spawnPickups() {
        // Determine which type to spawn
        let typeToSpawn = this.nextPickupType;
        
        // Check if enabled, otherwise switch
        if (typeToSpawn === 'health' && !this.healthSpawnsEnabled) {
          typeToSpawn = this.armorSpawnsEnabled ? 'armor' : null;
        } else if (typeToSpawn === 'armor' && !this.armorSpawnsEnabled) {
          typeToSpawn = this.healthSpawnsEnabled ? 'health' : null;
        }
        
        if (!typeToSpawn) return;
        
        // Spawn 5 pickups
        for (let i = 0; i < 5; i++) {
          // Random position avoiding edges
          const x = 150 + Math.random() * (this.width - 300);
          const y = 150 + Math.random() * (this.height - 300);
          
          this.pickups.push({
            x, y,
            type: typeToSpawn,
            radius: 15
          });
        }
        
        // Alternate for next spawn
        this.nextPickupType = typeToSpawn === 'health' ? 'armor' : 'health';
        
        const icon = typeToSpawn === 'health' ? 'ü©π' : 'üõ°Ô∏è';
        this.addEvent(icon + ' ' + typeToSpawn.toUpperCase() + ' packs spawned!', 'pickup');
      }

      fireLaser(agent) {
        // Calculate beam endpoint (extends to world edge)
        const angle = agent.rotation;
        const startX = agent.x + Math.cos(angle) * agent.radius;
        const startY = agent.y + Math.sin(angle) * agent.radius;
        
        // Find where beam exits world
        let endX, endY;
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        
        // Calculate intersection with world boundaries
        const tRight = cosA > 0 ? (this.width - startX) / cosA : Infinity;
        const tLeft = cosA < 0 ? -startX / cosA : Infinity;
        const tBottom = sinA > 0 ? (this.height - startY) / sinA : Infinity;
        const tTop = sinA < 0 ? -startY / sinA : Infinity;
        
        const t = Math.min(tRight, tLeft, tBottom, tTop);
        endX = startX + cosA * t;
        endY = startY + sinA * t;
        
        // Check for hits on all agents in beam path
        let killCount = 0;
        for (const target of this.agents) {
          if (target === agent || !target.alive) continue;
          
          // Skip teammates unless FF is on
          if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;
          
          // Point-to-line distance check
          const dx = endX - startX;
          const dy = endY - startY;
          const len = Math.hypot(dx, dy);
          const nx = -dy / len;
          const ny = dx / len;
          
          const px = target.x - startX;
          const py = target.y - startY;
          const dist = Math.abs(px * nx + py * ny);
          
          // Also check if target is in front of shooter
          const dot = px * (dx / len) + py * (dy / len);
          
          if (dist < target.radius + 10 && dot > 0) {
            // Hit!
            if (target.team === agent.team) {
              // Friendly fire
              if (this.friendlyFireRicochet) {
                // Ricochet damage to self
                const killed = agent.takeDamage(999, agent, this);
                this.teamRicochets[agent.team]++;
                if (killed) {
                  this.addEvent('üîÑ ' + agent.name + ' LASER RICOCHET!', 'laser');
                }
              } else if (this.friendlyFire) {
                const killed = target.takeDamage(999, agent, this);
                if (killed) {
                  this.teamRicochets[agent.team]++;
                  this.addEvent('‚ö° ' + agent.name + ' TEAMKILLED ' + target.name + '!', 'laser');
                }
              }
            } else {
              // Enemy kill
              const killed = target.takeDamage(999, agent, this);
              if (killed) {
                agent.kills++;
                agent.totalKills++;
                this.teamKills[agent.team]++;
                this.teamRawKills[agent.team]++;
                killCount++;
              }
            }
          }
        }
        
        if (killCount > 0) {
          const msg = killCount > 1 
            ? '‚ö° ' + agent.name + ' LASER MULTI-KILL x' + killCount + '!'
            : '‚ö° ' + agent.name + ' LASER KILL!';
          this.addEvent(msg, 'laser');
        }
        
        // Add beam animation
        this.laserBeams.push({
          startX, startY, endX, endY,
          team: agent.team,
          timer: 0,
          maxTime: 1.5
        });
      }

      executeSwordLunge(agent, chargeTime) {
        // Calculate lunge distance based on charge time (0.5s min charge, 2s max)
        const minDist = 50;
        const maxDist = 250;
        const chargeRatio = Math.min(1, Math.max(0, (chargeTime - 0.3) / 1.7)); // 0.3s to 2s
        const lungeDist = minDist + chargeRatio * (maxDist - minDist);
        
        const startX = agent.x;
        const startY = agent.y;
        const endX = agent.x + Math.cos(agent.rotation) * lungeDist;
        const endY = agent.y + Math.sin(agent.rotation) * lungeDist;
        
        // Clamp to world bounds
        const clampedEndX = clamp(endX, agent.radius, this.width - agent.radius);
        const clampedEndY = clamp(endY, agent.radius, this.height - agent.radius);
        
        // Set up lunge
        agent.lungeStartX = startX;
        agent.lungeStartY = startY;
        agent.lungeEndX = clampedEndX;
        agent.lungeEndY = clampedEndY;
        agent.lungeProgress = 0;
        agent.lungeDist = Math.hypot(clampedEndX - startX, clampedEndY - startY);
        agent.swordLunging = true;
        
        // Check for hits along the lunge path
        let killCount = 0;
        for (const target of this.agents) {
          if (target === agent || !target.alive) continue;
          
          // Skip teammates unless FF is on
          if (target.team === agent.team && !this.friendlyFire && !this.friendlyFireRicochet) continue;
          
          // Point-to-line distance check
          const dx = clampedEndX - startX;
          const dy = clampedEndY - startY;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;
          
          const nx = -dy / len;
          const ny = dx / len;
          
          const px = target.x - startX;
          const py = target.y - startY;
          const dist = Math.abs(px * nx + py * ny);
          
          // Check if target is along the path
          const dot = px * (dx / len) + py * (dy / len);
          
          if (dist < target.radius + 20 && dot > 0 && dot < len) {
            // Hit!
            if (target.team === agent.team) {
              if (this.friendlyFireRicochet) {
                const killed = agent.takeDamage(999, agent, this);
                this.teamRicochets[agent.team]++;
                if (killed) {
                  this.addEvent('üîÑ ' + agent.name + ' SWORD RICOCHET!', 'sword');
                }
              } else if (this.friendlyFire) {
                const killed = target.takeDamage(999, agent, this);
                if (killed) {
                  this.teamRicochets[agent.team]++;
                  this.addEvent('üó°Ô∏è ' + agent.name + ' TEAMKILLED ' + target.name + '!', 'sword');
                }
              }
            } else {
              const killed = target.takeDamage(999, agent, this);
              if (killed) {
                agent.kills++;
                agent.totalKills++;
                this.teamKills[agent.team]++;
                this.teamRawKills[agent.team]++;
                killCount++;
              }
            }
          }
        }
        
        if (killCount > 0) {
          const msg = killCount > 1 
            ? 'üó°Ô∏è ' + agent.name + ' SWORD MULTI-KILL x' + killCount + '!'
            : 'üó°Ô∏è ' + agent.name + ' SWORD KILL!';
          this.addEvent(msg, 'sword');
        }
        
        // Add slash animation (scale duration with distance)
        const actualDist = Math.hypot(clampedEndX - startX, clampedEndY - startY);
        const slashDuration = 0.3 + (actualDist / 250) * 0.5; // 0.3s base + up to 0.5s for max range
        this.swordSlashes.push({
          startX, startY,
          endX: clampedEndX, endY: clampedEndY,
          team: agent.team,
          timer: 0,
          maxTime: slashDuration
        });
      }

      setRoundTimeSeconds(sec) {
        this.roundTime = Math.max(10, sec);
        this.timeLeft = Math.min(this.timeLeft, this.roundTime);
      }

      generateObstacles() {
        this.obstacles = [];
        this.buildings = [];

        const bTypes = [
          { w: 100, h: 100 },
          { w: 150, h: 100 },
          { w: 80, h: 80 },
          { w: 120, h: 60 },
          { w: 60, h: 120 },
        ];

        const overlaps = (x, y, w, h, margin = 30) => {
          for (const o of this.obstacles) {
            if (x < o.x + o.w + margin && x + w > o.x - margin && 
                y < o.y + o.h + margin && y + h > o.y - margin) return true;
          }
          return false;
        };

        const addBuilding = (x, y, w, h) => {
          if (!overlaps(x, y, w, h)) {
            this.buildings.push({ x, y, w, h });
            this.obstacles.push({ x, y, w, h });
            return true;
          }
          return false;
        };

        // =====================
        // SPAWN AREA COVER - Heavy protection near spawns
        // =====================
        
        // Red spawn cover (left side, x: 100-500)
        for (let i = 0; i < 8; i++) {
          const x = 120 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue spawn cover (right side, x: width-500 to width-100)
        for (let i = 0; i < 8; i++) {
          const x = this.width - 470 + Math.random() * 350;
          const y = 150 + (i / 8) * (this.height - 300);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // MID TRANSITION - Some cover between spawn and open middle
        // =====================
        
        // Red side transition (x: 500-800)
        for (let i = 0; i < 4; i++) {
          const x = 500 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }
        
        // Blue side transition (x: width-800 to width-500)
        for (let i = 0; i < 4; i++) {
          const x = this.width - 750 + Math.random() * 250;
          const y = 200 + Math.random() * (this.height - 400);
          const t = bTypes[Math.floor(Math.random() * bTypes.length)];
          addBuilding(x, y, t.w, t.h);
        }

        // =====================
        // OPEN MIDDLE - Very sparse, just a few small covers
        // =====================
        
        // Only 2-3 small obstacles in the center zone (x: 900-1500)
        for (let i = 0; i < 3; i++) {
          const x = 950 + Math.random() * 500;
          const y = 300 + Math.random() * (this.height - 600);
          addBuilding(x, y, 60, 60); // Small cover only
        }

        // =====================
        // EDGE LANES - Cover along top and bottom for flanking
        // =====================
        
        // Top lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, 80 + Math.random() * 60, 80, 80);
        }
        
        // Bottom lane
        for (let i = 0; i < 4; i++) {
          const x = 300 + (i / 4) * (this.width - 600);
          addBuilding(x, this.height - 160 + Math.random() * 60, 80, 80);
        }
      }

      generateUniqueName() {
        let n;
        let att = 0;
        do {
          n = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)] + ' ' + LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
          if (this.usedNames.has(n)) {
            let s = 2;
            while (this.usedNames.has(n + ' (' + s + ')')) s++;
            n = n + ' (' + s + ')';
          }
          att++;
        } while (this.usedNames.has(n) && att < 100);
        this.usedNames.add(n);
        return n;
      }

      spawnAgents(count) {
        this.population = count;
        this.agents = [];
        this.usedNames.clear();

        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = [];

        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.winningTeam = null;

        const perTeam = Math.floor(count / 2);
        
        // Create persistent soldiers for each team
        for (let team = 0; team < 2; team++) {
          const clusterX = team === 0 ? 80 : this.width - 80;
          const clusterY = this.height / 2;
          
          for (let i = 0; i < perTeam; i++) {
            let x = clusterX + (Math.random() - 0.5) * 150;
            let y = clusterY + (Math.random() - 0.5) * (this.height - 200);
            x = clamp(x, 40, this.width - 40);
            y = clamp(y, 40, this.height - 40);
            
            const brain = this.teamBrains[team]?.clone() || null;
            const agent = new Agent(x, y, this.generateUniqueName(), brain, team);
            agent.rotation = team === 0 ? 0 : Math.PI;
            
            if (this.teamBrains[team] && i > 0) {
              agent.brain.mutate(0.1, 0.3);
            }
            
            this.agents.push(agent);
          }
        }

        this.timeLeft = this.roundTime;
      }

      spawnNextRound() {
        // Sort each team by score
        const redAgents = this.agents.filter(a => a.team === 0);
        const blueAgents = this.agents.filter(a => a.team === 1);
        
        redAgents.sort((a, b) => b.score - a.score);
        blueAgents.sort((a, b) => b.score - a.score);
        
        // Brain transfer: EVERYONE below top 10% gets a clone of a top performer
        const transferBrains = (agents) => {
          if (agents.length === 0) return;
          
          const top10pct = Math.max(1, Math.floor(agents.length * 0.1)); // Top 5 agents
          const top10Brains = agents.slice(0, top10pct).map(a => a.brain.clone());
          
          // Top 10% - keep their brains, tiny mutation to explore
          for (let i = 0; i < top10pct; i++) {
            agents[i].brain.mutate(0.02, 0.1);
          }
          
          // Everyone else gets a random top performer's brain with mutation
          for (let i = top10pct; i < agents.length; i++) {
            const parentBrain = top10Brains[Math.floor(Math.random() * top10Brains.length)];
            agents[i].brain = parentBrain.clone();
            
            // More mutation the worse they performed
            const performanceRatio = i / agents.length; // 0.1 to 1.0
            const mutationRate = 0.1 + performanceRatio * 0.2; // 0.1 to 0.3
            const mutationStrength = 0.2 + performanceRatio * 0.4; // 0.2 to 0.6
            agents[i].brain.mutate(mutationRate, mutationStrength);
          }
        };
        
        transferBrains(redAgents);
        transferBrains(blueAgents);
        
        // Update team brains to best performer
        if (redAgents[0]) this.teamBrains[0] = redAgents[0].brain.clone();
        if (blueAgents[0]) this.teamBrains[1] = blueAgents[0].brain.clone();
        
        // Reset round state
        this.teamKills = [0, 0];
        this.teamRawKills = [0, 0];
        this.teamRicochets = [0, 0];
        this.winningTeam = null;
        this.timeLeft = this.roundTime;
        this.generateObstacles();

        this.rockets = [];
        this.explosions = [];
        this.smokeParticles = [];
        this.pickups = [];
        this.pickupTimer = 0;
        this.nextPickupType = 'health';
        this.laserSpawned = false;
        this.laserBeams = [];
        this.swordSpawned = false;
        this.swordSlashes = [];
        
        // Reset all agents for new round (but keep names and lifetime stats)
        for (const agent of this.agents) {
          const clusterX = agent.team === 0 ? 80 : this.width - 80;
          agent.x = clusterX + (Math.random() - 0.5) * 150;
          agent.y = this.height / 2 + (Math.random() - 0.5) * (this.height - 200);
          agent.x = clamp(agent.x, 40, this.width - 40);
          agent.y = clamp(agent.y, 40, this.height - 40);
          agent.rotation = agent.team === 0 ? 0 : Math.PI;
          agent.resetForRound();
        }
      }

      // Keep for compatibility
      spawnFromParents(parents, total) {
        this.spawnNextRound();
      }

      rebuildSpatial() {
        this.spatialAgents.clear();
        for (const a of this.agents) if (a.alive) this.spatialAgents.insert(a, a.x, a.y);
      }

      update(dt) {
        if (this.paused) return;

        this.timeLeft -= dt;

        // Pickup spawning
        this.pickupTimer += dt;
        if (this.pickupTimer >= this.pickupInterval) {
          this.pickupTimer = 0;
          this.spawnPickups();
        }
        
        // Laser spawn check - spawn 10 seconds after round start
        if (!this.laserSpawned && this.laserSpawnsEnabled) {
          const timePassed = this.roundTime - this.timeLeft;
          if (timePassed >= 10) {
            this.spawnLaserPickups();
          }
        }
        
        // Sword spawn check - spawn 15 seconds after round start
        if (!this.swordSpawned && this.swordSpawnsEnabled) {
          const timePassed = this.roundTime - this.timeLeft;
          if (timePassed >= 15) {
            this.spawnSwordPickups();
          }
        }

        // Pickup collection
        for (const agent of this.agents) {
          if (!agent.alive) continue;
          
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            const dist = Math.hypot(agent.x - p.x, agent.y - p.y);
            
            if (dist < agent.radius + p.radius) {
              // Collect pickup
              if (p.type === 'health') {
                const healed = Math.min(50, agent.maxHealth - agent.health);
                agent.health = Math.min(agent.maxHealth, agent.health + 50);
                if (healed > 0) {
                  this.addEvent('ü©π ' + agent.name + ' +' + healed + 'hp', 'pickup');
                }
                this.pickups.splice(i, 1);
              } else if (p.type === 'armor') {
                if (agent.armor < agent.maxArmor) {
                  const gained = Math.min(50, agent.maxArmor - agent.armor);
                  agent.armor = Math.min(agent.maxArmor, agent.armor + 50);
                  this.addEvent('üõ°Ô∏è ' + agent.name + ' +' + gained + ' armor', 'pickup');
                  this.pickups.splice(i, 1);
                }
              } else if (p.type === 'laser') {
                agent.weapon = 'laser';
                agent.laserCharge = 0;
                agent.weaponCooldown = 0;
                this.addEvent('‚ö° ' + agent.name + ' GOT THE LASER!', 'laser');
                this.pickups.splice(i, 1);
              } else if (p.type === 'sword') {
                agent.weapon = 'sword';
                agent.swordCharge = 0;
                agent.swordCharging = false;
                agent.weaponCooldown = 0;
                this.addEvent('üó°Ô∏è ' + agent.name + ' GOT THE ENERGY SWORD!', 'sword');
                this.pickups.splice(i, 1);
              }
            }
          }
        }

        // Update alive count + spatial hash
        let alive = 0;
        for (const a of this.agents) if (a.alive) alive++;
        this.aliveCount = alive;
        this.rebuildSpatial();
        
        // Handle respawns
        for (const agent of this.agents) {
          if (!agent.alive && agent.respawnTimer > 0) {
            agent.respawnTimer -= dt;
            if (agent.respawnTimer <= 0) {
              agent.respawn(this);
              this.addEvent('üîÑ ' + agent.name + ' respawned', 'damage');
            }
          }
        }

        // Update rockets
        for (const r of this.rockets) {
          if (!r.alive) continue;
          
          // Move rocket
          r.x += Math.cos(r.angle) * r.speed * dt;
          r.y += Math.sin(r.angle) * r.speed * dt;
          r.traveled += r.speed * dt;
          
          // Spawn smoke particles behind rocket
          r.smokeTimer = (r.smokeTimer || 0) + dt;
          if (r.smokeTimer > 0.02) { // Every 20ms
            r.smokeTimer = 0;
            this.smokeParticles.push({
              x: r.x - Math.cos(r.angle) * 15,
              y: r.y - Math.sin(r.angle) * 15,
              vx: (Math.random() - 0.5) * 30,
              vy: (Math.random() - 0.5) * 30,
              life: 0.4, // 400ms lifetime
              maxLife: 0.4,
              size: 8 + Math.random() * 6
            });
          }
          
          let explode = false;
          let explodeX = r.x;
          let explodeY = r.y;
          
          // Check range
          if (r.traveled >= r.range) {
            explode = true;
          }
          
          // Check wall collision
          if (r.x < 0 || r.x > this.width || r.y < 0 || r.y > this.height) {
            explode = true;
            explodeX = clamp(r.x, 0, this.width);
            explodeY = clamp(r.y, 0, this.height);
          }
          
          // Check obstacle collision
          if (!explode) {
            for (const obs of this.obstacles) {
              if (r.x >= obs.x && r.x <= obs.x + obs.w && r.y >= obs.y && r.y <= obs.y + obs.h) {
                explode = true;
                break;
              }
            }
          }
          
          // Check agent collision (direct hit)
          if (!explode) {
            for (const agent of this.agents) {
              if (agent === r.owner || !agent.alive) continue;
              if (Math.hypot(r.x - agent.x, r.y - agent.y) < agent.radius + 8) {
                explode = true;
                explodeX = agent.x;
                explodeY = agent.y;
                break;
              }
            }
          }
          
          // Create explosion
          if (explode) {
            r.alive = false;
            this.explosions.push({
              x: explodeX, y: explodeY, 
              owner: r.owner, 
              damage: r.damage,
              splashRadius: r.splashRadius,
              splashFalloff: r.splashFalloff,
              timer: 0, 
              maxTime: 0.4, 
              dealtDamage: false
            });
          }
        }
        this.rockets = this.rockets.filter(r => r.alive);

        // Update smoke particles
        for (const p of this.smokeParticles) {
          p.life -= dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.95; // Slow down
          p.vy *= 0.95;
          p.size += dt * 10; // Expand
        }
        this.smokeParticles = this.smokeParticles.filter(p => p.life > 0);

        // Update explosions - SPLASH DAMAGE
        for (const e of this.explosions) {
          e.timer += dt;
          
          if (!e.dealtDamage && e.timer >= 0.05) {
            e.dealtDamage = true;
            
            for (const agent of this.agents) {
              if (!agent.alive) continue;
              
              const dist = Math.hypot(agent.x - e.x, agent.y - e.y);
              if (dist > e.splashRadius) continue;
              
              // Damage falloff based on distance
              const falloff = 1 - (dist / e.splashRadius) * e.splashFalloff;
              const dmg = Math.floor(e.damage * falloff);
              
              if (agent === e.owner) {
                // Direct self-damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (killed) {
                  this.addEvent('üíÄ ' + e.owner.name + ' ROCKET JUMPED TOO HARD!', 'kill');
                }
              } else if (e.owner && agent.team === e.owner.team) {
                // Teammate hit
                if (this.friendlyFire) {
                  // Direct friendly fire - damage teammate
                  const killed = agent.takeDamage(dmg, e.owner, this);
                  if (killed) {
                    this.teamRicochets[e.owner.team]++;
                    this.addEvent('üíÄ ' + e.owner.name + ' TEAMKILLED ' + agent.name + '!', 'kill');
                  }
                } else if (this.friendlyFireRicochet) {
                  // Ricochet - damage reflects to shooter
                  const killed = e.owner.takeDamage(dmg, e.owner, this);
                  this.teamRicochets[e.owner.team]++;
                  if (killed) {
                    this.addEvent('üîÑ ' + e.owner.name + ' DIED FROM RICOCHET!', 'kill');
                  } else {
                    this.addEvent('üîÑ ' + e.owner.name + ' ricochet -' + dmg + 'hp', 'damage');
                  }
                }
                // Else: no friendly fire, skip
              } else {
                // Enemy damage
                const killed = agent.takeDamage(dmg, e.owner, this);
                if (e.owner) {
                  e.owner.damageDealt += dmg;
                  if (killed) {
                    e.owner.kills++; 
                    e.owner.totalKills = (e.owner.totalKills || 0) + 1;
                    this.teamKills[e.owner.team]++;
                    this.teamRawKills[e.owner.team]++;
                    this.addEvent('üöÄ ' + e.owner.name + ' FRAGGED ' + agent.name + '!', 'kill');
                  }
                }
              }
            }
          }
        }
        this.explosions = this.explosions.filter(e => e.timer < e.maxTime);

        // Get decisions
        const decisions = new Array(this.agents.length);
        for (let i = 0; i < this.agents.length; i++) {
          decisions[i] = this.agents[i].think(this);
        }

        // Update agents
        for (let i = 0; i < this.agents.length; i++) {
          const a = this.agents[i];
          const d = decisions[i];
          a.update(d, dt, this, this.obstacles);

          // Handle shooting based on weapon type
          if (d && d.wantsShoot) {
            if (a.weapon === 'rocket') {
              const rocket = a.tryShoot(this);
              if (rocket) {
                this.rockets.push(rocket);
              }
            } else if (a.weapon === 'laser') {
              // Laser charging
              if (a.weaponCooldown <= 0) {
                a.laserCharging = true;
                a.laserCharge += dt;
                
                // Fire when fully charged
                if (a.laserCharge >= 3.0) {
                  this.fireLaser(a);
                  a.laserCharge = 0;
                  a.laserCharging = false;
                  a.weaponCooldown = 1.0; // 1 second cooldown
                }
              }
            } else if (a.weapon === 'sword') {
              // Sword charging (ready stance)
              if (a.weaponCooldown <= 0 && !a.swordLunging) {
                a.swordCharging = true;
                a.swordCharge = Math.min(2.0, a.swordCharge + dt); // Max 2 seconds charge
              }
            }
          } else {
            // Reset laser charge if not holding shoot
            if (a.weapon === 'laser' && a.laserCharging) {
              a.laserCharge = 0;
              a.laserCharging = false;
            }
            // Execute sword lunge when releasing
            if (a.weapon === 'sword' && a.swordCharging && a.swordCharge >= 0.3) {
              this.executeSwordLunge(a, a.swordCharge);
              a.swordCharge = 0;
              a.swordCharging = false;
            } else if (a.weapon === 'sword' && a.swordCharging) {
              // Not enough charge, just reset
              a.swordCharge = 0;
              a.swordCharging = false;
            }
          }
        }
        
        // Update laser beams animation
        for (const beam of this.laserBeams) {
          beam.timer += dt;
        }
        this.laserBeams = this.laserBeams.filter(b => b.timer < b.maxTime);
        
        // Update sword slash animations
        for (const slash of this.swordSlashes) {
          slash.timer += dt;
        }
        this.swordSlashes = this.swordSlashes.filter(s => s.timer < s.maxTime);

        // Agent-agent collision (push apart)
        const aliveAgents = this.agents.filter(a => a.alive);
        for (let i = 0; i < aliveAgents.length; i++) {
          for (let j = i + 1; j < aliveAgents.length; j++) {
            const a = aliveAgents[i];
            const b = aliveAgents[j];
            
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = a.radius + b.radius;
            
            if (dist < minDist && dist > 0) {
              // Push apart
              const overlap = minDist - dist;
              const pushX = (dx / dist) * overlap * 0.5;
              const pushY = (dy / dist) * overlap * 0.5;
              
              a.x -= pushX;
              a.y -= pushY;
              b.x += pushX;
              b.y += pushY;
              
              // Clamp to world bounds
              a.x = clamp(a.x, a.radius, this.width - a.radius);
              a.y = clamp(a.y, a.radius, this.height - a.radius);
              b.x = clamp(b.x, b.radius, this.width - b.radius);
              b.y = clamp(b.y, b.radius, this.height - b.radius);
            }
          }
        }

        // Check win condition
        if (this.teamKills[0] >= this.killLimit || this.teamKills[1] >= this.killLimit || this.timeLeft <= 0) {
          this.endRound();
        }
      }
      endRound() {
        // Determine winner
        if (this.teamKills[0] >= this.killLimit) {
          this.winningTeam = 0;
          this.teamWins[0]++;
          this.addEvent('üî¥ RED TEAM WINS! ' + this.teamKills[0] + ' kills!', 'kill');
        } else if (this.teamKills[1] >= this.killLimit) {
          this.winningTeam = 1;
          this.teamWins[1]++;
          this.addEvent('üîµ BLUE TEAM WINS! ' + this.teamKills[1] + ' kills!', 'kill');
        } else {
          // Time out - team with most kills wins
          this.winningTeam = this.teamKills[0] > this.teamKills[1] ? 0 : 1;
          this.teamWins[this.winningTeam]++;
          const winnerName = this.winningTeam === 0 ? 'RED' : 'BLUE';
          this.addEvent('‚è±Ô∏è TIME! ' + winnerName + ' WINS ' + this.teamKills[this.winningTeam] + '-' + this.teamKills[1-this.winningTeam], 'kill');
        }
        
        // Get best brain from winning team
        const winningAgents = this.agents.filter(a => a.team === this.winningTeam);
        const bestAgent = winningAgents.sort((a, b) => b.score - a.score)[0];
        
        // Update the winning team's brain
        this.teamBrains[this.winningTeam] = bestAgent.brain.clone();
        
        // Losing team gets a mutated version of their best, or copy winner if they had none
        const losingTeam = 1 - this.winningTeam;
        const losingAgents = this.agents.filter(a => a.team === losingTeam);
        const bestLoser = losingAgents.sort((a, b) => b.score - a.score)[0];
        if (bestLoser) {
          this.teamBrains[losingTeam] = bestLoser.brain.clone();
          this.teamBrains[losingTeam].mutate(0.2, 0.5);
        }
        
        this.addEvent('GENERATION ' + this.generation + ' COMPLETE', 'kill');
        this.generation++;
        this.spawnNextRound();
      }

      addEvent(text, type) {
        this.events.unshift({ text, type, time: Date.now() });
        if (this.events.length > 80) this.events.pop();
      }

      getLeaderboard() {
        return [...this.agents].sort((a, b) => b.score - a.score).slice(0, 10);
      }
    }

    // --------------------
    // Renderer
    // --------------------
    class Renderer {
      constructor(canvas, world) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.world = world;

        this.cameraX = 0;
        this.cameraY = 0;
        this.zoom = 1;
        this.minZoom = 0.25;
        this.maxZoom = 3;

        this.isDragging = false;
        this.baseScale = 1;
        this.cssW = 0;
        this.cssH = 0;
        this.dpr = 1;

        this.setupControls();
        this.resize();
      }

      setupControls() {
        const onWheel = (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const worldX = this.cameraX + mouseX / (this.baseScale * this.zoom);
          const worldY = this.cameraY + mouseY / (this.baseScale * this.zoom);

          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          this.zoom = clamp(this.zoom * zoomFactor, this.minZoom, this.maxZoom);

          this.cameraX = worldX - mouseX / (this.baseScale * this.zoom);
          this.cameraY = worldY - mouseY / (this.baseScale * this.zoom);

          this.clampCamera();
        };

        this.canvas.addEventListener('wheel', onWheel, { passive: false });

        const startDrag = (x, y) => {
          this.isDragging = true;
          this.dragStartX = x;
          this.dragStartY = y;
          this.dragCamX = this.cameraX;
          this.dragCamY = this.cameraY;
          this.canvas.style.cursor = 'grabbing';
        };

        const moveDrag = (x, y) => {
          if (!this.isDragging) return;
          const dx = x - this.dragStartX;
          const dy = y - this.dragStartY;
          this.cameraX = this.dragCamX - dx / (this.baseScale * this.zoom);
          this.cameraY = this.dragCamY - dy / (this.baseScale * this.zoom);
          this.clampCamera();
        };

        const endDrag = () => {
          this.isDragging = false;
          this.canvas.style.cursor = 'grab';
        };

        this.canvas.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
        window.addEventListener('mouseup', endDrag);

        // Touch (single finger pan)
        this.canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) startDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: true });

        this.canvas.addEventListener('touchmove', (e) => {
          if (!this.isDragging || e.touches.length !== 1) return;
          e.preventDefault();
          moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        this.canvas.addEventListener('touchend', endDrag);

        this.canvas.style.cursor = 'grab';
      }

      clampCamera() {
        const vw = this.cssW / (this.baseScale * this.zoom);
        const vh = this.cssH / (this.baseScale * this.zoom);
        this.cameraX = clamp(this.cameraX, -100, this.world.width - vw + 100);
        this.cameraY = clamp(this.cameraY, -100, this.world.height - vh + 100);
      }

      resize() {
        const container = this.canvas.parentElement;
        this.cssW = container.clientWidth;
        this.cssH = container.clientHeight;
        this.dpr = window.devicePixelRatio || 1;

        this.canvas.width = Math.floor(this.cssW * this.dpr);
        this.canvas.height = Math.floor(this.cssH * this.dpr);

        // Auto-fit: baseScale makes the world fit perfectly in the canvas at zoom=1
        const scaleX = this.cssW / this.world.width;
        const scaleY = this.cssH / this.world.height;
        this.baseScale = Math.min(scaleX, scaleY);
        
        // Center camera on world
        this.cameraX = 0;
        this.cameraY = 0;
        
        this.clampCamera();
      }

      render() {
        const ctx = this.ctx;
        const s = this.baseScale * this.zoom;

        // Draw in CSS pixels, with DPR scaling handled by transform.
        ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, this.cssW, this.cssH);

        ctx.save();
        ctx.translate(-this.cameraX * s, -this.cameraY * s);

        // Grid
        ctx.strokeStyle = '#151525';
        ctx.lineWidth = 1;
        const step = 100 * s;
        const maxX = this.world.width * s;
        const maxY = this.world.height * s;
        for (let x = 0; x <= maxX; x += step) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, maxY); ctx.stroke(); }
        for (let y = 0; y <= maxY; y += step) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(maxX, y); ctx.stroke(); }

        // Border
        ctx.strokeStyle = '#ff0055';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, maxX, maxY);

        // Buildings
        for (const b of this.world.buildings) {
          const x = b.x * s, y = b.y * s, w = b.w * s, h = b.h * s;
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + 10, y + 10, w, h);
          ctx.fillStyle = '#111';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = '#334';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
        }

        // Pickups
        for (const p of this.world.pickups) {
          const px = p.x * s, py = p.y * s, pr = p.radius * s;
          
          // Glow effect
          const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
          
          if (p.type === 'health') {
            // Health pack - green cross shape
            ctx.shadowBlur = 15 * pulse;
            ctx.shadowColor = '#00ff9d';
            ctx.fillStyle = '#00ff9d';
            
            // Horizontal bar of cross
            ctx.fillRect(px - pr, py - pr * 0.3, pr * 2, pr * 0.6);
            // Vertical bar of cross
            ctx.fillRect(px - pr * 0.3, py - pr, pr * 0.6, pr * 2);
            
          } else if (p.type === 'armor') {
            // Armor pack - blue kite shield
            ctx.shadowBlur = 15 * pulse;
            ctx.shadowColor = '#00aaff';
            ctx.fillStyle = '#00aaff';
            
            // Kite shield shape (wider at top, pointed at bottom)
            ctx.beginPath();
            ctx.moveTo(px, py - pr * 1.1);           // Top center
            ctx.lineTo(px + pr * 0.8, py - pr * 0.3); // Top right
            ctx.lineTo(px + pr * 0.6, py + pr * 0.4); // Mid right
            ctx.lineTo(px, py + pr * 1.1);            // Bottom point
            ctx.lineTo(px - pr * 0.6, py + pr * 0.4); // Mid left
            ctx.lineTo(px - pr * 0.8, py - pr * 0.3); // Top left
            ctx.closePath();
            ctx.fill();
            
            // Inner highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else if (p.type === 'laser') {
            // Laser pickup - electric bolt shape
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            
            // Lightning bolt shape
            ctx.beginPath();
            ctx.moveTo(px + pr * 0.3, py - pr * 1.2);
            ctx.lineTo(px - pr * 0.1, py - pr * 0.2);
            ctx.lineTo(px + pr * 0.3, py - pr * 0.2);
            ctx.lineTo(px - pr * 0.3, py + pr * 1.2);
            ctx.lineTo(px + pr * 0.1, py + pr * 0.2);
            ctx.lineTo(px - pr * 0.3, py + pr * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Inner glow
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else if (p.type === 'sword') {
            // Sword pickup - energy sword shape (neutral purple until picked up)
            ctx.shadowBlur = 20 * pulse;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff00ff';
            
            // Sword blade shape
            ctx.beginPath();
            ctx.moveTo(px, py - pr * 1.5);           // Tip
            ctx.lineTo(px + pr * 0.3, py - pr * 0.5); // Right edge upper
            ctx.lineTo(px + pr * 0.2, py + pr * 0.8); // Right edge lower
            ctx.lineTo(px, py + pr * 1.2);            // Handle
            ctx.lineTo(px - pr * 0.2, py + pr * 0.8); // Left edge lower
            ctx.lineTo(px - pr * 0.3, py - pr * 0.5); // Left edge upper
            ctx.closePath();
            ctx.fill();
            
            // Inner glow line
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
        }

        // Agents with class-based rendering
        for (const agent of this.world.agents) {
          if (!agent.alive) continue;
          const x = agent.x * s, y = agent.y * s, r = agent.radius * s;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(agent.rotation);

          // Vision cone
          const fov = Math.PI * 0.4;
          const viewDist = 200 * s;
          const grad = ctx.createRadialGradient(0, 0, r, 0, 0, viewDist);
          grad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
          grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, viewDist, -fov / 2, fov / 2);
          ctx.fill();

          // Body
          ctx.shadowBlur = 15;
          const swordColor = agent.team === 0 ? '#ff4444' : '#4488ff';
          ctx.shadowColor = agent.weapon === 'laser' ? '#00ffff' : (agent.weapon === 'sword' ? swordColor : agent.color);
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = agent.weapon === 'laser' ? '#00ffff' : (agent.weapon === 'sword' ? swordColor : agent.color);
          ctx.lineWidth = 2;
          ctx.stroke();

          if (agent.weapon === 'rocket') {
            // Rocket launcher icon
            ctx.fillStyle = '#ff6600';
            ctx.font = 'bold ' + (r * 0.7) + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üöÄ', 0, 0);

            // Rocket launcher weapon
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(r * 0.3, 0);
            ctx.lineTo(r * 1.6, 0);
            ctx.stroke();
            // Launcher tip
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(r * 1.6, 0, 4 * s, 0, Math.PI * 2);
            ctx.fill();
          } else if (agent.weapon === 'laser') {
            // Laser weapon icon
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold ' + (r * 0.7) + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚ö°', 0, 0);

            // Laser weapon barrel
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(r * 0.3, 0);
            ctx.lineTo(r * 1.8, 0);
            ctx.stroke();
            
            // Charging glow
            if (agent.laserCharging && agent.laserCharge > 0) {
              const chargeProgress = agent.laserCharge / 3.0;
              const glowSize = 8 + chargeProgress * 15;
              const glowAlpha = 0.3 + chargeProgress * 0.7;
              
              ctx.shadowBlur = glowSize * s;
              ctx.shadowColor = '#00ffff';
              ctx.fillStyle = `rgba(0, 255, 255, ${glowAlpha})`;
              ctx.beginPath();
              ctx.arc(r * 1.8, 0, (4 + chargeProgress * 8) * s, 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
            }
          } else if (agent.weapon === 'sword') {
            // Energy sword - color based on team
            ctx.fillStyle = swordColor;
            ctx.font = 'bold ' + (r * 0.7) + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üó°Ô∏è', 0, 0);
            
            // Sword blade
            ctx.save();
            if (agent.swordCharging) {
              // Ready stance - sword to the right
              ctx.rotate(Math.PI / 2);
            }
            
            // Draw sword blade
            ctx.shadowBlur = 10;
            ctx.shadowColor = swordColor;
            ctx.strokeStyle = swordColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(r * 0.5, 0);
            ctx.lineTo(r * 2.2, 0);
            ctx.stroke();
            
            // Blade glow tip
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(r * 2.2, 0);
            ctx.lineTo(r * 1.8, -4 * s);
            ctx.lineTo(r * 1.8, 4 * s);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Charging indicator
            if (agent.swordCharging && agent.swordCharge > 0) {
              const chargeProgress = agent.swordCharge / 2.0;
              ctx.shadowBlur = 20 * chargeProgress;
              ctx.shadowColor = swordColor;
              ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + chargeProgress * 0.5})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, r * (1.2 + chargeProgress * 0.5), 0, Math.PI * 2 * chargeProgress);
              ctx.stroke();
              ctx.shadowBlur = 0;
            }
          }

          ctx.restore();
          ctx.shadowBlur = 0;

          // Health bar
          const barW = 30 * s;
          const barH = 4 * s;
          ctx.fillStyle = '#333';
          ctx.fillRect(x - barW / 2, y - r - 12 * s, barW, barH);
          ctx.fillStyle = agent.health > 50 ? '#00ff9d' : '#ff0055';
          ctx.fillRect(x - barW / 2, y - r - 12 * s, barW * (agent.health / agent.maxHealth), barH);
          
          // Armor bar (blue, below health bar)
          if (agent.armor > 0) {
            ctx.fillStyle = '#333';
            ctx.fillRect(x - barW / 2, y - r - 7 * s, barW, barH);
            ctx.fillStyle = '#00aaff';
            ctx.fillRect(x - barW / 2, y - r - 7 * s, barW * (agent.armor / agent.maxArmor), barH);
          }
          
          // Weapon cooldown indicator
          if (agent.weaponCooldown > 0) {
            const cooldownPct = agent.weaponCooldown / ROCKET.fireRate;
            const cooldownY = agent.armor > 0 ? y - r - 2 * s : y - r - 6 * s;
            ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
            ctx.fillRect(x - barW / 2, cooldownY, barW * cooldownPct, 2 * s);
          }
        }

        // Projectiles
        ctx.shadowBlur = 0;
        
        // Smoke particles (draw first, behind rockets)
        for (const p of this.world.smokeParticles) {
          const px = p.x * s, py = p.y * s;
          const alpha = (p.life / p.maxLife) * 0.6;
          const size = p.size * s;
          
          ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
          ctx.beginPath();
          ctx.arc(px, py, size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Rockets
        for (const r of this.world.rockets) {
          if (!r.alive) continue;
          const rx = r.x * s, ry = r.y * s;
          
          ctx.save();
          ctx.translate(rx, ry);
          ctx.rotate(r.angle);
          
          // Flame trail (behind rocket)
          const flameGrad = ctx.createLinearGradient(-35 * s, 0, 0, 0);
          flameGrad.addColorStop(0, 'rgba(255, 100, 0, 0)');
          flameGrad.addColorStop(0.3, 'rgba(255, 150, 0, 0.8)');
          flameGrad.addColorStop(0.6, 'rgba(255, 200, 50, 1)');
          flameGrad.addColorStop(1, 'rgba(255, 255, 200, 1)');
          
          ctx.fillStyle = flameGrad;
          ctx.beginPath();
          ctx.moveTo(-35 * s, 0);
          ctx.lineTo(-8 * s, -6 * s);
          ctx.lineTo(-8 * s, 6 * s);
          ctx.closePath();
          ctx.fill();
          
          // Rocket body
          ctx.fillStyle = '#444';
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(0, 0, 12 * s, 5 * s, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Rocket nose (red tip)
          ctx.fillStyle = '#ff3300';
          ctx.beginPath();
          ctx.moveTo(12 * s, 0);
          ctx.lineTo(6 * s, -4 * s);
          ctx.lineTo(6 * s, 4 * s);
          ctx.closePath();
          ctx.fill();
          
          // Fins
          ctx.fillStyle = '#ff3300';
          ctx.beginPath();
          ctx.moveTo(-8 * s, -5 * s);
          ctx.lineTo(-12 * s, -10 * s);
          ctx.lineTo(-6 * s, -5 * s);
          ctx.closePath();
          ctx.fill();
          
          ctx.beginPath();
          ctx.moveTo(-8 * s, 5 * s);
          ctx.lineTo(-12 * s, 10 * s);
          ctx.lineTo(-6 * s, 5 * s);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }

        // Explosions
        ctx.globalCompositeOperation = 'lighter';
        for (const e of this.world.explosions) {
          const ex = e.x * s, ey = e.y * s;
          const progress = e.timer / e.maxTime;
          const currentRadius = e.splashRadius * s * (0.3 + progress * 0.7);
          
          // Outer shockwave ring
          ctx.strokeStyle = `rgba(255, 100, 0, ${1 - progress})`;
          ctx.lineWidth = 8 * (1 - progress);
          ctx.beginPath();
          ctx.arc(ex, ey, currentRadius, 0, Math.PI * 2);
          ctx.stroke();
          
          // Inner flash
          const innerGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, currentRadius * 0.8);
          innerGrad.addColorStop(0, `rgba(255, 255, 200, ${0.9 - progress * 0.9})`);
          innerGrad.addColorStop(0.3, `rgba(255, 200, 0, ${0.7 - progress * 0.7})`);
          innerGrad.addColorStop(0.6, `rgba(255, 100, 0, ${0.5 - progress * 0.5})`);
          innerGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
          ctx.fillStyle = innerGrad;
          ctx.beginPath();
          ctx.arc(ex, ey, currentRadius * 0.8, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Laser beams (anime style)
        for (const beam of this.world.laserBeams) {
          const progress = beam.timer / beam.maxTime;
          const sx = beam.startX * s, sy = beam.startY * s;
          const ex = beam.endX * s, ey = beam.endY * s;
          
          // Phase 1: Expansion (0 - 0.1)
          // Phase 2: Peak (0.1 - 0.4)
          // Phase 3: Contraction (0.4 - 1.0)
          
          let beamWidth, alpha;
          if (progress < 0.1) {
            // Expanding
            beamWidth = (progress / 0.1) * 25;
            alpha = 1;
          } else if (progress < 0.4) {
            // Peak
            beamWidth = 25;
            alpha = 1;
          } else {
            // Contracting
            const contractProgress = (progress - 0.4) / 0.6;
            beamWidth = 25 * (1 - contractProgress);
            alpha = 1 - contractProgress;
          }
          
          // Outer glow
          ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
          ctx.lineWidth = beamWidth * s * 3;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
          
          // Middle glow
          ctx.strokeStyle = `rgba(100, 255, 255, ${alpha * 0.6})`;
          ctx.lineWidth = beamWidth * s * 1.5;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
          
          // Core beam
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.lineWidth = beamWidth * s * 0.5;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        }
        
        // Sword slashes
        for (const slash of this.world.swordSlashes) {
          const progress = slash.timer / slash.maxTime;
          const sx = slash.startX * s, sy = slash.startY * s;
          const ex = slash.endX * s, ey = slash.endY * s;
          
          const alpha = 1 - progress;
          const slashColor = slash.team === 0 ? 
            `rgba(255, 68, 68, ${alpha})` : 
            `rgba(68, 136, 255, ${alpha})`;
          const glowColor = slash.team === 0 ? '#ff4444' : '#4488ff';
          
          // Calculate perpendicular for slash width
          const dx = ex - sx;
          const dy = ey - sy;
          const len = Math.hypot(dx, dy);
          if (len === 0) continue;
          
          const nx = -dy / len;
          const ny = dx / len;
          const slashWidth = (30 - progress * 25) * s;
          
          // Draw arc slash effect
          ctx.beginPath();
          ctx.moveTo(sx + nx * slashWidth, sy + ny * slashWidth);
          ctx.lineTo(ex + nx * slashWidth * 0.3, ey + ny * slashWidth * 0.3);
          ctx.lineTo(ex - nx * slashWidth * 0.3, ey - ny * slashWidth * 0.3);
          ctx.lineTo(sx - nx * slashWidth, sy - ny * slashWidth);
          ctx.closePath();
          
          // Glow
          ctx.shadowBlur = 20 * alpha;
          ctx.shadowColor = glowColor;
          ctx.fillStyle = slashColor;
          ctx.fill();
          
          // Core white line
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
          ctx.lineWidth = 3 * (1 - progress * 0.5);
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
          
          ctx.shadowBlur = 0;
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // --------------------
    // Init
    // --------------------
    const canvas = document.getElementById('canvas');
    const world = new World(2400, 2400);
    const renderer = new Renderer(canvas, world);

    let population = 100;
    let simSpeed = 1;

    world.spawnAgents(population);

    const ui = {
      gen: document.getElementById('generation'),
      alive: document.getElementById('alive'),
      time: document.getElementById('time-left'),
      leaderboard: document.getElementById('leaderboard'),
      log: document.getElementById('event-log'),
      alltimeLeaderboard: document.getElementById('alltime-leaderboard'),

      zoom: document.getElementById('zoom'),
      speed: document.getElementById('speed'),
      population: document.getElementById('population'),
      roundTime: document.getElementById('round-time'),
      killLimit: document.getElementById('kill-limit'),

      zoomValue: document.getElementById('zoom-value'),
      speedValue: document.getElementById('speed-value'),
      populationValue: document.getElementById('population-value'),
      roundTimeValue: document.getElementById('round-time-value'),
      killLimitValue: document.getElementById('kill-limit-value'),
      killLimitDisplay: document.getElementById('kill-limit-display'),

      // Team score elements (new layout)
      redScore: document.getElementById('red-score'),
      blueScore: document.getElementById('blue-score'),
      redWins: document.getElementById('red-wins'),
      blueWins: document.getElementById('blue-wins'),

      // Toggles
      toggleHealth: document.getElementById('toggle-health'),
      toggleArmor: document.getElementById('toggle-armor'),
      toggleLaser: document.getElementById('toggle-laser'),
      toggleSword: document.getElementById('toggle-sword'),
      toggleFf: document.getElementById('toggle-ff'),
      toggleRicochet: document.getElementById('toggle-ricochet'),

      // Field item counts
      fieldItemsList: document.getElementById('field-items-list'),

      // Respawn time slider
      respawnTime: document.getElementById('respawn-time'),
      respawnTimeValue: document.getElementById('respawn-time-value'),

      pauseBtn: document.getElementById('pause-btn'),
      restartBtn: document.getElementById('restart-btn'),
      saveBtn: document.getElementById('save-btn'),
      loadBtn: document.getElementById('load-btn'),
      loadFile: document.getElementById('load-file'),
      headlessBtn: document.getElementById('headless-btn'),
      headlessOverlay: document.getElementById('headless-overlay'),
      ups: document.getElementById('ups'),
    };

    // Headless mode
    let headlessMode = true;
    ui.headlessOverlay.classList.add('visible');
    
    ui.headlessBtn.addEventListener('click', () => {
      headlessMode = !headlessMode;
      ui.headlessBtn.textContent = headlessMode ? 'üñ•Ô∏è HEADLESS MODE (ON)' : 'üñ•Ô∏è HEADLESS MODE (OFF)';
      ui.headlessBtn.style.background = headlessMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(100, 100, 100, 0.1)';
      ui.headlessBtn.style.borderColor = headlessMode ? '#0f0' : '#888';
      ui.headlessBtn.style.color = headlessMode ? '#0f0' : '#888';
      ui.headlessOverlay.classList.toggle('visible', headlessMode);
    });

    // Toggle handlers - connect to world
    ui.toggleFf.addEventListener('click', () => {
      if (ui.toggleFf.classList.contains('disabled')) return;
      ui.toggleFf.classList.toggle('active');
      world.friendlyFire = ui.toggleFf.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFire) {
        ui.toggleRicochet.classList.add('disabled');
        ui.toggleRicochet.classList.remove('active');
        world.friendlyFireRicochet = false;
      } else {
        ui.toggleRicochet.classList.remove('disabled');
      }
    });

    ui.toggleRicochet.addEventListener('click', () => {
      if (ui.toggleRicochet.classList.contains('disabled')) return;
      ui.toggleRicochet.classList.toggle('active');
      world.friendlyFireRicochet = ui.toggleRicochet.classList.contains('active');
      // Mutual exclusion
      if (world.friendlyFireRicochet) {
        ui.toggleFf.classList.add('disabled');
        ui.toggleFf.classList.remove('active');
        world.friendlyFire = false;
      } else {
        ui.toggleFf.classList.remove('disabled');
      }
    });

    // Respawn time slider
    ui.respawnTime.addEventListener('input', (e) => {
      const seconds = parseInt(e.target.value, 10);
      world.respawnTime = seconds;
      ui.respawnTimeValue.textContent = seconds + 's';
    });

    // Health/Armor toggle handlers
    ui.toggleHealth.addEventListener('click', () => {
      ui.toggleHealth.classList.toggle('active');
      world.healthSpawnsEnabled = ui.toggleHealth.classList.contains('active');
    });

    ui.toggleArmor.addEventListener('click', () => {
      ui.toggleArmor.classList.toggle('active');
      world.armorSpawnsEnabled = ui.toggleArmor.classList.contains('active');
    });

    ui.toggleLaser.addEventListener('click', () => {
      ui.toggleLaser.classList.toggle('active');
      world.laserSpawnsEnabled = ui.toggleLaser.classList.contains('active');
    });

    ui.toggleSword.addEventListener('click', () => {
      ui.toggleSword.classList.toggle('active');
      world.swordSpawnsEnabled = ui.toggleSword.classList.contains('active');
    });

    // Sliders
    ui.zoom.addEventListener('input', (e) => {
      renderer.zoom = parseInt(e.target.value, 10) / 100;
      renderer.clampCamera();
      ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    });

    ui.speed.addEventListener('input', (e) => {
      simSpeed = parseInt(e.target.value, 10);
      ui.speedValue.textContent = simSpeed + 'x';
    });

    ui.population.addEventListener('input', (e) => {
      population = parseInt(e.target.value, 10);
      ui.populationValue.textContent = String(population);
      world.spawnAgents(population);
    });

    ui.roundTime.addEventListener('input', (e) => {
      const minutes = parseInt(e.target.value, 10);
      world.setRoundTimeSeconds(minutes * 60);
      ui.roundTimeValue.textContent = String(minutes);
    });
    
    ui.killLimit.addEventListener('input', (e) => {
      world.killLimit = parseInt(e.target.value, 10);
      ui.killLimitValue.textContent = String(world.killLimit);
      ui.killLimitDisplay.textContent = String(world.killLimit);
    });

    // Pause/Reset
    ui.pauseBtn.addEventListener('click', (e) => {
      world.paused = !world.paused;
      e.target.textContent = world.paused ? 'RESUME' : 'PAUSE';
    });

    ui.restartBtn.addEventListener('click', () => {
      world.generation = 1;
      world.events = [];
      world.teamBrains = [null, null];
      world.pickups = [];
      world.pickupTimer = 0;
      world.nextPickupType = 'health';
      world.laserSpawned = false;
      world.laserBeams = [];
      world.swordSpawned = false;
      world.swordSlashes = [];
      world.spawnAgents(population);
    });

    // Save checkpoint to localStorage
    ui.saveBtn.addEventListener('click', () => {
      const checkpoint = {
        version: '2.8',
        timestamp: Date.now(),
        generation: world.generation,
        teamWins: world.teamWins,
        teamBrains: world.teamBrains.map(b => b ? {
          weightsIH: b.weightsIH.map(row => Array.from(row)),
          weightsHO: b.weightsHO.map(row => Array.from(row)),
          biasH: Array.from(b.biasH),
          biasO: Array.from(b.biasO),
          inputSize: b.inputSize,
          hiddenSize: b.hiddenSize,
          outputSize: b.outputSize
        } : null)
      };
      
      localStorage.setItem('quake-checkpoint', JSON.stringify(checkpoint));
      world.addEvent('üíæ Checkpoint saved! Gen ' + world.generation, 'kill');
      ui.saveBtn.textContent = 'üíæ SAVED!';
      setTimeout(() => ui.saveBtn.textContent = 'üíæ SAVE', 1000);
    });

    // Load checkpoint from localStorage
    ui.loadBtn.addEventListener('click', () => {
      try {
        const data = localStorage.getItem('quake-checkpoint');
        if (!data) {
          alert('No checkpoint found!');
          return;
        }
        
        const checkpoint = JSON.parse(data);
        
        world.generation = checkpoint.generation || 1;
        world.teamWins = checkpoint.teamWins || [0, 0];
        
        // Restore brains
        world.teamBrains = checkpoint.teamBrains.map(b => {
          if (!b) return null;
          const brain = new NeuralNetwork(b.inputSize, b.hiddenSize, b.outputSize);
          brain.weightsIH = b.weightsIH.map(row => [...row]);
          brain.weightsHO = b.weightsHO.map(row => [...row]);
          brain.biasH = [...b.biasH];
          brain.biasO = [...b.biasO];
          return brain;
        });
        
        // Respawn with loaded brains
        world.spawnAgents(population);
        
        const savedTime = new Date(checkpoint.timestamp).toLocaleTimeString();
        world.addEvent('üìÇ Loaded Gen ' + world.generation + ' (saved ' + savedTime + ')', 'kill');
        ui.loadBtn.textContent = 'üìÇ LOADED!';
        setTimeout(() => ui.loadBtn.textContent = 'üìÇ LOAD', 1000);
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    });

    // Hotkeys: Space pause, R reset, F fullscreen
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        world.paused = !world.paused;
        ui.pauseBtn.textContent = world.paused ? 'RESUME' : 'PAUSE';
      } else if (e.code === 'KeyR') {
        world.generation = 1;
        world.events = [];
        world.teamBrains = [null, null];
        world.spawnAgents(population);
      } else if (e.code === 'KeyF') {
        ui.fullscreenBtn.click();
      }
    });

    // Resize
    window.addEventListener('resize', () => renderer.resize());

    // --------------------
    // Game loop (fixed timestep)
    // --------------------
    const FIXED_DT = 1 / 60;
    let accumulator = 0;
    let lastTime = performance.now();

    // UPS tracking
    let upsCounter = 0;
    let upsTimer = 0;
    let currentUps = 60;

    let uiTimer = 0;
    const UI_INTERVAL = 0.2; // seconds

    function drawUI(dt) {
      uiTimer += dt;
      if (uiTimer < UI_INTERVAL) return;
      uiTimer = 0;

      ui.gen.textContent = world.generation;
      ui.alive.textContent = world.agents.filter(a => a.alive).length;
      ui.time.textContent = Math.ceil(world.timeLeft) + 's';
      
      // UPS display with color coding
      ui.ups.textContent = currentUps;
      if (currentUps >= 55) {
        ui.ups.style.color = '#00ff9d';
      } else if (currentUps >= 30) {
        ui.ups.style.color = '#ffc800';
      } else {
        ui.ups.style.color = '#ff4444';
      }
      
      // Team scores (new layout)
      ui.redScore.textContent = world.teamKills[0];
      ui.blueScore.textContent = world.teamKills[1];
      ui.redWins.textContent = world.teamWins[0];
      ui.blueWins.textContent = world.teamWins[1];

      // Field items (dynamic based on active toggles with actual counts)
      const healthCount = world.pickups.filter(p => p.type === 'health').length;
      const armorCount = world.pickups.filter(p => p.type === 'armor').length;
      const laserCount = world.pickups.filter(p => p.type === 'laser').length;
      const swordCount = world.pickups.filter(p => p.type === 'sword').length;
      
      let fieldItemsHtml = '';
      if (ui.toggleHealth.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="Heals 50HP instantly"><span>ü©π Health</span><span class="stat-value">' + healthCount + '</span></div>';
      }
      if (ui.toggleArmor.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="+50 armor per pickup, max 100"><span>üõ°Ô∏è Armor</span><span class="stat-value">' + armorCount + '</span></div>';
      }
      if (ui.toggleLaser.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="3s charge, instant kill beam"><span>‚ö° Laser</span><span class="stat-value">' + laserCount + '</span></div>';
      }
      if (ui.toggleSword.classList.contains('active')) {
        fieldItemsHtml += '<div class="stat-row" title="Hold to charge, release to lunge"><span>üó°Ô∏è Sword</span><span class="stat-value">' + swordCount + '</span></div>';
      }
      if (!fieldItemsHtml) {
        fieldItemsHtml = '<div class="stat-row" style="opacity: 0.5; font-size: 0.75rem;">No active spawns</div>';
      }
      ui.fieldItemsList.innerHTML = fieldItemsHtml;

      // This round leaderboard
      ui.leaderboard.innerHTML = world.getLeaderboard().map((a, i) => {
        const status = a.alive ? '' : (a.respawnTimer > 0 ? ' (' + Math.ceil(a.respawnTimer) + 's)' : '');
        const kd = a.kills + '/' + a.deaths;
        return '<div class="leader-entry ' + (a.alive ? '' : 'dead') + '" style="border-left: 2px solid ' + (a.team === 0 ? '#ff4444' : '#4488ff') + '">' +
          '<span class="name" style="color: ' + (a.team === 0 ? '#ff8888' : '#88aaff') + '">' + a.name + status + '</span>' +
          '<span class="score">' + a.score + '</span>' +
        '</div>';
      }).join('');

      // All-time legends leaderboard
      const allTimeSorted = [...world.agents].sort((a, b) => b.totalKills - a.totalKills).slice(0, 5);
      ui.alltimeLeaderboard.innerHTML = allTimeSorted.map((a, i) => {
        const medal = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : ''));
        return '<div class="leader-entry" style="border-left: 2px solid ' + (a.team === 0 ? '#ff4444' : '#4488ff') + '">' +
          '<span class="name" style="color: ' + (a.team === 0 ? '#ff8888' : '#88aaff') + '">' + medal + ' ' + a.name + '</span>' +
          '<span class="score">' + a.totalKills + 'K</span>' +
        '</div>';
      }).join('');

      ui.log.innerHTML = world.events.slice(0, 10).map(e =>
        '<div class="event"><span class="' + e.type + '">' + e.text + '</span></div>'
      ).join('');
    }

    function gameLoop(curr) {
      const realDt = Math.min((curr - lastTime) / 1000, 0.1);
      lastTime = curr;

      // UPS tracking
      upsTimer += realDt;
      if (upsTimer >= 1.0) {
        currentUps = upsCounter;
        upsCounter = 0;
        upsTimer = 0;
      }

      // scale by simSpeed into the simulation accumulator
      accumulator += realDt * simSpeed;

      // prevent spiral of death - but allow more steps in headless mode
      const maxSteps = headlessMode ? 100 : 12;
      let steps = 0;
      while (accumulator >= FIXED_DT && steps < maxSteps) {
        world.update(FIXED_DT);
        accumulator -= FIXED_DT;
        steps++;
        upsCounter++;
      }
      // if we hit max steps, drop the rest to keep UI responsive
      if (steps === maxSteps) accumulator = 0;

      // Only render if not headless
      if (!headlessMode) {
        renderer.render();
      }
      drawUI(realDt);

      requestAnimationFrame(gameLoop);
    }

    // Initialize UI values
    ui.zoomValue.textContent = renderer.zoom.toFixed(1) + 'x';
    ui.speedValue.textContent = simSpeed + 'x';
    ui.populationValue.textContent = String(population);
    ui.roundTimeValue.textContent = String(parseInt(ui.roundTime.value, 10));
    ui.killLimitValue.textContent = String(world.killLimit);

    requestAnimationFrame(gameLoop);
  })();
  </script>

</body>
</html>
